<?xml version="1.0" encoding="utf-8" ?>
<!--

 Copyright Â© 2009-2020 Intel Corporation. All rights reserved.

 The information contained herein is the exclusive property of
 Intel Corporation and may not be disclosed, examined, or reproduced in
 whole or in part without explicit written authorization from the Company.

-->
<xmc version="1.0">
    <catalog name="viewpoint" lang="en">
      <msg name="%fastFinalizationNotification">Finalization mode: Fast. If the number of collected samples exceeds the threshold, this mode limits the number of processed samples to speed up post-processing.</msg>
      <msg name='%WSMEXBandwidthViewpointName'>Bandwidth</msg>
      <msg name='%WSMEXBandwidthViewpointShortName'>Bandwidth</msg>
      <msg name='%WSMEXBandwidthViewpointDescription'>This view uses &lt;a href='configs.ebs_collection_f1114'&gt;hardware event-based metrics&lt;/a&gt; to quantify bandwidth over time and show code regions where the application is generating significant bandwidth to DRAM. Memory bandwidth, in GB/sec, is plotted over time in the Timeline, while metrics for events often associated with DRAM requests are shown in the grid. Hover over a metric name in the &lt;a href='configs.bottomup_pane_f1130'&gt;grid&lt;/a&gt; for the metric description.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Select a region of high bandwidth in the Timeline, filter that region in, and identify bottlenecks.&lt;br&gt;- Analyze the grid to discover where in the code DRAM accesses are generated.&lt;br&gt;- &lt;a href='configs.view_source_f1119'&gt;Analyze the source&lt;/a&gt; by double-clicking a hotspot and identify its most critical code lines.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%SNBGeneralExplorationViewpointName'>Microarchitecture Exploration</msg>
      <msg name='%SNBGeneralExplorationViewpointShortName'>Microarchitecture Exploration</msg>
      <msg name='%SNBGeneralExplorationViewpointDescription'>This view uses &lt;a href='configs.ebs_collection_f1114'&gt;hardware event-based metrics&lt;/a&gt; to show code regions that experienced potentially significant architectural bottlenecks. Hover over a metric name in the &lt;a href='configs.bottomup_pane_f1130'&gt;grid&lt;/a&gt; for the metric description.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Identify code regions (modules, functions, and so on) with the highest execution time.&lt;br&gt;- &lt;a href='configs.interpret_gen_exp_f1116'&gt;Analyze detected hardware issues&lt;/a&gt; highlighted by pink cells and get tuning recommendations.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%SNBBandwidthViewpointName'>Memory Usage</msg>
      <msg name='%SNBBandwidthViewpointShortName'>Memory Usage</msg>
      <msg name='%SNBBandwidthViewpointDescription'>This view uses &lt;a href='configs.ebs_collection_f1114'&gt;hardware event-based metrics&lt;/a&gt; to characterize how effectively your application uses memory resources and identify potential memory access related issues like excessive access to remote memory on NUMA platforms, hitting DRAM or Intel QPI bandwidth limit, and others. It provides various performance metrics for both the application code and memory objects arrays.</msg>
      <msg name='%SNBQPIBandwidthViewpointName'>QPI Bandwidth</msg>
      <msg name='%SNBQPIBandwidthViewpointShortName'>QPI Bandwidth</msg>
      <msg name='%SNBQPIBandwidthViewpointDescription'>This view uses &lt;a href='configs.ebs_collection_f1114'&gt;hardware event-based metrics&lt;/a&gt; to quantify QPI bandwidth over time and show code regions where the application is generating significant bandwidth across the QPI links. Transmit bandwidth, in GB/sec, is plotted over time in the Timeline, while metrics for events often associated with DRAM requests are shown in the grid. Hover over a metric name in the &lt;a href='configs.bottomup_pane_f1130'&gt;grid&lt;/a&gt; for the metric description.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Select a region of high bandwidth in the Timeline, filter that region in, and identify bottlenecks.&lt;br&gt;- Analyze the grid to discover where in the code QPI packets are generated.&lt;br&gt;- &lt;a href='configs.view_source_f1119'&gt;Analyze the source&lt;/a&gt; by double-clicking a hotspot and identify its most critical code lines.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%HardwareIssuesViewpointName'>Hardware Issues</msg>
      <msg name='%HardwareIssuesViewpointShortName'>Hardware Issues</msg>
      <msg name='%HardwareIssuesViewpointDescription'>This view uses &lt;a href='configs.ebs_collection_f1114'&gt;hardware event-based metrics&lt;/a&gt; to show code regions that experienced potentially significant architectural bottlenecks. Hover over a metric name in the &lt;a href='configs.bottomup_pane_f1130'&gt;grid&lt;/a&gt; for the metric description.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Identify code regions (modules, functions, and so on) where the application poorly utilizes available hardware resources.&lt;br&gt;- &lt;a href='configs.interpret_hw_issues_f1117'&gt;Analyze detected hardware issues&lt;/a&gt; highlighted by pink cells and get tuning recommendations.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%LightweightHotspotsViewpointName'>Hotspots</msg>
      <msg name='%LightweightHotspotsViewpointShortName'>Hotspots</msg>
      <msg name='%LightweightHotspotsViewpointDescription'>This view uses &lt;a href='configs.ebs_collection_f1114'&gt;hardware event-based collection&lt;/a&gt; to display code regions (modules, functions, and so on) that consume a lot of CPU time (hotspots).&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- &lt;a href='configs.interpret_hs_f1118'&gt;Identify and analyze hotspots&lt;/a&gt; with the highest CPU time values and high CPI rate.&lt;br&gt;- Filter hotspots to identify hotspots for a specific time region.&lt;br&gt;- &lt;a href='configs.view_source_f1119'&gt;Analyze the source&lt;/a&gt; by double-clicking a hotspot and identify its most critical code lines.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%PerfSnapshotViewpointName'>Performance Snapshot</msg>
      <msg name='%PerfSnapshotViewpointShortName'>Performance Snapshot</msg>
      <msg name='%PerfSnapshotViewpointDescription'>Characterize your workload and identify relevant analysis types.</msg>
      <msg name='%SystemOverviewViewpointName'>System Overview</msg>
      <msg name='%SystemOverviewViewpointShortName'>System Overview</msg>
      <msg name='%SystemOverviewViewpointDescription'>Analyze general behavior of a Linux, Android or Windows target system including CPU/GPU utilization, DRAM/PCIe bandwidth, and input/output data transfers.</msg>
      <msg name='%GpuHotspotsViewpointName'>GPU Compute/Media Hotspots</msg>
      <msg name='%GpuHotspotsViewpointShortName'>GPU Compute/Media Hotspots</msg>
      <msg name='%GpuHotspotsViewpointDescription'>This view helps identify GPU tasks with high GPU utilization and estimate its effectiveness. It is particularly useful for analysis of the OpenCL kernels and Intel Media SDK tasks.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Identify the &lt;a href='configs.interpret_gpu_hotspots'&gt;most time-consuming GPU computing tasks&lt;/a&gt;.&lt;br&gt;- Analyze GPU tasks execution over time.&lt;br&gt;- Explore the GPU hardware metrics per GPU architecture blocks.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%GraphicsRenderingViewpointName'>GPU Rendering</msg>
      <msg name='%GraphicsRenderingViewpointShortName'>GPU Rendering</msg>
      <msg name='%GraphicsRenderingViewpointDescription'>This view provides platform-wide CPU/GPU utilization and efficiency statistics collected with GPU Rendering analysis including dedicated support for the Xen virtualization platform.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Analyze CPU/GPU utilization and efficiency on all the virtual domains.&lt;br&gt;- Inspect which domain occupies too many resources and becomes a bottleneck for the whole platform utilization.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%OpenMPHotspotsViewpointName'>HPC Performance Characterization</msg>
      <msg name='%OpenMPHotspotsViewpointDescription'>This view displays &lt;a href='configs.interpret_hpc'&gt;performance statistics for applications using OpenMP and MPI runtimes&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Explore OpenMP code optimization &lt;a href='configs.potential_gain_f1138'&gt;Potential Gain&lt;/a&gt; by parallelization inefficiencies representing their wall time cost.&lt;br&gt;- Explore precise Imbalance metrics to identify imbalance of working threads on barriers.&lt;br&gt;- Analyze barrier-to-barrier region segments to explore performance of OpenMP work-sharing constructs and barrier cost inside a region.&lt;br&gt;- For hybrid MPI and OpenMP applications using Intel MPI library, analyze per-rank MPI communication busy wait time.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%OpenMPHotspotsViewpointShortName'>HPC Performance Characterization</msg>
      <msg name='%PerformanceAspects'>Performance Aspects</msg>
      <msg name='%VectHotspotsViewpointName'>Hotspots with Vectorization Info</msg>
      <msg name='%VectHotspotsByCPUUsageViewpointName'>Hotspots by CPU Utilization with Vectorization Info</msg>
      <msg name='%VectLightweightHotspotsViewpointName'>Hotspots with Vectorization Info</msg>
      <msg name='%VectHardwareIssuesViewpointName'>Hardware Issues with Vectorization Info</msg>
      <msg name='%VectPMUEventsViewpointName'>Hardware Event Counts with Vectorization Info</msg>
      <msg name='%VectSamplesViewpointName'>Hardware Event Sample Counts with Vectorization Info</msg>
      <msg name='%VectPMUSamplesViewpointName'>Hardware Event Sample Counts with Vectorization Info</msg>
      <msg name='%HotspotsByCPUUsageViewpointName'>Hotspots by CPU Utilization</msg>
      <msg name='%HotspotsByCPUUsageViewpointShortName'>Hotspots by CPU Utilization</msg>
      <msg name='%HotspotsByCPUUsageViewpointDescription'>This view displays code regions (modules, functions, and so on) that consume a lot of CPU time (hotspots). CPU time is represented by bars colored according to the &lt;a href='configs.cpu_usage_f1120'&gt;CPU utilization level&lt;/a&gt;: idle, poor, okay, ideal, and over-committed.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- &lt;a href='configs.interpret_hs_f1118'&gt;Identify hotspots&lt;/a&gt; with the highest CPU time values.&lt;br&gt;- Analyze how much available processing time (from a maximum of the product of CPU Count and Elapsed Time) was spent executing your application.&lt;br&gt;- Filter hotspots to identify hotspots for a specific time region.&lt;br&gt;- &lt;a href='configs.view_source_f1119'&gt;Analyze the source&lt;/a&gt; by double-clicking a hotspot and identify its most critical code lines.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%HotspotsByThreadConcurrencyViewpointName'>Hotspots by Thread Concurrency</msg>
      <msg name='%HotspotsByThreadConcurrencyViewpointShortName'>Hotspots by Thread Concurrency</msg>
      <msg name='%HotspotsByThreadConcurrencyViewpointDescription'>This view displays code regions (modules, functions, and so on) that consume a lot of CPU time (hotspots). CPU time is categorized into &lt;a href='configs.thread_concurrency_f1122'&gt;thread concurrency states&lt;/a&gt;: idle, poor, okay, ideal, and over-committed.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- &lt;a href='configs.interpret_hs_f1118'&gt;Identify hotspots&lt;/a&gt; with the highest CPU time values.&lt;br&gt;- Analyze whether the logical threads of your application were scheduled on the system CPUs effectively.&lt;br&gt;- Filter hotspots to identify hotspots for a specific time region.&lt;br&gt;- &lt;a href='configs.view_source_f1119'&gt;Analyze the source&lt;/a&gt; by double-clicking a hotspot and identify its most critical code lines.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%ThreadingEfficiencyViewpointName'>Threading Efficiency</msg>
      <msg name='%ThreadingEfficiencyViewpointShortName'>Threading Efficiency</msg>
      <msg name='%ThreadingEfficiencyViewpointDescription'>This view displays code regions (modules, functions, and so on) that consume a lot of CPU time (hotspots). CPU time is categorized into &lt;a href='configs.thread_concurrency_f1122'&gt;thread concurrency states&lt;/a&gt;: idle, poor, okay, ideal, and over-committed.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- &lt;a href='configs.interpret_hs_f1118'&gt;Identify hotspots&lt;/a&gt; with the highest CPU time values.&lt;br&gt;- Analyze whether the logical threads of your application were scheduled on the system CPUs effectively.&lt;br&gt;- Filter hotspots to identify hotspots for a specific time region.&lt;br&gt;- &lt;a href='configs.interpret_thread'&gt;Analyze the source&lt;/a&gt; by double-clicking a hotspot and identify its most critical code lines.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%HotspotsCounterViewpointName'>CPU Time Hotspots, Counters, and Stacks</msg>
      <msg name='%HotspotsCounterViewpointShortName'>Hotspots with Counters</msg>
      <msg name='%UncoreEventsViewpointName'>Off-core Hardware Event Counts</msg>
      <msg name='%UncoreEventsViewpointShortName'>Off-core Hardware Event Counts</msg>
      <msg name='%UncoreEventsViewpointDescription'>This view uses &lt;a href='configs.ebs_collection_f1114'&gt;hardware event-based collection&lt;/a&gt; to display an estimated event count for all monitored off-core hardware events. Hover over an event name for more information.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Identify packages with the highest count for an event of interest.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%PMUEventsViewpointName'>Hardware Events</msg>
      <msg name='%PMUEventsViewpointShortName'>Hardware Events</msg>
      <msg name='%PMUEventsViewpointDescription'>This view uses &lt;a href='configs.ebs_collection_f1114'&gt;hardware event-based collection&lt;/a&gt; to display statistics of monitored hardware events: estimated count and/or the number of samples collected. Hover over an event name for more information.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;-Identify code regions (modules, functions, and so on) with the highest activity for an event of interest.&lt;br&gt;- &lt;a href='configs.view_source_f1119'&gt;Analyze the source&lt;/a&gt; by double-clicking a program unit and identify its most critical code lines.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%LocksAndWaitsViewpointName'>Locks and Waits</msg>
      <msg name='%LocksAndWaitsViewpointShortName'>Locks and Waits</msg>
      <msg name='%LocksAndWaitsViewpointDescription'>This view shows CPU time utilization of synchronization objects. CPU time is represented by bars colored according to the &lt;a href='configs.cpu_usage_f1120'&gt;CPU utilization level&lt;/a&gt; during the wait: idle, poor, okay, ideal, and over-committed.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- &lt;a href='configs.interpret_lw_f1129'&gt;Identify synchronization objects&lt;/a&gt; with high Wait Time and Wait Count values that under-utilize available cores (red bars).&lt;br&gt;- Analyze the cause of ineffective utilization.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%LocksAndWaitsCounterViewpointName'>Locks and Waits with Counters</msg>
      <msg name='%LocksAndWaitsCounterViewpointShortName'>Locks and Waits with Counters</msg>
      <msg name='%AtomGeneralExplorationViewpointName'>Microarchitecture Exploration</msg>
      <msg name='%AtomGeneralExplorationViewpointShortName'>Microarchitecture Exploration</msg>
      <msg name='%AtomGeneralExplorationViewpointDescription'>This view uses &lt;a href='configs.ebs_collection_f1114'&gt;hardware event-based metrics&lt;/a&gt; to show code regions that experienced potentially significant architectural bottlenecks. Hover over a metric name in the &lt;a href='configs.bottomup_pane_f1130'&gt;grid&lt;/a&gt; for the metric description.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Identify code regions (modules, functions, and so on) with the highest execution time.&lt;br&gt;- Analyze detected hardware issues highlighted by pink cells and get tuning recommendations.&lt;br&gt;&lt;br&gt;Press F1 for help on each window.</msg>
      <msg name='%CPUFrequencyViewpointName'>CPU Frequency</msg>
      <msg name='%CPUFrequencyViewpointShortName'>CPU Frequency</msg>
      <msg name='%CPUFrequencyViewpointDescription'>This view displays the time spent in different frequency modes and frequency transitions.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Analyze the &lt;a href='configs.bottomup_pane_f1130'&gt;grid&lt;/a&gt; to identify cores with the most time spent in the high frequency modes. Spending more time in low frequency modes provides greater power savings.&lt;br&gt;- Analyze the Timeline and identify cores with the highest count of frequency transitions.&lt;br&gt;&lt;br&gt;Press F1 for help on each window.</msg>
      <msg name='%CPUSleepStatesViewpointName'>CPU Sleep States</msg>
      <msg name='%CPUSleepStatesViewpointShortName'>CPU Sleep States</msg>
      <msg name='%CPUSleepStatesViewpointDescription'>This view displays the time spent in each sleep state and provides information on processor wake-ups: time and cause. Eliminate wake-ups where possible and maximize the time spent in the deepest sleep state to achieve lower power consumption.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Analyze the &lt;a href='configs.bottomup_pane_f1130'&gt;grid&lt;/a&gt; to identify cores with the highest time spent in the active C0 state. Spending more time in deeper sleep states (C1-Cn) provides greater power savings.&lt;br&gt;- Identify causes of processor wake-ups. For timer wake-ups, explore the associated call stacks.&lt;br&gt;- &lt;a href='configs.view_source_f1119'&gt;Analyze the source&lt;/a&gt; by double-clicking a wake-up reason on the Timeline to identify a code region that may be contributing to higher power consumption. Source analysis for timers from user code (ring 3) is not supported for system-wide collection (without specifying a target).&lt;br&gt;&lt;br&gt;Press F1 for help on each window.</msg>
      <msg name='%PlatformProfilingViewpointName'>Platform Analyzer</msg>
      <msg name='%PlatformProfilingViewpointShortName'>Platform Analyzer</msg>
      <msg name='%PlatformProfilingViewpointDescription'>This view provides platform-wide statistics collected with &lt;a href='configs.cpu_gpu_concurrency_f1178'&gt;CPU/GPU Concurrency analysis&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Analyze GPU utilization and a software queue for GPU engines at each moment of time.&lt;br&gt;- Explore your application performance for user tasks created with Intel ITT API.&lt;br&gt;- Inspect CPU and GPU utilization, frame rate and memory bandwidth.&lt;br&gt;- Correlate CPU and GPU activity and identify whether your application is GPU or CPU bound.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%CPUGPUConcurrencyViewpointName'>Platform View</msg>
      <msg name='%CPUGPUConcurrencyViewpointShortName'>Platform View</msg>
      <msg name='%CPUPowerAndPerformanceEventsViewpointName'>CPU Power And Performance Events</msg>
      <msg name='%CPUPowerAndPerformanceEventsViewpointShortName'>CPU Power And Performance Events</msg>
      <msg name='%CPUPowerAndPerformanceEventsViewpointDescription'>This view displays the power and hardware events on the same timeline and helps in correlating behaviors. Eliminate wake-ups where possible and maximize the time spent in the deepest sleep state to achieve lower power consumption. Press F1 for help on each window.</msg>
      <msg name='%DiskIOViewpointName'>Input and Output</msg>
      <msg name='%DiskIOViewpointShortName'>Input and Output</msg>
      <msg name='%DiskIOViewpointDescription'>This view shows input/output data, CPU and bus utilization statistics correlated with the execution of your target.&lt;/a&gt; &lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Identify long latency of IO requests.&lt;br&gt;- &lt;a href='configs.interpret_io_analysis'&gt;Analyze slow IO requests &lt;/a&gt; on the timeline and identify imbalance between IO and compute operations.&lt;br&gt;- Analyze the call stack for IO functions.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%MemoryConsumptionViewpointName'>Memory Consumption</msg>
      <msg name='%MemoryConsumptionViewpointShortName'>Memory Consumption</msg>
      <msg name='%MemoryConsumptionViewpointDescription'>This view provides memory allocation data and shows which stack and object was stored in the RAM.&lt;/a&gt; &lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Identify memory objects and code lines with the highest memory consumption.&lt;br&gt; - Analyze the call stack for every allocation you are interested in.&lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%UnknownTab'>Unknown</msg>
      <msg name='%AnalysisTarget'>Analysis Target</msg>
      <msg name='%AnalysisTargetToolTip'></msg>
      <msg name='%AnalysisType'>Analysis Type</msg>
      <msg name='%AnalysisTypeToolTip'></msg>
      <msg name='%AnalysisConfiguration'>Analysis Configuration</msg>
      <msg name='%AnalysisConfigurationTooltip'></msg>
      <msg name='%CollectionLog'>Collection Log</msg>
      <msg name='%CollectionLogToolTip'></msg>
      <msg name='%ErrorTab'>Error</msg>
      <msg name='%GraphicsTabName'>Graphics</msg>
      <msg name='%IOTabName'>IO</msg>
      <msg name='%IOQueueDepth'>I/O Queue Depth</msg>
      <msg name='%IOOperation'>I/O Operations</msg>
      <msg name='%IOBytes'>I/O Data Transfer</msg>
      <msg name='%IOThroughput'>R/W Ratio</msg>
      <msg name='%IOTotal'>Total</msg>
      <msg name='%IOOperationType'>Operation Type</msg>
      <msg name='%IOOperationCountDescription'>Number of I/O operations processed by storage device(s)</msg>
      <msg name='%IOBytesCountDescription'>Number of bytes processed by I/O operations</msg>
      <msg name='%IOQueueCountDescription'>Number of I/O operations processed by OS I/O queue</msg>
      <msg name='%IOBinType'>Operation Type</msg>
      <msg name='%IOBinDuration'>Duration (sec)</msg>
      <msg name='%IOSlowRequest'>Slow</msg>
      <msg name='%IOGoodRequest'>Good</msg>
      <msg name='%IOFastRequest'>Fast</msg>
      <msg name='%IOFunction'>I/O APIs</msg>
      <msg name='%IOFunctionName'>I/O API</msg>
      <msg name='%IOFunctionDurationType'>I/O API Duration Type</msg>
      <msg name='%IOFunctionEndCallStack'>I/O API End Call Stack</msg>
      <msg name='%CPUActivity'>CPU Activity</msg>
      <msg name='%HardwareIssuesBottomUpWindowDescription'>Identify Hardware Issues per Grouping</msg>
      <msg name='%HardwareIssuesSummaryWindowDescription'>Identify Application-level Hardware Issues</msg>
      <msg name='%HardwareIssuesTimelineWindowDescription'>Analyze Hardware Issues Plotted over Time</msg>
      <msg name='%SNBGeneralExplorationBottomUpWindowDescription'>Analyze Pipeline Execution per Grouping</msg>
      <msg name='%SNBGeneralExplorationSummaryWindowDescription'>Analyze Application-level Pipeline Execution</msg>
      <msg name='%SNBGeneralExplorationTimelineWindowDescription'>Analyze Pipeline Execution Metrics Plotted over Time</msg>
      <msg name='%BandwidthBottomUpWindowDescription'>Analyze Bandwidth over Time</msg>
      <msg name='%BandwidthSummaryWindowDescription'>Explore Application-level Bandwidth</msg>
      <msg name='%BandwidthTimelineWindowDescription'>Analyze Bandwidth over Time</msg>
      <msg name='%BottomUpWindow'>Bottom-up</msg>
      <msg name='%PMUBottomUpWindow'>PMU Events</msg>
      <msg name='%EventCountBottomUpWindow'>Event Count</msg>
      <msg name='%EventSampleCountBottomUpWindow'>Sample Count</msg>
      <msg name='%IPTDetailsDiff'>Intel Processor Trace Details</msg>
      <msg name='%CallStackTab'>Call Stack</msg>
      <msg name='%FilterBar'>Filter</msg>
      <msg name='%HotspotsBottomUpWindowDescription'>Analyze Hotspots and Their Callers</msg>
      <msg name='%HotspotsStackWindowDescription'>Hotspots Stack Window</msg>
      <msg name='%HotspotsSummaryWindowDescription'>Identify Application-level Hotspots</msg>
      <msg name='%HotspotsTimelineWindowDescription'>Hotspots Metrics over Time</msg>
      <msg name='%HotspotsTopDownTreeWindowDescription'>Analyze Hotspots and Their Callees</msg>
      <msg name='%HotspotsCallerCalleeWindowDescription'>Analyze Hot Subtrees</msg>
      <msg name='%LightweightHotspotsBottomUpWindowDescription'>Analyze Hotspots and Their Callers</msg>
      <msg name='%LightweightHotspotsCallerCalleeWindowDescription'>Analyze Hot Subtrees</msg>
      <msg name='%LightweightHotspotsSummaryWindowDescription'>Identify Application-level Hotspots</msg>
      <msg name='%LightweightHotspotsTimelineWindowDescription'>Hotspots Metrics Plotted over Time</msg>
      <msg name='%PMUEventsBottomUpWindowDescription'>Analyze Event Count per Grouping</msg>
      <msg name='%PMUEventsSummaryWindowDescription'>Analyze Application-level Event Count</msg>
      <msg name='%PMUEventsTimelineWindowDescription'>Hardware Events over Time</msg>
      <msg name='%PMUEventsTopDownTreeWindowDescription'>Explore Event Count for Functions and Their Callees</msg>
      <msg name='%PMUEventsCallerCalleeWindowDescription'>Explore Event Count for Hot Subtrees</msg>
      <msg name='%PMUSamplesBottomUpWindowDescription'>Analyze Event Sample Count per Grouping</msg>
      <msg name='%PMUSamplesTopDownWindowDescription'>Explore Event Sample Count for Functions and Their Callees</msg>
      <msg name='%PMUSamplesCallerCalleeWindowDescription'>Explore Event Sample Count for Hot Subtrees</msg>
      <msg name='%PMUSamplesSummaryWindowDescription'>Analyze Application-level Event Sample Count </msg>
      <msg name='%PMUSamplesTimelineWindowDescription'>Hardware Event Samples over Time</msg>
      <msg name='%ParallelismBottomUpWindowDescription'>Analyze Hotspots and Their Callers</msg>
      <msg name='%ParallelismStackWindowDescription'>Locks and Waits Stack Pane</msg>
      <msg name='%ParallelismSummaryWindowDescription'>Identify Application-level Locks and Waits</msg>
      <msg name='%ParallelismTimelineWindowDescription'>Locks and Waits Issues over Time</msg>
      <msg name='%ParallelismTopDownTreeWindowDescription'>Analyze Hotspots and Their Callees</msg>
      <msg name='%ParallelismCallerCalleeWindowDescription'>Analyze Hot Subtrees</msg>
      <msg name='%ExtendedSleepStatesViewpointName'>Platform Power Analysis</msg>
      <msg name='%ExtendedSleepStatesViewpointShortName'>Platform Power Analysis</msg>
      <msg name='%ExtendedSleepStatesViewpointDescription'>This view displays platform level CPU and graphics sleep states, frequencies, wake up events, temperature, memory bandwidth and other metrics measured during the data collection run. Press F1 for help on each window.</msg>
      <msg name='%GenericPowerViewpointName'>Platform Power Analysis</msg>
      <msg name='%GenericPowerViewpointShortName'>Platform Power Analysis</msg>
      <msg name='%GenericPowerViewpointDescription'>This view displays platform level CPU and graphics sleep states, frequencies, wake up events, temperature, memory bandwidth and other metrics measured during the data collection run. Press F1 for help on each window.</msg>
      <msg name='%SummaryWindow'>Summary</msg>
      <msg name='%UncoreTimelineWindow'>Uncore Events</msg>
      <msg name='%TimelineWindow'>Timeline</msg>
      <msg name='%Metrics'>Metrics</msg>
      <msg name='%MetricsWindowDescription'>Detailed metrics for selected objects</msg>
      <msg name='%GeneralMetrics'>General Metrics</msg>
      <msg name='%RegionMetrics'>Region Metrics</msg>
      <msg name='%BarrierMetrics'>Barrier Metrics</msg>
      <msg name='%HistogramWindow'>Histograms</msg>
      <msg name='%HistogramWindowDescription'>Histograms for applied filter data</msg>
      <msg name='%TopDownTreeWindow'>Top-down Tree</msg>
      <msg name='%CallerCalleeWindow'>Caller/Callee</msg>
      <msg name='%PlatformTimelineWindow'>Platform</msg>
      <msg name='%PlatformTimelineWindowDescription'>Analyze CPU, GPU, and Bandwidth Usage with Platform Metrics</msg>
      <msg name='%PowerPMUEventsSummaryWindowDescription'>Analyze Application-level Event Metrics</msg>
      <msg name='%OpenCLKernels'>OpenCL Kernels</msg>
      <msg name='%CPUUsageOverTime'>CPU Utilization</msg>
      <msg name='%CPUUsageAverage'>Average Effective CPU Utilization</msg>
      <msg name='%CPUUsageAverageDescription'>The metrics shows average CPU utilization by computations of the application. Spin and Overhead time are not counted. Ideal average CPU utilization is equal to the number of logical CPU cores.</msg>
      <msg name='%ThreadConcurrency'>Thread Concurrency</msg>
      <msg name='%FramesOverTime'>Frame Rate</msg>
      <msg name='%Bandwidth'>Bandwidth, GB/sec</msg>
      <msg name='%DRAMBandwidth'>DRAM Bandwidth</msg>
      <msg name='%DRAMBandwidthGB'>DRAM Bandwidth, GB/sec</msg>
      <msg name='%FPGA_PCIE_Bandwidth'>FPGA PCIe Bandwidth, GB/sec</msg>
      <msg name='%PCIE_FPGADataTransferredGB'>Total Bandwidth, GB/sec</msg>
      <msg name='%PCIE_FPGADataReadGB'>FPGA PCIe Read Bandwidth, GB/sec</msg>
      <msg name='%PCIE_FPGADataWrittenGB'>FPGA PCIe Write Bandwidth, GB/sec</msg>
      <msg name='%FPGA_QPI_Bandwidth'>FPGA QPI Bandwidth, GB/sec</msg>
      <msg name='%QPI_FPGADataTransferredGB'>Total Bandwidth, GB/sec</msg>
      <msg name='%QPI_FPGADataReadGB'>FPGA QPI Read Bandwidth, GB/sec</msg>
      <msg name='%QPI_FPGADataWrittenGB'>FPGA QPI Write Bandwidth, GB/sec</msg>
      <msg name='%FPGARatios'>FPGA Cache Read/Write Miss Ratios</msg>
      <msg name='%FPGADataWriteMissRatio'>FPGA Cache Write Miss Ratio</msg>
      <msg name='%FPGADataReadMissRatio'>FPGA Cache Read Miss Ratio</msg>
      <msg name='%FPGAPCIeLink0Bandwidth'>FPGA PCIe Link0 Bandwidth, GB/sec</msg>
      <msg name='%FPGAPCIeLink1Bandwidth'>FPGA PCIe Link1 Bandwidth, GB/sec</msg>
      <msg name='%PackageBandwidth'>Package Bandwidth</msg>
      <msg name="%SystemBandwidth">System Bandwidth</msg>
      <msg name='%GPUUncoreBandwidth'>GPU to Uncore Bandwidth</msg>
      <msg name='%ReadBandwidth'>Read Bandwidth, GB/sec</msg>
      <msg name='%WriteBandwidth'>Write Bandwidth, GB/sec</msg>
      <msg name='%SOCBandwidth'>Core Bandwidth, MB/sec</msg>
      <msg name='%SOCReadBandwidth'>Core Read Bandwidth, MB/sec</msg>
      <msg name='%SOCWriteBandwidth'>Core Write Bandwidth, MB/sec</msg>
      <msg name='%SOCGraphicsBandwidth'>Graphics Bandwidth, MB/sec</msg>
      <msg name='%SOCGraphicsReadBandwidth'>Graphics Read Bandwidth, MB/sec</msg>
      <msg name='%SOCGraphicsWriteBandwidth'>Graphics Write Bandwidth, MB/sec</msg>
      <msg name='%SOCDisplayBandwidth'>Display Bandwidth, MB/sec</msg>
      <msg name='%SOCDisplayReadBandwidth'>Display Read Bandwidth, MB/sec</msg>
      <msg name='%SOCDisplayWriteBandwidth'>Display Write Bandwidth, MB/sec</msg>
      <msg name='%QPITotalBandwidth'>QPI Total Transmit BW, GB/sec</msg>
      <msg name='%QPIDataBandwidth'>QPI Data Transmit BW, GB/sec</msg>
      <msg name='%Module'>Module</msg>
      <msg name='%Threads'>Threads</msg>
      <msg name='%UncoreEvent'>Uncore Event Count</msg>
      <msg name='%AtomGeneralExplorationBottomUpWindowDescription'>Analyze Pipeline Execution</msg>
      <msg name='%AtomGeneralExplorationSummaryWindowDescription'>Analyze Application-level Pipeline Execution</msg>
      <msg name='%AtomGeneralExplorationTimelineWindowDescription'>Pipeline Execution Metrics over Time</msg>
      <msg name='%APBandwidth'>PMEM Bandwidth</msg>
      <msg name='%APDataTransferredGB'>Total Bandwidth, GB/sec</msg>
      <msg name='%APDataReadGB'>PMEM Read Bandwidth, GB/sec</msg>
      <msg name='%APDataWrittenGB'>PMEM Write Bandwidth, GB/sec</msg>
      <msg name='%PowerEvents'>Power events</msg>
      <msg name='%WastedWork'>Wasted Work</msg>
      <msg name='%BackendIssues'>Back-end Issues</msg>
      <msg name='%FrontendIssues'>Front-end Issues</msg>
      <msg name='%UnfilledPipelineSlots'>Unfilled Pipeline Slots (Stalls)</msg>
      <msg name='%FilledPipelineSlots'>Filled Pipeline Slots</msg>
      <msg name='%MemoryLatency'>Memory Latency</msg>
      <msg name='%MemoryReplacements'>Memory Replacements</msg>
      <msg name='%MemoryReissues'>Memory Reissues</msg>
      <msg name='%QuantumWaitTime'>Wait Time</msg>
      <msg name='%QuantumWaitTimeDescription'>The time while threads (or the system on behalf of user-mode threads) were waiting on synchronization objects.</msg>
      <msg name='%QuantumIOWaitTime'>I/O Wait Time</msg>
      <msg name='%QuantumIOWaitTimeDescription'>This metric represents a portion of time when threads reside in I/O wait state while there are idle cores on the system.</msg>
      <msg name='%QuantumInactiveTime'>Inactive Time</msg>
      <msg name='%QuantumWaitAndInactiveTime'>Context Switch Time</msg>
      <msg name='%QuantumInactiveTimeDescription'>The time while threads were preempted by the system and remained inactive.</msg>
      <msg name='%KNCGeneralExplorationViewpointName'>Microarchitecture Exploration</msg>
      <msg name='%KNCGeneralExplorationViewpointShortName'>Microarchitecture Exploration</msg>
      <msg name='%KNCGeneralExplorationViewpointDescription'>This view uses &lt;a href='intel.phe.configs.knc_metrics_f1339'&gt;hardware event-based metrics&lt;/a&gt; to show code regions that experienced potentially significant architectural bottlenecks. Hover over a metric name in the &lt;a href='configs.bottomup_pane_f1130'&gt;grid&lt;/a&gt; for the metric description.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Identify code regions (modules, functions, and so on) with the highest execution time.&lt;br&gt;- Analyze detected hardware issues highlighted by pink cells and get tuning recommendations.&lt;br&gt;&lt;br&gt;Press F1 for help on each window.</msg>
      <msg name='%KNCGeneralExplorationBottomUpWindowDescription'>Analyze Microarchitecture-specific Hotspots per Grouping</msg>
      <msg name='%KNCGeneralExplorationSummaryWindowDescription'>Analyze Application-level Microarchitecture-specific Hotspots</msg>
      <msg name='%KNCGeneralExplorationTimelineWindowDescription'>Analyze Microarchitecture-specific Hotspots Plotted over Time</msg>
      <msg name='%KNCCacheUsageGroup'>Cache Usage</msg>
      <msg name='%KNCCacheUsageGroupDescription'>These metrics indicate the efficiency of cache usage by the workload. For applications running on the Intel Xeon Phi coprocessor, good data locality is critical for achieving their performance potential. To benefit from vectorizing applications, the data must be accessible to be packed into VPU registers at as low a latency as possible. Otherwise, the time to pack the registers dominates the time to do the computation. Although being able to switch execution among four hardware threads does hide some data access latency, it can still have a significant impact on performance. Both L1 and L2 locality are important. Program changes that result in data being accessed from local L2 cache as opposed to a remote cache or memory save at least 250 cycles of access time. Under load, the savings are even greater. Accessing data from L1 as opposed to L2 saves about 20 cycles.</msg>
      <msg name='%KNCEstimatedLatencyImpact'>Estimated Latency Impact</msg>
      <msg name='%KNCEstimatedLatencyImpactDescription'>This metric is an estimate of the average number of cycles taken to service L1 misses.  It is imperfect and likely to be over-estimating the true impact of L1 misses.  However it can be used as a general indicator of whether the majority L1 data misses are hitting in L2.  If the value for this metric is less than 145 cycles, then it is likely the case that more than half of L1 misses are hitting in a hardware thread's local L2 cache.  To decrease this metric, apply optimizations to reduce data latency such as data reorganization, prefetching, cache blocking/tiling, streaming stores, or data alignment.</msg>
      <msg name='%KNCEstimatedLatencyImpactIssueText'>Estimated Latency Impact value is high, which likely indicates that the majority of L1 data cache misses are not being serviced by the L2 cache.  Software prefetching is one strategy for improving this on the Intel Xeon Phi coprocessor.  Data reorganization or traditional techniques to increase data locality (such as cache blocking/tiling, using streaming stores, and data alignment) are other options.</msg>
      <msg name='%KNCL1ComputeToDataAccessRatio'>L1 Compute to Data Access Ratio</msg>
      <msg name='%KNCL1ComputeToDataAccessRatioDescription'>This metric measures the computational density of an application, or how many computations it is performing on average for each piece of data loaded. Use this metric to judge suitability of an application for running on the Intel MIC architecture. Applications that perform well on the Intel MIC architecture should be vectorized, and ideally be able to perform multiple operations on the same pieces of data (or same cachelines). The L1 ratio calculates an average of the number of vectorized operations that occur for each L1 cache access.</msg>
      <msg name='%KNCL1ComputeToDataAccessRatioIssueText'>Most codes that run well on the Intel MIC architecture should be able to achieve a ratio of computation to L1 access that is greater than or equal to their Vectorization Intensity. This is similar to a 1:1 ratio - one data access for one computation - except that by vectorizing each computation should be operating on multiple elements at once. An application that cannot achieve a ratio above this threshold may not be computationally dense enough to fully utilize the Intel MIC architecture.</msg>
      <msg name='%KNCL2ComputeToDataAccessRatio'>L2 Compute to Data Access Ratio</msg>
      <msg name='%KNCL2ComputeToDataAccessRatioDescription'>This metric shows the average number of vectorized operations that occur for each L2 access. Applications that are able to block data for the L1 cache, or reduce data access in general, will have higher numbers for this ratio. While the computational density at the L1 level is critical, the L2 level metric mostly indicates whether code is operating efficiently. Like the L1 metric, it includes all vectorized operations (including data movement) in the numerator.</msg>
      <msg name='%KNCL2ComputeToDataAccessRatioIssueText'>High values for this ratio are typical to applications that are able to block data for the L1 cache or reduce data access in general. As a baseline, the threshold of 100x the L1 ratio has been used, meaning there should be roughly 1 L2 data access for every 100 L1 data accesses. Like the L1 metric, it includes all vectorized operations (including data movement) in the numerator.</msg>
      <msg name='%KNCL1HitRate'>L1 Hit Ratio</msg>
      <msg name='%KNCL1HitRateDescription'>This metric is a hit ratio for L1 cache that should approach 1.  L1 cache accesses can be either a standard hit, a miss, or a hit to an in-flight prefetch, which is counted separately. Hits to an in-flight prefetch occur when the data was not found in the cache, and was a match for a cacheline already being retrieved for the same cache level by a prefetch. These types of hits have a longer latency than a standard hit, but less than a miss.</msg>
      <msg name='%KNCL1HitRateIssueText'>The L1 cache hit ratio should be as close to 1 as possible. A low value for this ratio may mean that the application does not use the cache effectively.</msg>
      <msg name='%KNCL1Misses'>L1 Misses</msg>
      <msg name='%KNCL1MissesDescription'>This metric shows the number of cache misses that occurred in the application.</msg>
      <msg name='%KNCTLBUsageGroup'>TLB Usage</msg>
      <msg name='%KNCTLBUsageGroupDescription'>Translation Lookaside Buffer (TLB) is a cache used for mapping virtual address to physical ones. This metric helps identify a high rate of TLB misses that can affect performance of a program running on the Intel Xeon Phi coprocessor.</msg>
      <msg name='%KNCL1TLBMissRatio'>L1 TLB Miss Ratio</msg>
      <msg name='%KNCL1TLBMissRatioDescription'>This metric is a ratio of data accesses that resulted in an L1 data Translation Lookaside Buffer (TLB) miss to all data accesses.  TLBs are caches that hold virtual-to-physical memory address translations, so that the translation does not have to be performed on each memory access.  This metric should be less than 1, meaning there should be fewer than 1 out of 100 misses to the L1 TLB on average.  To reduce this metric, try optimizations that increase data locality.</msg>
      <msg name='%KNCL1TLBMissRatioIssueText'>High ratio value indicates lack of spatial locality; the program is not using all the data in the page. Since there are 64 cachelines in a 4 KB page, the L1 TLB miss ratio for sequential access to all the cachelines in a page is 1/64. High value may also indicate thrashing; if multiple pages are accessed in the same loop, the TLB associativity or capacity may not be sufficient to hold all the TLB entries.</msg>
      <msg name='%KNCL2TLBMissRatio'>L2 TLB Miss Ratio</msg>
      <msg name='%KNCL2TLBMissRatioDescription'>This metric is a ratio of data accesses that resulted in an L2 data Translation Lookaside Buffer (TLB) miss to all data accesses.  TLBs are caches that hold virtual-to-physical memory address translations, so that the translation does not have to be performed on each memory access.  This metric should be less than .1, meaning there should be fewer than 1 out of 1000 misses to the L2 TLB on average.  To reduce this metric, try optimizations that increase data locality.</msg>
      <msg name='%KNCL2TLBMissRatioIssueText'>The L2 TLB miss penalty is at least 100 clocks. It is also impossible to hide this latency with prefetches, so it is important to try to avoid L2 TLB misses.</msg>
      <msg name='%KNCL1TLBMissesPerL2TLBMiss'>L1 TLB Misses per L2 TLB Miss</msg>
      <msg name='%KNCL1TLBMissesPerL2TLBMissDescription'>This metric is a ratio of misses in the L1 data Translation Lookaside Buffer (TLB) to misses in the L2 data TLB.  TLBs are caches that hold virtual-to-physical memory address translations, so that the translation does not have to be performed on each memory access.  A large number of L1 TLB misses compared to L2 TLB misses indicates that the data footprint of the application may be very dispersed, and using large pages might help performance.</msg>
      <msg name='%KNCL1TLBMissesPerL2TLBMissIssueText'>The L1 to L2 TLB miss ratio is high: there are many more L1 TLB misses than L2 TLB misses. This means that the L2 TLB has the capacity to hold the program's working set, and the program may benefit from large pages.</msg>
      <msg name='%KNCVectorizationGroup'>Vectorization Usage</msg>
      <msg name='%KNCVectorizationGroupDescription'>These metrics help assess the quality of code vectorization level and its execution.</msg>
      <msg name='%KNCVectorizationIntensity'>Vectorization Intensity</msg>
      <msg name='%KNCVectorizationIntensityDescription'>This metric is a ratio between the total number of data elements processed by vector instructions and the total number of vector instructions. If the ratio approaches 8 or 16 then there is a good chance that the loop is well vectorized. Use this metric in conjunction with the compiler's vectorization report to understand the compiler's judgement about the code.</msg>
      <msg name='%KNCVectorizationIntensityIssueText'>Low vectorization intensity (significantly less than 8 for double-precision code and less than 16 for single-precision code) may indicate that the compiler failed to vectorize a particular loop, or that the vectorization was inefficient. Problems are typically one or more of unknown data dependencies, non unit-stride accesses and true access indirection. Consider examining the vectorization report for details.</msg>
      <msg name='%CPUUsageChart'>Effective CPU Utilization Histogram</msg>
      <msg name='%CPUUsageChartWithErrorMessage'>CPU Utilization Histogram</msg>
      <msg name='%CPUUsageChartDescription'>This histogram displays a percentage of the wall time the specific number of CPUs were running simultaneously. Spin and Overhead time adds to the Idle CPU utilization value.</msg>
      <msg name='%RegionCPUUsageChart'>OpenMP Region CPU Utilization Histogram</msg>
      <msg name='%RegionCPUUsageChartDescription'>This histogram displays a percentage of the wall time the specific number of CPUs were running simultaneously in an OpenMP region. Spin and Overhead time adds to the Idle CPU utilization value. OpenMP regions in the drop-down list are sorted by Potential Gain (Elapsed Time) so it is recommended to start exploration from the top.</msg>
      <msg name='%FrameRateChart'>Frame Rate Histogram</msg>
      <msg name='%FrameRateChartDescription'>This histogram shows the total number of frames in your application executed with a specific frame rate. High number of slow or fast frames signals a performance bottleneck. Explore the data provided in the Bottom-up, Top-down Tree, and Timeline panes to identify code regions with the high/slow frame rate. Try to optimize your code to keep the frame rate constant (for example, from 30 to 60 frames per second).</msg>
      <msg name='%RegionDurationChart'>OpenMP Region Duration Histogram</msg>
      <msg name='%RegionDurationChartDescription'>This histogram shows the total number of region instances in your application executed with a specific duration. High number of slow instances may signal a performance bottleneck. Explore the data provided in the Bottom-up, Top-down Tree, and Timeline panes to identify code regions with the slow duration.</msg>
      <msg name='%IODurationChart'>Disk Input and Output Histogram</msg>
      <msg name='%IODurationChartDescription'>This histogram shows the total number of I/O operations executed with a specific duration. A high number of slow instances may signal a performance bottleneck. Explore the data in the Bottom-up and Timeline panes to identify the I/O operations with slow duration.</msg>
      <msg name='%PMUEvents'>Hardware Events</msg>
      <msg name='%PMUEventsDescription'>Hardware Events</msg>
      <msg name='%PMUEventTimeline'>Timeline Hardware Event</msg>
      <msg name='%PMUSamples'>Hardware Event Samples</msg>
      <msg name='%PMUSamplesDescription'>Hardware Event Samples</msg>
      <msg name='%UncoreEventTimeline'>Timeline Hardware Event</msg>
      <msg name='%Package'>Package</msg>
      <msg name='%ResultInfo'>Collection and Platform Info</msg>
      <msg name='%ResultInfoDescription'>This section provides information about this collection, including result set size and collection platform data.</msg>
      <msg name='%ResultSummaryInfo'>Result Summary</msg>
      <msg name='%ResultSummaryInfoDescription'>Result Summary</msg>
      <msg name='%EventCountSummary'>Collected Hardware Events</msg>
      <msg name='%MetricSummary'>Hardware Metrics</msg>
      <msg name='%SimultaneouslyRunningThreads'>Simultaneously Running Threads</msg>
      <msg name='%ThreadConcurrencyChart'>Thread Concurrency Histogram</msg>
      <msg name='%ThreadConcurrencyChartDescription'>This histogram represents a breakdown of the Elapsed Time. It visualizes the percentage of the wall time the specific number of threads were running simultaneously. Threads are considered running if they are either actually running on a CPU or are in the runnable state in the OS scheduler. Essentially, Thread Concurrency is a measurement of the number of threads that were not waiting. Thread Concurrency may be higher than CPU utilization if threads are in the runnable state and not consuming CPU time.</msg>
      <msg name='%TopHotspots'>Top Hotspots</msg>
      <msg name='%TopHotspotsSortedByDiff'>Top Hotspots by Difference</msg>
      <msg name='%HWContextBalanceHistogram'>Logical CPU Balance</msg>
      <msg name='%HWContextBalanceHistogramDescription'>This histogram represents a breakdown of overall CPU time by logical CPUs where it was spent. Explore to understand the overall balance of program execution over available logical CPUs.</msg>
      <msg name='%TopGPUHotspots'>Hottest GPU Computing Tasks</msg>
      <msg name='%TopGPUDeepProfilingHotspots'>Hottest GPU Computing Tasks</msg>
      <msg name='%GPUEnginesUsageTime'>GPU Utilization</msg>
      <msg name='%GPUEnginesUsageTimeDescription'>GPU Utilization breakdown by GPU engines and work types.</msg>
      <msg name='%GPUEnginesUsageTimeNoPacketsDescription'>GPU Utilization breakdown by GPU engines.</msg>
      <msg name='%GPUEUNotActiveWhenBusyHeaderDescription'>Analyze the average value of EU Array Stalled/Idle metric and identify why EUs were waiting for resources instead of doing computations. This metric is critical for compute-bound applications. Explore typical reasons for this kind of inefficiency listed below.</msg>
      <msg name='%GPUThreadOccupancyWhenBusyHeaderDescription'>Identify too large or too small computing tasks with low occupancy that make the EU array idle while waiting for the scheduler. Note that frequent SLM accesses and barriers may affect the maximum possible occupancy.</msg>
      <msg name='%GPUSamplerBusyWhenBusyHeaderDescription'>Identify computing tasks with frequent accesses to the Sampler that make the EU array stalled or idle.</msg>
      <msg name='%GPUL3BandwidthWhenBusyHeaderDescription'>Identify whether performance of your code executing on the GPU is bounded by GPU L3 bandwidth.</msg>
      <msg name='%TopGPUTasksWithOccupancyProblems'>Hottest GPU Computing Tasks with Low Occupancy</msg>
      <msg name='%TopGPUTasksWithOccupancyProblemsDescription'>This section lists the most active computing tasks running on the GPU with a low Occupancy, sorted by the Total Time.</msg>
      <msg name='%GPUFPUBoundHeaderDescription'>Identify computing tasks with high utilization of the floating point execution units.</msg>
      <msg name='%TopGPUTasksWithFPUProblems'>Hottest GPU Computing Tasks with High FPU Utilization</msg>
      <msg name='%TopGPUTasksWithFPUProblemsDescription'>This section lists the most active computing tasks that ran on the GPU heavily using the floating point execution units. Tasks in the table are sorted by the Total Time.</msg>
      <msg name='%TopGPUTasksWithSamplerAccessProblems'>Hottest GPU Computing Tasks with High Sampler Usage</msg>
      <msg name='%TopGPUTasksWithSamplerAccessProblemsDescription'>This section lists the most active computing tasks running on the GPU with high usage of the Sampler, sorted by the Total Time.</msg>
      <msg name='%TopGPUTasksWithGPUL3BandwidthProblems'>Hottest GPU Computing Tasks Bound by GPU L3 Bandwidth</msg>
      <msg name='%TopGPUTasksWithGPUL3BandwidthProblemsDescription'>This section lists the most active computing tasks running on the GPU with high GPU L3 bandwidth, sorted by the Total Time.</msg>
      <msg name='%NoDataToShowForGPUTasksWithIssues'>No data to show. There are no Computing Tasks affected by this issue.</msg>
      <msg name='%MemoryInfo'>Memory Info</msg>
      <msg name='%NoMetricValue'>N/A*</msg>
      <msg name='%NoMetricValueFilterDescription'>*N/A is applied to metrics with undefined value. Suggestion: Make sure the proper filtering is applied. See the Troubleshooting help topic for more details.</msg>
      <msg name='%Others'>[Others]</msg>
      <msg name='%NotSummable'>N/A*</msg>
      <msg name='%NotSummableDescription'>*N/A is applied to non-summable metrics.</msg>
      <msg name='%MemoryConsumptionHistogram'>Allocation Distribution By Size</msg>
      <msg name='%MemoryConsumptionHistogramDescription'>This histogram displays the number of allocations per specific sizes to help you identify the most popular memory object sizes.</msg>
      <msg name='%MemoryConsumptionTopFiveObjects'>Top Memory-Consuming Functions</msg>
      <msg name='%MemoryConsumptionTopFiveObjectsDescription'>This section lists the most memory-consuming functions in your application.</msg>
      <msg name='%GPUAnalysisWorkflow'>Analysis Workflow</msg>
      <msg name='%GPUAnalysisWorkflowDescription'>Start your GPU analysis with exploring the GPU Utilization section to identify whether the GPU was properly utilized. Then, focus on the EU Array Stalled/Idle section for compute-bound applications and on the Memory Info section for memory-bound applications. Press F1 for more help.</msg>
      <msg name='%GPUUtilization'>&#32;&#32;&#32;GPU Utilization</msg>
      <msg name='%GPUUtilizationDescription'>Use this section to understand whether the GPU was utilized properly and which of the engines were utilized. Identify the amount of gaps in the GPU utilization that potentially could be loaded with some work. This metric is calculated for the engines that had at least one piece of work scheduled to them.</msg>
      <msg name='%TotalElapsedTimeMultirunNote'>If your application target was run more than once during the collection, this value includes elapsed time for all the runs.</msg>
      <msg name='%NotChanged'>Not changed, </msg>
      <msg name="%CopyToClipboard">Copy to Clipboard</msg>
      <msg name='%NoMetricValueDescription'>*N/A is applied to metrics with undefined value. There is no data to calculate the metric.</msg>
      <msg name="%Apply">Apply</msg>
      <msg name="%ApplyButtonTooltip">Apply Slider Changes</msg>
      <msg name="%ApplyButtonWarning">Threshold change may take time. Result will be re-opened.</msg>
      <msg name="%ApplyButtonWaiting">Saving the new thresholds. Please wait.</msg>
      <msg name="%AverageBandwidth">Average</msg>
      <msg name="%AverageDramBandwidth">Average DRAM Bandwidth</msg>
      <msg name="%Average">Average</msg>
      <msg name="%ColorbandTooltip">Use sliders to change thresholds.</msg>
      <msg name="%DomainLabel">Domain:</msg>
      <msg name="%NoDataToShowWithFilter">No data to show. Suggestion: Make sure the proper filtering is applied. See the Troubleshooting help topic for more details.</msg>
      <msg name="%NoDataToShowOnActiveTime">No data to show. The collected data is not sufficient.</msg>
      <msg name="%DetailsLink">[Details]</msg>
      <msg name='%TopHotspotsDescription'>This section lists the most active functions in your application. Optimizing these hotspot functions typically results in improving overall application performance.</msg>
      <msg name='%TopHotspotsSortedByDiffDescription'>This section displays the performance difference between two selected results for the most active functions in your application.</msg>
      <msg name='%TopWaitObjects'>Top Waiting Objects</msg>
      <msg name='%TopWaitObjectsDescription'>This section lists the objects that spent the most time waiting in your application. Objects can wait on specific calls, such as sleep() or I/O, or on contended synchronizations. A significant amount of Wait time associated with a synchronization object reflects high contention for that object and, thus, reduced parallelism.</msg>
      <msg name='%TopFunctionsByInactiveWaitTime'>Top functions by Inactive Wait Time with Poor CPU Utilization.</msg>
      <msg name='%TopFunctionsByInactiveWaitTimeDescription'>This section lists the functions sorted by the time spent waiting on synchronization or thread preemption with poor CPU Utilization.</msg>
      <msg name='%TopGPUHotspotsDescription'>This section lists the most active computing tasks running on the GPU, sorted by the Total Time. Focus on the computing tasks flagged as performance-critical.</msg>
      <msg name='%TopGPUDeepProfilingHotspotsDescription'>This section lists the most active computing tasks running on the GPU, sorted by the Total Time.</msg>
      <msg name='%TopSerialHotspotsDescription'>This section lists the loops and functions executed serially in the master thread outside of any OpenMP region and consuming the most CPU time. Improve overall application performance by optimizing or parallelizing these hotspot functions. Since the Serial Time metric includes the Wait time of the master thread, it may significantly exceed the aggregated CPU time in the table.</msg>
      <msg name='%CPU'>CPU</msg>
      <msg name='%GPU'>GPU</msg>
      <msg name='%GPUInfo'>Graphics Processing Unit Info</msg>
      <msg name='%GPUInfoDescription'>This section provides detailed GPU characteristics.</msg>
      <msg name='%GPUOpenCLInfo'>GPU OpenCL Info</msg>
      <msg name='%GPUOpenCLInfoDescription'>This section provides detailed GPU OpenCL characteristics.</msg>
      <msg name='%AbortCyclesChart'>Abort Cycles Histogram</msg>
      <msg name='%AbortCyclesChartDescription'>This histogram shows the number of aborts happened for transactions with a specific cycles duration.</msg>
      <msg name='%TopRegions'>Top OpenMP Regions by Potential Gain</msg>
      <msg name='%TopOpenMPProcesses'>Top OpenMP Processes by MPI Busy Wait Time</msg>
      <msg name='%TopOpenMPProcessesDescription'>This section lists processes sorted by MPI Busy Wait time. The lower MPI Busy Wait time, the more a process was on a critical path of MPI application execution. Explore OpenMP efficiency metrics by MPI processes laying on the critical path</msg>
      <msg name='%TopRegionsDescription'>This section lists OpenMP regions with the highest potential for performance improvement. The Potential Gain metric shows the elapsed time that could be saved if the region was optimized to have no load imbalance assuming no runtime overhead.</msg>
      <msg name='%MPIAnalisysMainMetrics'>MPI Analysis</msg>
      <msg name='%MPIAnalisysMainMetricsDescription'>MPI Analysis main metrics</msg>
      <msg name='%PMUCallStackLayerName'>Data Of Interest (CPU Metrics)</msg>
      <msg name='%CPUCallStackLayerName'>Data Of Interest (CPU Metrics)</msg>
      <msg name='%WaitCallStackLayerName'>Wait Time</msg>
      <msg name='%ContextSwitchCallStackLayerName'>Context Switch Time</msg>
      <msg name='%WaitSyncObjCreationCallStackLayerName'>Wait Time (Sync Object Creation)</msg>
      <msg name='%SignalCallStackLayerName'>Wait Time (Signal)</msg>
      <msg name='%PMUMemoryObjectAllocCallStackLayerName'>Memory Allocation Call Stack</msg>
      <msg name='%UserTaskCallStackLayerName'>Task Stack</msg>
      <msg name='%CStateTimerCallStackLayerName'>Timer Wake-up Call Stack</msg>
      <msg name='%PMUCallStackTypeName'>Function</msg>
      <msg name='%CPUCallStackTypeName'>Function</msg>
      <msg name='%WaitCallStackTypeName'>Wait</msg>
      <msg name='%ContextSwitchCallStackTypeName'>Context Switch</msg>
      <msg name='%WaitSyncObjCreationCallStackTypeName'>Sync Object Creation</msg>
      <msg name='%SignalCallStackTypeName'>Signal</msg>
      <msg name='%PMUMemoryObjectAllocCallStackTypeName'>Memory Allocation</msg>
      <msg name='%UserTaskCallStackTypeName'>Task</msg>
      <msg name='%CStateTimerCallStackTypeName'>Timer Wake-up</msg>
      <msg name='%MemoryAllocCallStackTypeName'>Function</msg>
      <msg name='%WaitCallStackDescription'>Stacks waiting for sync object</msg>
      <msg name='%ContextSwitchCallStackDescription'>Stacks causing context switch</msg>
      <msg name='%WaitSyncObjCreationCallStackDescription'>Stacks creating sync object</msg>
      <msg name='%SignalCallStackDescription'>Stacks signaling to release sync object</msg>
      <msg name='%PMUMemoryObjectAllocCallStackDescription'>Stacks allocating memory object</msg>
      <msg name='%UserTaskCallStackDescription'>Stacks finishing user task</msg>
      <msg name='%CStateTimerCallStackDescription'>Stacks waking the timer up</msg>
      <msg name='%MemoryAllocCallStackDescription'>Stacks allocating memory</msg>
      <msg name='%WaitTimeCallStack'>Wait Time</msg>
      <msg name='%WaitCountCallStack'>Wait Count</msg>
      <msg name='%SpinTimeCallStack'>Spin Time</msg>
      <msg name='%ContextSwitchTimeCallStack'>Context Switch Time</msg>
      <msg name='%ContextSwitchCountCallStack'>Context Switch Count</msg>
      <msg name='%QuantumWaitTimeCallStack'>Wait Time</msg>
      <msg name='%QuantumInactiveTimeCallStack'>Inactive Time</msg>
      <msg name='%ErrorNoData'>No data to show</msg>
      <msg name='%ErrorNoDataHotspots'>Your application has not consumed enough CPU time to be measured by the statistical method used in this product. Try to increase the time your workload runs, or use the Locks and Waits analysis to gather performance data on your application.</msg>
      <msg name='%ErrorNoDataConcurrency'>Your application has not consumed enough CPU time to be measured by the statistical method used in this product. Try to increase the time your workload runs, or use the Locks and Waits analysis to gather performance data on your application.</msg>
      <msg name='%ErrorNoDataLocksAndWaits'>No Locks and Waits data has been collected for your application because it did not wait on any synchronization or I/O objects. Use the Hotspot or Concurrency analyses to gather other performance data on your application.</msg>
      <msg name='%ErrorNoDataEBS'>Your application has not consumed enough CPU time to be measured by the statistical method used in this product. Try to increase the time your workload runs, or use other analysis types to gather performance data on your application.</msg>
      <msg name='%ErrorNoDataGPUDiagram'>Please use the Grouping drop-down menu to select a "Computing Task Purpose" granularity to see the diagram.</msg>
      <msg name='%UnexpectedErrorOnLoadingData'>Unexpected error occurred while loading data.</msg>
      <msg name='%FrameCount'>Frame Count</msg>
      <msg name='%FrameDomain'>Frame Domain</msg>
      <msg name='%FrameRate'>Frame Rate</msg>
      <msg name='%FrameType'>Frame Duration Type</msg>
      <msg name='%Frames'>Frames</msg>
      <msg name='%RefTime'>CPU Time</msg>
      <msg name='%FilledPipelineSlotsDescription'>Each cycle, a hardware thread (or core, if Intel Hyper-Threading Technology is disabled) can issue work to up to four pipeline slots. Fewer than four pipeline slots might be filled due to problems the front-end is experiencing generating uOps, or due to stalls in the back-end. The sub-metrics under this metric measure the proportion of pipeline slots that were filled but may have been cancelled after issue. </msg>
      <msg name='%UnfilledPipelineSlotsDescription'>Each cycle, a hardware thread (or core, if Intel Hyper-Threading Technology is disabled) can issue work to up to four pipeline slots. Fewer than four pipeline slots might be filled due to problems the front-end is experiencing generating uOps, or due to stalls in the back-end. The sub-metrics under this metric measure the proportion of pipeline slots that could not be filled due to stalls in the front-end or back-end.</msg>
      <msg name='%MemoryLatencyDescription'>Most memory performance issues stem not from problems in the core pipeline but from latency in the memory hierarchy. The sub-metrics under this metric measure such performance issues. </msg>
      <msg name='%MemoryReplacementsDescription'>Certain circumstances can cause memory operations to perform pathologically in the core pipeline. The sub-metrics under this metric measure such pathological conditions. </msg>
      <msg name='%MemoryReissuesDescription'>Often, useful data is ejected from the cache by other, less-useful data. If, when exploring long-latency memory loads, you discover some critical data experiencing an unexpected degree of latency, consider using the memory replacement metrics under this metric to discover where memory accesses are causing evictions at different levels of the memory hierarchy.</msg>
      <msg name='%LLCMissCountDescription'>This metric counts load misses originating from the last-level cache (LLC).  Use this data to identify where demand loads in your application are missing in the LLC.  This metric uses precise events.</msg>
      <msg name='%LLCtoDRAMCountDescription'>This metric counts memory misses serviced by DRAM originating from last-level cache (LLC) misses.  Use this data to identify where memory requests of any kind (including prefetches) are serviced by DRAM.</msg>
      <msg name='%LLCMissCountName'>Load Misses from LLC</msg>
      <msg name='%LLCtoDRAMCountName'>DRAM accesses from LLC</msg>
      <msg name='%PMUCallTreeViewpointName'>PMU Call Tree</msg>
      <msg name='%PMUCallTreeViewpointShortName'>PMU Call Tree</msg>
      <msg name='%PMUCallTreeViewpointDescription'>This view displays a statistically reconstructed tree of function calls in a program. Each node on the call tree (a function) is associated with a corresponding number of PMU events.&lt;br&gt;&lt;br&gt;Press F1 for help on each window.</msg>
      <msg name='%CPUSleepStatesBottomUpWindowDescription'>Analyze Sleep States Breakdown</msg>
      <msg name='%CPUWakeUPsBottomUpWindowDescription'>Explore Wake-up Details</msg>
      <msg name='%SStateBottomUpWindowDescription'>Explore System Sleep State Details</msg>
      <msg name='%DStateBottomUpWindowDescription'>Explore Device Sleep State Details</msg>
      <msg name='%WakelockBottomUpWindowDescription'>Explore Wakelock Details</msg>
      <msg name='%CPUSleepStatesSummaryWindowDescription'>Explore System-level Sleep States Statistics</msg>
      <msg name='%CPUSleepStatesTimelineWindowDescription'>Analyze Sleep States Metrics Over Time</msg>
      <msg name='%SStatesTimelineWindowDescription'>Analyze System Sleep States Metrics Over Time</msg>
      <msg name='%DStatesTimelineWindowDescription'>Analyze Device Sleep States Metrics Over Time</msg>
      <msg name='%WakelocksTimelineWindowDescription'>Analyze Wakelocks Metrics Over Time</msg>
      <msg name='%TimerResolutionTimelineWindowDescription'>Analyze Timer Resolution Metrics Over Time</msg>
      <msg name='%TimerResolutionBottomUpWindowDescription'>Analyze Timer Resolution Metrics Over Time</msg>
      <msg name='%CorrelateTimelineWindowDescription'>Analyze C, P, and Wakelocks Metrics Over Time</msg>
      <msg name='%PowerPMUCorrelateTimelineWindowDescription'>Analyze C, P, and Hardware Events Metrics Over Time</msg>
      <msg name='%CPUFrequencySummaryWindowDescription'>Explore Summary Frequency Statistics</msg>
      <msg name='%CPUFrequencyTimelineWindowDescription'>Analyze Frequency Metrics over Time</msg>
      <msg name='%CPUFrequencyBottomUpWindowDescription'>Identify Frequency per CPU</msg>
      <msg name='%PMUProcessTimelineWindowDescription'>Analyze Hardware Event Counts per Process</msg>
      <msg name='%TopSleepStateWakeUps'>Top 5 Causes of Core Wake-ups</msg>
      <msg name='%TopFrequencyWakeUps'>Top 5 Frequencies</msg>
      <msg name='%FrequencyHistogram'>Core Frequency Histogram</msg>
      <msg name='%ModuleFrequencyHistogram'>Module Frequency Histogram</msg>
      <msg name='%FrequencyHistogramDescription'>This histogram represents a breakdown of the Elapsed Time per Frequency over all cores.</msg>
      <msg name='%ModuleFrequencyHistogramDescription'>This histogram represents a breakdown of the Elapsed Time per Frequency over all modules.</msg>
      <msg name='%SleepStateHistogram'>Elapsed Time per Core Sleep State Histogram</msg>
      <msg name='%SleepStateHistogramDescription'>This histogram represents a breakdown of the Elapsed Time per Core Sleep State over all cores.</msg>
      <msg name='%CPUFrequencyWindow'>CPU Frequencies</msg>
      <msg name='%CPUSleepStatesWindow'>CPU Sleep States</msg>
      <msg name='%CPStatesWindow'>CPU C/P States</msg>
      <msg name='%WakeUpsWindow'>Core Wake-ups</msg>
      <msg name='%PStates'>Frequency</msg>
      <msg name='%PState'>P-State</msg>
      <msg name='%Modem'>Modem</msg>
      <msg name='%MainAppOS'>Main Application OS</msg>
      <msg name='%MinPolicy'>Minimum Policy</msg>
      <msg name='%MaxPolicy'>Maximum Policy</msg>
      <msg name='%CState'>Core Sleep State</msg>
      <msg name="%ThreadID">TID</msg>
      <msg name='%TimeInSeconds'>Time (sec)</msg>
      <msg name='%CStateIRQName'>IRQ Name</msg>
      <msg name='%CStateIRQWakeUps'>Wake-up Count due to IRQ Interrupts</msg>
      <msg name='%CStateIRQWakeUpsDescription'>Total number of core wakeups caused by Interrupt Requests.</msg>
      <msg name='%CStateTimerWakeUps'>Wake-up Count due to Timers</msg>
      <msg name='%CStateTimerWakeUpsDescription'>Total number of core wakeups caused by Timers.</msg>
      <msg name='%CStateTimerStack'>Timer Wake-up Call Stack</msg>
      <msg name='%CStateStackWindowDescription'>C-State Timer Wake-ups Stack Pane</msg>
      <msg name='%GFXSleepStateHistogram'>Elapsed Time per Graphics Device Sleep State Histogram</msg>
      <msg name='%GFXSleepStateHistogramDescription'>This histogram represents a breakdown of the Elapsed Time per Graphics Sleep State over graphics devices.</msg>
      <msg name='%GfxCState'>Graphics Device Sleep State</msg>
      <msg name='%TaskViewpointName'>Task Time</msg>
      <msg name='%TaskViewpointShortName'>Task Time</msg>
      <msg name='%TasksViewpointDescription'>This view visualizes tasks, logical units of work on specific threads, based on ITT API annotations.&lt;br&gt;&lt;br&gt;Use this viewpoint to:&lt;br&gt;- Identify tasks with the highest execution time.&lt;br&gt;- Analyze threads responsible for a particular task.&lt;br&gt;&lt;br&gt;Press F1 for help on each window.</msg>
      <msg name='%TaskTimeline'>Tasks over Time</msg>
      <msg name='%TaskTimelineDescription'>Identify Elapsed Time for Each Task</msg>
      <msg name='%ThreadTaskTimeline'>Tasks by Threads</msg>
      <msg name='%ThreadTaskTimelineDescription'>Analyze Task Elapsed Time by Threads</msg>
      <msg name='%TaskTimelineWithData'>Tasks and Frames</msg>
      <msg name='%TaskTimelineWithDataDescription'>Analyze Performance Metrics Correlated with Tasks and Frames</msg>
      <msg name='%TaskTimeBottomUp'>Task Elapsed Time</msg>
      <msg name='%TaskTimeBottomUpWindowDescription'>Identify Elapsed Time for Each Task</msg>
      <msg name='%TaskSummaryWindowDescription'>Explore Task Summary Statistics</msg>
      <msg name='%TopTasks'>Top Tasks</msg>
      <msg name='%TopModuleTasks'>Top Modules</msg>
      <msg name='%TopTasksSortedByDiff'>Top Tasks by Difference</msg>
      <msg name='%TopTasksDescription'>This section lists the most active tasks in your application.</msg>
      <msg name='%TopModuleTasksDescription'>This section lists the most active modules on your system.</msg>
      <msg name='%TopTasksSortedByDiffDescription'>This section displays the performance difference between two selected results for the most active tasks in your application.</msg>
      <msg name='%FPGAInteractionViewpointName'>CPU/FPGA Interaction</msg>
      <msg name='%FPGAInteractionViewpointShortName'>CPU/FPGA Interaction</msg>
      <msg name='%FPGAInteractionViewpointDescription'>This view helps identify CPU and FPGA issues by exploring FPGA OpenCL kernel execution on top of CPU utilization.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- Identify the most time-consuming FPGA kernels.&lt;br&gt;- Analyze FPGA tasks execution over time.&lt;br&gt;- &lt;br&gt;&lt;br&gt;Press &lt;b&gt;F1&lt;/b&gt; for help on each window.</msg>
      <msg name='%FPGATopTasks'>FPGA Top Compute Tasks</msg>
      <msg name='%FPGATopTasksDescription'>This section lists the most active FPGA compute tasks in your application.</msg>
      <msg name='%GPUTimelineWindow'>Metrics Over Time</msg>
      <msg name='%HotspotsAndGPUTimelineWindowDescription'>Analyze hotspots and GPU metrics over time</msg>
      <msg name='%GPUUsageOverTime'>GPU Utilization</msg>
      <msg name='%GPUSoftQueue'>GPU Software Queue</msg>
      <msg name='%GPUEUActivity'>GPU Execution Units</msg>
      <msg name='%GPUCSActivity'>GPU Computing Threads Dispatch</msg>
      <msg name='%GPUEUInstructions'>GPU EU Instructions</msg>
      <msg name='%GPUEUInstructionsShort'>EU Instructions</msg>
      <msg name='%GPUMemoryAccessCoalescence'>GPU EU Memory Access Coalescence</msg>
      <msg name='%GPUShaderBarriersAndAtomics'>GPU Barriers and Atomics</msg>
      <msg name='%GPUUntypedMemoryAccess'>GPU Untyped Memory Access</msg>
      <msg name='%GPUSharedLocalMemoryAccess'>GPU Shared Local Memory Access</msg>
      <msg name='%GPUTypedMemoryAccess'>GPU Typed Memory Access</msg>
      <msg name='%GPUMemoryAccess'>GPU Memory Access</msg>
      <msg name='%GPUL3CacheMiss'>GPU L3 Cache Misses</msg>
      <msg name='%GPUL3CacheMissAndMemAccess'>GPU Cache Misses and Memory Access</msg>
      <msg name='%GPUMemAccess'>GPU Memory Access</msg>
      <msg name='%GPUTextureAccesses'>GPU Texture Memory Access</msg>
      <msg name='%GPUSamplerActivity'>GPU Texture Sampler</msg>
      <msg name='%ComputingQueue'>Computing Queue</msg>
      <msg name='%DevicesConcurrencyAndUsage'>CPU/GPU Concurrency and Usage</msg>
      <msg name='%GPUL3ThroughputAndMisses'>GPU L3 Cache Bandwidth and Misses</msg>
      <msg name='%GPUEUArrayMetrics'>EU Array Metrics</msg>
      <msg name='%GPU3DPipe'>3D Pipe</msg>
      <msg name='%GPUPixelShader'>EU Array/Pixel Shader</msg>
      <msg name='%GPUVertexShader'>EU Array/Vertex Shader</msg>
      <msg name='%gpuDiagramPane'>Memory Hierarchy Diagram</msg>
      <msg name='%gpuDiagramPaneDescription'>Analyze GPU metric values over hardware architecture blocks.</msg>
      <msg name='%GPUUsageOverTime'>GPU Utilization</msg>
      <msg name='%SState'>S-State</msg>
      <msg name='%S3Time'>S3 Duration</msg>
      <msg name='%DState'>D-State</msg>
      <msg name='%SStateWindow'>System Sleep States</msg>
      <msg name='%NCDStateWindow'>NC Device States</msg>
      <msg name='%SCDStateWindow'>SC Device States</msg>
      <msg name='%WakelockWindow'>Wakelocks</msg>
      <msg name='%TopSCDevices'>Top 5 Active SC Devices</msg>
      <msg name='%TopKWLProcesses'>Top 5 Kernel Wakelocks</msg>
      <msg name='%SStateHistogram'>Elapsed Time per System Sleep State Histogram</msg>
      <msg name='%SStateHistogramDescription'>This histogram represents a breakdown of the Elapsed Time per System Sleep State.</msg>
      <msg name='%SystemSleepSummaryInfo'>System Sleep Summary</msg>
      <msg name='%KernelWakelockSummaryInfo'>Kernel Wakelock Summary</msg>
      <msg name='%UserWakelockSummaryInfo'>User Wakelock Summary</msg>
      <msg name='%CorrelateTimelineWindow'>Correlate Metrics</msg>
      <msg name='%ThreadLifetime'>Thread Lifetime</msg>
      <msg name='%PackageCStates'>Package C-States</msg>
      <msg name='%GfxPStates'>Graphics P-States</msg>
      <msg name='%SamplingPoints'>Sampling Points</msg>
      <msg name='%BwStateWindow'>Bandwidth</msg>
      <msg name='%BandwidthByComponent'>Bandwidth by Component</msg>
      <msg name='%BandwidthByType'>Bandwidth by Event Type</msg>
      <msg name='%BwStateBottomUpWindowDescription'>Explore Bandwidth Data per SoC Device</msg>
      <msg name='%GfxWindow'>Graphics C/P States</msg>
      <msg name='%GfxBottomUpWindowDescription'>Analyze Graphics P-States</msg>
      <msg name='%ThermalWindow'>Temperature</msg>
      <msg name='%ThermalBottomUpWindowDescription'>Explore Temperature Data per SoC Device</msg>
      <msg name='%BandwidthBytes'>Bandwidth (Bytes)</msg>
      <msg name='%BandwidthMBytes'>Bandwidth (Mbytes)</msg>
      <msg name='%BandwidthBytesPerSecond'>Bandwidth (Bytes/sec)</msg>
      <msg name='%BandwidthMBytesPerSecond'>Total Bandwidth (MB/sec)</msg>
      <msg name='%OverallBandwidthBytesPerSecond'>Overall Bandwidth (Bytes/sec)</msg>
      <msg name='%WakeUpObject'>Wake-up Object</msg>
      <msg name='%PMUProcessTimelineWindow'>Process Events</msg>
      <msg name='%PMUEventsSummary'>Hardware Events Summary</msg>
      <msg name='%CoreEvents'>Core Events</msg>
      <msg name='%DramSRR'>DRAM SRR</msg>
      <msg name='%DramSRRBottomUpWindowDescription'>Explore DRAM SRR Data per SoC Device</msg>
      <msg name='%DramSRRTimelineWindowDescription'>Analyze DRAM metrics over time</msg>
      <msg name='%TSXExplorationViewpointName'>TSX Exploration</msg>
      <msg name='%TSXExplorationViewpointShortName'>TSX Exploration</msg>
      <msg name='%TSXExplorationViewpointDescription'>This view shows metrics related to Intel(R) Transactional Synchronization Extensions (Intel TSX). It helps identify how efficiently Intel TSX is used.</msg>
      <msg name='%GlobalInstantValuesType'>Counter Type</msg>
      <msg name='%GlobalInstantValue'>Counter Value</msg>
      <msg name='%ThreadInstantValuesType'>Counter Type</msg>
      <msg name='%ThreadInstantValue'>Counter Value</msg>
      <msg name='%GlobalInstantValues'>Counter Values</msg>
      <msg name='%DeviceInstantValuesType'>Counter Type</msg>
      <msg name='%GlobalCountersArea'>Global Counters</msg>
      <msg name='%AllThreadsArea'>All Threads</msg>
      <msg name='%DeviceDataArea'>Device Data</msg>
      <msg name='%DeviceCountersPane'>Device Counters</msg>
      <msg name='%OsHwCoreCstateTimeGridPaneName'>OS/HW Core C-States</msg>
      <msg name='%OsHwCoreCstateTimeGridPaneDescription'>Dual-Timeline view with OS/HW C-State Residency Summaries</msg>
      <msg name='%OsHwCoreCstateWakeUpGridPaneName'>OS/HW Core Wake-Ups</msg>
      <msg name='%OsHwCoreCstateWakeUpGridPaneDescription'>Dual-Timeline view with OS Wake-Up Summaries</msg>
      <msg name='%OsHwCoreCstateTimelinePaneName'>OS/HW Core C-States</msg>
      <msg name='%OsHwCoreCstateTimelinePaneDescription'>Dual-Timeline view with OS/HW C-State Residency Summaries</msg>
      <msg name='%TimerResolutionWindow'>Timer Resolution</msg>
      <msg name='%PwrStateWindow'>Power</msg>
      <msg name='%PwrStateBottomUpWindowDescription'>Explore Power Data</msg>
      <msg name='%PowerMilliWatt'>Power (mW)</msg>
      <msg name='%ISTPViewpointName'>Modem Trace</msg>
      <msg name='%ISTPViewpointShortName'>Modem Trace</msg>
      <msg name='%IstpLogFileName'>Log File Name</msg>
      <msg name='%IstpSWVersion'>Software Version</msg>
      <msg name='%ISTPViewpointDescription'>This view uses ExactProfiling technology to display performance statistics for Intel Modem platforms.&lt;br&gt;&lt;br&gt;&lt;b&gt;Use this view to:&lt;/b&gt;&lt;br&gt;- This view uses ExactProfiling technology to display performance statistics for Intel Modem platforms.&lt;br&gt;- Identify code regions (modules, functions, and so on) with the highest activity for as event of interest.&lt;br&gt;- &lt;a href='configs.view_source_f1119'&gt;Analyze the source&lt;/a&gt; by double-clicking a hotspot and identify its most critical code lines.&lt;br&gt;&lt;br&gt;</msg>
      <msg name='%BandwidthMB'>Bandwidth (MB/s)</msg>
      <msg name='%DdrBwStateWindow'>DDR Bandwidth</msg>
      <msg name='%ModuleBwStateWindow'>Module Bandwidth</msg>
      <msg name='%DisplayBwStateWindow'>Display Bandwidth</msg>
      <msg name='%GraphicsBwStateWindow'>Graphics Bandwidth</msg>
      <msg name='%ImagingBwStateWindow'>Imaging Bandwidth</msg>
      <msg name='%LowspeedPFBwStateWindow'>Low Speed PF Bandwidth</msg>
      <msg name='%TaskStates'>Task States and Interrupts</msg>
      <msg name='%PhysCoresArea'>Physical Cores</msg>
      <msg name='%VirtCoresArea'>Virtual Cores</msg>
      <msg name='%VirtCoresAreaDescription'>This table shows various statistics by virtual cores</msg>
      <msg name='%TaskDurationChart'>Task Duration Histogram</msg>
      <msg name='%TaskDurationChartDescription'>This histogram shows the total number of task instances executed with a specific duration. High number of slow instances may signal a performance bottleneck.</msg>
      <msg name='%InterruptDurationChart'>Interrupt Duration Histogram</msg>
      <msg name='%InterruptDurationChartDescription'>This histogram shows the total number of interrupt handler instances executed with a specific duration. High number of slow instances may signal a performance bottleneck.</msg>
      <msg name='%TopInterrupts'>Top Interrupt Handlers</msg>
      <msg name='%TopInterruptsDescription'>This section lists the most active interrupt handlers on your system.</msg>
      <msg name='%FunctionDurationChart'>Function Duration Histogram</msg>
      <msg name='%FunctionDurationChartDescription'>This histogram shows the total number of function instances executed with a specific duration. High number of slow instances may signal a performance bottleneck.</msg>
      <msg name='%TopFunctions'>Top Functions</msg>
      <msg name='%TopFunctionsDescription'>This section lists the most active tasks in your application.</msg>
      <msg name='%TopCStateWakeUpObjects'>Top C-State Wakeup Reasons</msg>
      <msg name='%CStateHistogram'>Elapsed Time per Virtual Core C-State</msg>
      <msg name='%CStateHistogramDescription'>This histogram represents a breakdown of the Elapsed Time per Virtual Core Sleep State</msg>
      <msg name='%TopSStateWakeUpObjects'>Top S-State Wakeup Reasons</msg>
      <msg name='%CTDurationChart'>Critical Timing Duration Histogram</msg>
      <msg name='%CTDurationChartDescription'>This histogram shows the total number of critical timing instances executed with a specific duration. Negative duration signals that crtitical timing out event was received before corresponding in event. Use sliders to specify the duration of interest.</msg>
      <msg name='%CriticalTimingDomain'>Domain</msg>
      <msg name='%CriticalTimingCount'>Critical Timing Count</msg>
      <msg name='%CriticalTimingDuration'>Duration, sec</msg>
      <msg name='%SoCBandwidth'>SoC Bandwidth</msg>
      <msg name='%SoCBandwidthDescription'>SoC Bandwidth</msg>
      <msg name='%SoCBandwidthShortName'>SoC Bandwidth</msg>
      <msg name='%QPIBandwidth'>QPI Bandwidth, GB/sec</msg>
      <msg name='%LatencyChart'>Latency Histogram</msg>
      <msg name='%LatencyChartDescription'>This histogram shows a distribution of loads per latency (in cycles).</msg>
      <msg name='%DMAPacketPreempted'>Preempted Packet</msg>
      <msg name='%DMAPacketPresent'>Present Packet</msg>
      <msg name='%DMAPacketReconstructed'>Reconstructed Packet</msg>
      <msg name='%DMAPacketPreemptedDescription'>Mark-up for packets preempted by other high-priority GPU work.</msg>
      <msg name='%DMAPacketPresentDescription'>Mark-up for packets presenting the content on the screen.</msg>
      <msg name='%DMAPacketReconstructedDescription'>Mark-up for packets re-constructed using heuristics.</msg>
      <msg name='%DMAPacketDurationHistogramHeader'>Packet Duration Histogram</msg>
      <msg name='%DMAPacketDurationHistogramDescription'>This histogram shows DMA packet duration for the GPU workload.</msg>
      <msg name='%DMAQueueDepthHistogramHeader'>Packet Queue Depth Histogram</msg>
      <msg name='%DMAQueueDepthHistogramEscription'>This histogram shows the overall time spent at a given queue depth.</msg>
      <msg name='%TopMemoryObjects'>Top Memory Objects by LLC Misses</msg>
      <msg name='%TopMemoryObjectsDescription'>This section lists the most actively used memory objects that introduced the highest LLC Miss count during the application execution.</msg>
      <msg name='%TopMemoryObjectsByTotalLatency'>Top Memory Objects by Latency</msg>
      <msg name='%TopMemoryObjectsByTotalLatencyDescription'>This section lists memory objects that introduced the highest latency to the overall application execution.</msg>
      <msg name='%UPIBandwidth'>UPI Bandwidth, GB/sec</msg>
      <msg name='%BandwidthBottomUpPane'>Bandwidth</msg>
      <msg name='%TopFPU'>Top Loops/Functions with FPU Usage by CPU Time</msg>
      <msg name='%TopFPUDescription'>This section provides information for the most time consuming loops/functions with floating point operations.</msg>
      <msg name='%NoDataToShowForTopFPU'>No data to show. No loops/functions with floating point operations detected.</msg>
      <msg name='%IceViewpointName'>NNP-I Overview</msg>
      <msg name='%IceViewpointDescription'>NNP-I Overview</msg>
      <msg name='%IceViewpointShortName'>NNP-I Overview</msg>
      <msg name="%IceHWEventsTimelinePaneName">Hardware Events</msg>
      <msg name="%IceTimelinePaneName">Timeline</msg>
      <msg name='%IceCbbConcurrencyAreaName'>ICE</msg>
      <msg name='%IceCbbStatesAreaName'>Computing Nodes</msg>
      <msg name='%IceBidStatesAreaName'>Data Buffers</msg>
      <msg name='%IceTotalElapsedTime'>This section provides metrics on an overall workload execution.</msg>
      <msg name='%IceUsageSectionHeader'>Inference Compute Engine Usage</msg>
      <msg name='%IceUsageSectionDescription'>This section lists the most active Inference Compute Engines, sorted by the Running Time. Use this section to understand whether the Intel Neural Network Processor (NNP-I) for deep learning inference was utilized properly.</msg>
      <msg name='%TopCbbsHistogramHeader'>Compute Building Block Histogram</msg>
      <msg name='%TopCbbsHistogramDescription'>This histogram shows the Running Time spent by a given Compute Building Block. Focus on the most active Compute Building Blocks (CBBs) on a given ICE. Optimizing execution time of these CBBs results in improving overall workload performance.</msg>
      <msg name='%TopKernelHotspots'>Hottest Computing Nodes</msg>
      <msg name='%TopKernelHotspotsDescription'>This section lists the most active computing nodes (except for WDSE), sorted by the Running Time. Optimizing execution time of these computing nodes results in improving overall workload performance.</msg>
      <msg name='%TopBIDHotspots'>Hottest Data Buffers</msg>
      <msg name='%TopBIDHotspotsDescription'>This section lists the most active data buffers, sorted by the Processing Time.</msg>
      <msg name='%IceSummaryWindowDescription'>Identify the most active inference compute engines/compute building blocks/computing nodes and data buffers.</msg>
      <msg name='%IceTimelineWindowDescription'>Inference compute engines/compute building blocks/computing nodes and data buffers activity plotted over time.</msg>
      <msg name='%IceBottomUpWindowDescription'>Analyze the most active inference compute engines/compute building blocks/computing nodes and data buffers.</msg>
      <msg name="%IceMemoryBandwidth">Memory Bandwidth, GB/sec</msg>
      <msg name="%IceAverageMemoryBandwidth">Average Memory Bandwidth, GB/sec</msg>
      <msg name="%IceATUMetrics">ATU Metrics</msg>
      <msg name='%AverageBandwidthMB'>Average Bandwidth, MB/sec</msg>
      <msg name='%AverageBandwidthGB'>Average Bandwidth, GB/sec</msg>
      <msg name='%PCIeBandwidthMB'>PCIe Bandwidth, MB/sec</msg>
      <msg name='%PCIeBandwidth'>PCIe Bandwidth</msg>
      <msg name='%InboundPCIeBandwidthMB'>Inbound PCIe Bandwidth (device transactions targeting system memory), MB/sec</msg>
      <msg name='%OutboundPCIeBandwidthMB'>Outbound PCIe Bandwidth (CPU transactions targeting device's MMIO space), MB/sec</msg>
      <msg name='%InboundPCIeBandwidthSection'>Inbound PCIe Bandwidth</msg>
      <msg name='%OutboundPCIeBandwidthSection'>Outbound PCIe Bandwidth</msg>
      <msg name='%OfLabel'>of</msg>
      <msg name='%MetricTooltip'>Select a metric to see its portion in the filtered data.</msg>
      <msg name='%ClearFilterTooltip'>Clear all filters.</msg>
      <msg name='%Any'>Any</msg>
      <msg name='%SelectLabel'>Select</msg>
      <msg name='%Tooltip2dPartLabel'>to filter data by its contribution.</msg>
      <msg name='%BandwidthSystemInfo'>System Bandwidth</msg>
      <msg name='%BandwidthSystemInfoDescription'>This section provides various system bandwidth-related properties detected by the product. These values are used to define default High, Medium and Low bandwidth utilization thresholds for the Bandwidth Utilization Histogram and to scale overtime bandwidth graphs in the Bottom-up view.</msg>
      <msg name='%ViewingLabel'>Viewing</msg>
      <msg name='%SelectedStacksLabel'>selected stack(s)</msg>
      <msg name='%NoStackInformationLabel'>No stack information</msg>
      <msg name='%LoadingLabel'>Loading...</msg>
      <msg name='%ViewSourceLabel'>View Source</msg>
      <msg name='%ShowModulesLabel'>Show Modules</msg>
      <msg name='%ShowSourceFileAndLineLabel'>Show Source File and Line</msg>
      <msg name='%ShowInOneLineModeLabel'>Show in One-Line Mode</msg>
      <msg name='%UnknownSourceFileLabel'>[unknown source file]</msg>
      <msg name='%StackLimitExceededMessage'>Limit for stack depth is exceeded</msg>
      <msg name='%StackCountLimitExceededMessage'>Limit for the number of stacks is exceeded</msg>
      <msg name='%SGXHotspotsViewpointName'>SGX Hotspots</msg>
      <msg name='%SGXHotspotsViewpointShortName'>SGX Hotspots</msg>
      <msg name='%SGXHotspotsViewpointDescription'>This view uses &lt;a href='configs.ebs_collection_f1114'&gt;hardware event-based collection&lt;/a&gt; to display code regions (modules, functions, and so on) that consume a lot of Precise CPU Clockticks (hotspots). Analyze this metric values to identify the most time-consuming program units inside enclaves.</msg>
      <msg name='%percent'>Percent</msg>
      <msg name='%time'>Time</msg>
      <msg name='%bar'>Bar</msg>
      <msg name='%timeAndBar'>Time and Bar</msg>
      <msg name='%percentAndBar'>Percent and Bar</msg>
      <msg name='%count'>Counts</msg>
      <msg name='%countAndBar'>Counts and Bar</msg>
      <msg name='%percent_by'>Percent of <arg name='%1'/></msg>
      <msg name='%integer'>Number</msg>
      <msg name='%integerAndBar'>Number and Bar</msg>
      <msg name='%_double_'>Number</msg>
      <msg name='%doubleAndBar'>Number and Bar</msg>
      <msg name='%scientific'>Scientific</msg>
      <msg name='%scientificAndBar'>Scientific and Bar</msg>
      <msg name='%timeScientific'>Scientific</msg>
      <msg name='%timeScientificAndBar'>Scientific and Bar</msg>
      <msg name='%ratio'>Percent</msg>
      <msg name='%ratioAndBar'>Percent and Bar</msg>
      <msg name='%hex'>Hex</msg>
      <msg name='%LargeNumber'>Number Short Form</msg>
      <msg name='%memory'>Memory Size</msg>
      <msg name='%StacksAsTreeTooltip'>View Stacks as a Tree</msg>
      <msg name='%StacksAsChainTooltip'>View Stacks as a Chain</msg>
      <msg name='%GroupingCustomizationTooltip'>Customize Grouping</msg>
      <msg name='%SelectAllLabel'>Select All</msg>
      <msg name='%ExpandSelectedRowsLabel'>Expand Selected Rows</msg>
      <msg name='%CollapseAllLabel'>Collapse All</msg>
      <msg name='%HideColumnLabel'>Hide Column</msg>
      <msg name='%ShowDataAsLabel'>Show Data As</msg>
      <msg name='%ColumnHelpLabel'>What's This Column?</msg>
      <msg name='%LoadIPTBySelection'>Load Intel Processor Data by Selection</msg>
      <msg name='%FilterInBySelection'>Filter In by Selection</msg>
      <msg name='%FilterOutBySelection'>Filter Out by Selection</msg>
      <msg name='%CopyCellToClipboardLabel'>Copy Cell to Clipboard</msg>
      <msg name='%CopyRowsToClipboardLabel'>Copy Rows to Clipboard</msg>
      <msg name='%ExportToCSVLabel'>Export to CSV...</msg>
      <msg name='%HideColumnLabel'>Hide Column</msg>
      <msg name='%ShowAllColumnsLabel'>Show All Columns</msg>
      <msg name='%FailedToSaveFileLabel'>Failed to save the file.</msg>
      <msg name='%SearchTooltip'>Find (CTRL+F)</msg>
      <msg name='%SearchTooltipMac'>Find (CMD+F)</msg>
      <msg name='%FormulaLabel'>Formula: </msg>
      <msg name='%TotalDataTooltip'>Total metric value includes Self value of the program unit and Self values of its callees.</msg>
      <msg name='%SelfDataTooltip'>Self metric applies to a program unit only, without its callees.</msg>
      <msg name='%ThresholdLabel'>Threshold: </msg>
      <msg name='%PinLabel'>Pin tooltip</msg>
      <msg name='%SelectGroupingLabel'>Select grouping levels from:</msg>
      <msg name='%CustomizeGroupingLabel'>Customize the grouping:</msg>
      <msg name='%GroupingItemsLimitLabel'>Maximum acceptable number of elements in the grouping is reached.</msg>
      <msg name='%CloseGroupingLabel'>The 'Call Stack' level should close the grouping.</msg>
      <msg name='%ByLabel'>by</msg>
      <msg name='%CSVFileFilter'>CSV files (*.csv)|*.csv|All files (*.*)|*</msg>
      <msg name='%ChangeFocusFunctionLabel'>Change Focus Function</msg>
      <msg name='%eDRAMBandwidth'>eDRAM Bandwidth</msg>
      <msg name='%eDRAMBandwidthGB'>eDRAM Bandwidth, GB/sec</msg>
      <msg name='%FpgaViewpointName'>FPGA Usage</msg>
      <msg name='%FpgaViewpointDescription'>FPGA Usage</msg>
      <msg name='%FpgaViewpointShortName'>FPGA Usage</msg>
      <msg name='%Sort_by_row_start'>Row Start Time</msg>
      <msg name='%Sort_by_row_label'>Row Label</msg>
      <msg name='%Band_normal'>Normal</msg>
      <msg name='%Band_rich'>Rich</msg>
      <msg name='%Band_super_tiny'>Super Tiny</msg>
      <msg name='%Time_unit'>Show Time Scale As</msg>
      <msg name='%Time_unit_db_tsc'>DB Timestamp (internal)</msg>
      <msg name='%Time_unit_cpu_tsc'>CPU Timestamp</msg>
      <msg name='%Time_unit_os_tsc'>OS Timestamp</msg>
      <msg name='%Time_unit_second'>Elapsed Time</msg>
      <msg name='%Unknown'>[Unknown]</msg>
      <msg name='%ZoomInLabel'>Zoom In</msg>
      <msg name='%ZoomOutLabel'>Zoom Out</msg>
      <msg name='%ZoomResetLabel'>Reset Zoom</msg>
      <msg name='%ZoomUndoLabel'>Undo Previous Zoom</msg>
      <msg name='%ZoomInOnSelectionLabel'>Zoom In on Selection</msg>
      <msg name='%FilteredOutTooltip'>Filtered Out</msg>
      <msg name='%FilterInBySelectionLabel'>Filter In by Selection</msg>
      <msg name='%FilterOutBySelectionLabel'>Filter Out by Selection</msg>
      <msg name='%ZoomInAndFilterInBySelectionLabel'>Zoom In and Filter In by Selection</msg>
      <msg name='%RemoveAllFiltersLabel'>Remove All Filters</msg>
      <msg name='%BandModeLabel'>Change Band Height</msg>
      <msg name='%TimeScaleLabel'>Show Time Scale As</msg>
      <msg name='%SortByLabel'>Sort by</msg>
      <msg name='%PausedRangeHint'>paused</msg>
      <msg name='%DismissMenuLabel'>Dismiss Menu</msg>
      <msg name='%AscendingLabel'>Ascending</msg>
      <msg name='%DescendingLabel'>Descending</msg>
      <msg name='%BandwidthUtilizationStatistic'>Bandwidth Utilization</msg>
      <msg name='%NoDataSerialHotspots'>No data to show. Try to re-resolve the result.</msg>
      <msg name='%TopSerialHotspots'>Top Serial Hotspots (outside parallel regions)</msg>
      <msg name='%RulerAreaLegendLabel'>Scale Markers:</msg>
      <msg name='%TimelineTooltipDurationLabel'>Duration</msg>
      <msg name='%TimelineTooltipItemsShownLabel'>Item(s) shown</msg>
      <msg name='%TimelineTooltipStartLabel'>Start</msg>
      <msg name='%TimelineTooltipToLabel'>to</msg>
      <msg name='%TimelineTooltipOutOfLabel'>out of</msg>
      <msg name='%PCIeTrafficSummary'>PCIe Traffic Summary</msg>
      <msg name='%UncacheableReadTopHotspots'>Top Functions Using Uncacheable Reads</msg>
      <msg name='%UncacheableReadTopHotspotsDescription'>This section lists functions most actively reading from unacheable memory during collection run. In case of non-zero outbound read traffic, explore these functions to locate the sources of reads from MMIO space. MMIO reads are expensive operations that should be avoided on the hot path.</msg>
      <msg name='%DpdkRxBatchStatistics'>DPDK Rx Batch Statistics</msg>
      <msg name='%DpdkRxBatchStatisticsDescription'>In data plane applications, where fast packet processing is required, the DPDK polls a certain port for incoming packets in an infinite loop. To understand efficiency of the polling thread utilization, explore the batch statistics of fetching packets with the rte_eth_rx_burst() batch operation.</msg>
      <msg name='%DpdkInfo'>DPDK Info</msg>
      <msg name='%DpdkVTuneSupportInfoDescription'>DPDK data was not collected. To collect DPDK data, make sure that DPDK is compiled with VTune profiling options enabled</msg>
      <msg name='%DpdkDequeueStatistics'>DPDK Events Dequeue Statistics</msg>
      <msg name='%DpdkDequeueStatisticsDescription'>Explore the statistics of the events dequeued by rte_event_dequeue_burst() function to understand the efficiency of the eventdev pipeline.</msg>
      <msg name='%spdkIo'>SPDK IOPs</msg>
      <msg name='%spdkIoBytes'>SPDK Throughput, MB/sec</msg>
      <msg name='%SpdkInfo'>SPDK Info</msg>
      <msg name='%SpdkBandwidthInfo'>SPDK Throughput</msg>
      <msg name='%SpdkBandwidthInfoDescription'>Analyze information on the SPDK throughput utilization per device.</msg>
      <msg name='%SpdkBandwidthHistogram'>SPDK Throughput Histogram</msg>
      <msg name='%SpdkBandwidthHistogramDescription'>Explore an over-time distribution of the throughput utilization by IO operations for the selected SPDK device.</msg>
      <msg name='%SpdkOperationsGrid'>SPDK Throughput Utilization Info</msg>
      <msg name='%SpdkOperationsGridDescription'>This section provides statistics on the SPDK activity by a throughput utilization level.</msg>
      <msg name='%SpdkLatencyInfo'>SPDK Latency</msg>
      <msg name='%SpdkLatencyInfoDescription'>Analyze information on the SPDK operations latency per device.</msg>
      <msg name='%SpdkLatencyHistogram'>SPDK Latency Histogram</msg>
      <msg name='%SpdkLatencyHistogramDescription'>Explore the distribution of the IO operations latency over time for the selected SPDK device.</msg>
      <msg name='%SpdkLatencyGrid'>SPDK Operations Latency Info</msg>
      <msg name='%SpdkLatencyGridDescription'>This section provides statistics on the SPDK activity by a operations latency level.</msg>
      <msg name='%SpdkVTuneSupportInfoDescription'>No SPDK data is collected. For successful analysis, make sure SPDK is built using the --with-vtune option.</msg>
      <msg name='%GPUDRAMBandwidthWhenBusyHeaderDescription'>Identify whether performance of your code executing on the GPU is bounded by DRAM bandwidth.</msg>
      <msg name='%TopGPUTasksWithGPUDRAMBandwidthProblems'>Hottest GPU Computing Tasks Bound by DRAM Bandwidth</msg>
      <msg name='%TopGPUTasksWithGPUDRAMBandwidthProblemsDescription'>This section lists the most active computing tasks running on the GPU and heavily using DRAM bandwidth. The tasks are sorted by Total Time.</msg>
      <msg name='%HotspotsPtViewpointName'>Anomaly Detection (Intel Processor Trace)</msg>
      <msg name='%HotspotsPtViewpointShortName'>Anomaly Detection</msg>
      <msg name='%HotspotsPtViewpointDescription'>This view helps to detect anomalies using the data collected with Intel Processor Trace (IPT) technology. Unlike a traditional sampling-based approach, the IPT is able to analyze short code regions (functions, loops iterations, tasks, or frames) and detect sporadic short-term issues.</msg>
      <msg name='%Parallelism'>Parallelism</msg>
      <msg name='%ParallelismDescription'>Effective parallel execution of an application on available processor cores significantly helps to reduce elapsed time of an application or do more work for the same time.</msg>
      <msg name='%Microarchitecture'>CPU Microarchitecture</msg>
      <msg name='%MicroarchitectureDescription'>Effective execution of an application on processor microarchitecture is essential on getting maximum application performance.</msg>
      <msg name='%Vectorization'>Vectorization</msg>
      <msg name='%VectorizationDescription'>Effective use of vectorization capabilities of the system can significantly help to reduce elapsed time of an application or do more work for the same time.</msg>
      <msg name='%ParallelismRecommendation'><![CDATA[ The application significantly underutilizes logical cores available on the system for useful work. It makes sense to run Concurrency analysis to explore on reasons of underutilization.<p><a class="icon analysis-hotspots" action-link="?type=collection&analysisId=%ConcurrencyAtypeName&helpId=configs.event_based_analysis_f1103" cli="Concurrency">Concurrency</a></p> ]]> </msg>
      <msg name='%MicroarchitectureRecommendation'><![CDATA[ Run Microarchitecture Exploration analysis to identify areas for improvement.<p><a class="icon analysis-hotspots" action-link="?type=collection&analysisId=%MicroarchitectureExplorationAtypeName&helpId=configs.event_based_analysis_f1103" cli="Microarchitecture Exploration">Microarchitecture Exploration</a></p> ]]> </msg>
      <msg name='%VectorizationRecommendation'><![CDATA[ The application significantly underutilizes vector processing unit. Run <a web-link="https://software.intel.com/en-us/intel-advisor-xe" cli="HPC Performance Characterization or Intel Advisor">Intel Advisor</a> tool to get insight into possible causes of inefficient vectorization. ]]></msg>
      <msg name='%AlgorithmAnalysis'>Algorithm Analysis</msg>
      <msg name='%AlgorithmAnalysisDescription'>Identify inefficiencies in your current algorithms and improve application performance as recommended.</msg>
      <msg name='%TopHotspotsRecommendation'><![CDATA[ If you see significant hotspots in the Top Hotspots list, switch to the <a action-link="?type=navigate&tabId=bottomUpPane&handlerId=bottomUpPane">Bottom-up</a> view for in-depth analysis per function. Otherwise, use the <a action-link="?type=navigate&tabId=callerCalleePane&handlerId=callerCalleePane">Caller/Callee</a> view to track critical paths for these hotspots. ]]></msg>
      <msg name='%Insights'>INSIGHTS</msg>
      <msg name='%HotspotsInsights'>Hotspots Insights</msg>
      <msg name='%ExploreAdditionalInsights'>Explore Additional Insights</msg>
      <msg name='%ParallelEfficiencyRecommendation'><![CDATA[ Use <a class="icon analysis-parallelism" action-link="?type=collection&analysisId=%ThreadingAtypeName&helpId=configs.analysis_type_thread" cli="Threading">Threading</a> to explore more opportunities to increase parallelism in your application. ]]></msg>
      <msg name='%HWUsageEfficiencyRecommendation'><![CDATA[ Use <a class="icon analysis-microarchitecture" action-link="?type=collection&analysisId=%MicroarchitectureExplorationAtypeName&helpId=configs.event_based_analysis_f1103" cli="Microarchitecture Exploration">Microarchitecture Exploration</a> to explore how efficiently your application runs on the used hardware. ]]></msg>
      <msg name="%VectorRegisterUtilization">Vector Register Utilization</msg>
      <msg name='%VectorRegisterUtilizationRecommendation'><![CDATA[ Use <a web-link="https://software.intel.com/en-us/intel-advisor-xe" cli="Intel Advisor">Intel Advisor</a> to learn more on vectorization efficiency of your application. ]]></msg>
      <msg name='%Recommendations'>Recommendations</msg>
      <msg name='%OmniPathUsage'>Intel Omni-Path Fabric Usage</msg>
      <msg name='%topFunctionWithSpinOverheadTime'>Top Functions with Spin or Overhead Time</msg>
      <msg name='%topFunctionWithSpinOverheadTimeDescription'>The section lists top functions in your application with the most spin and overhead time.</msg>
      <msg name='%mainWindow.configureAnalysis'>Configure Analysis</msg>
      <msg name='%mainWindow.compare'>Compare...</msg>
      <msg name='%mainWindow.import'>Import...</msg>
      <msg name='%mainWindow.welcome'>Welcome</msg>
      <msg name='%mainWindow.titleInitializing'>Initializing...</msg>
      <msg name='%mainWindow.configure'>New <arg name='prod_name'/>Result</msg>
      <msg name='%mainWindow.loading'>Loading...</msg>
      <msg name='%mainWindow.openingResult'>Opening result...</msg>
      <msg name='%PMUEventSamples'>Hardware Events Samples</msg>
      <msg name='%PMUUncoreEvents'>Uncore Events</msg>
      <msg name='%ClkSample'>Clocktick Sample</msg>
      <msg name="%uTubeDataNotConfident"><![CDATA[ The number of samples collected are not enough to build a metrics tree. Increase the time your workload runs or decrease the <a web-link="https://software.intel.com/en-us/vtune-amplifier-help-sampling-interval" cli="sampling interval">sampling interval</a> to generate a metrics tree. ]]></msg>
      <msg name="%ParallelFs">Parallel File System</msg>
      <msg name="%PerfSnapshotTreeHeader">Choose your next analysis type</msg>
      <msg name="%PerfSnapshotTreeHeaderDetails">Select a highlighted recommendation based on your performance snapshot.</msg>
      <msg name='%AnomalyRegionDuration'>Code Region Of Interest Duration Histogram</msg>
      <msg name='%AnomalyRegionDurationDescription'>Identify anomalies with a histogram of durations spent on code regions of interest.</msg>
      <msg name='%AnomalyRegionDurationChart'>Code Region Of Interest Duration Histogram</msg>
      <msg name='%AnomalyRegionDurationChartDescription'>This histogram shows the total number of code regions of interest (marked for anomaly detection) that were executed for a specific duration. Slow instances can signal an anomaly.</msg>
      <msg name='%AnomalyRegionByDuration'>Code Region Of Interests Count By Duration Type</msg>
      <msg name='%CpuGpuInteractionViewpointName'>GPU Offload (preview)</msg>
      <msg name='%CpuGpuInteractionViewpointDescription'>GPU Offload (preview)</msg>
      <msg name='%CpuGpuInteractionViewpointShortName'>GPU Offload (preview)</msg>
      <msg name='%InKernelProfilingViewpointName'>GPU Compute/Media Hotspots (preview)</msg>
      <msg name='%CpuGpuInteractionViewpointDescription'>GPU Compute/Media Hotspots (preview)</msg>
      <msg name='%CpuGpuInteractionViewpointShortName'>GPU Compute/Media Hotspots (preview)</msg>
      <msg name='%ThrottlingViewpointName'>Throttling</msg>
      <msg name='%ThrottlingViewpointShortName'>Throttling</msg>
      <msg name='%ThrottlingViewpointDescription'><![CDATA[ Identify whether your system is experiencing lower performance due to throttling of frequencies which can be caused by exceeding thermal or power limits or even incorrect settings in the OS or BIOS. <a web-link="" cli="">Learn more</a> ]]></msg>
      <msg name='%PowerUsage'>Power Usage</msg>
      <msg name='%SystemOverviewSummaryWindowDescription'>Identify System-level Hotspots and Hardware issues</msg>
      <msg name='%Active'>Active</msg>
      <msg name='%Stalled'>Stalled</msg>
      <msg name='%Idle'>Idle</msg>
      <msg name='%ThreadOccupancy'>Occupancy</msg>
      <msg name='%StalledIdle'>Stalled/Idle</msg>
      <msg name='%ThreadIssued'>Threads Issued</msg>
      <msg name='%Busy'>Busy</msg>
      <msg name='%Bottleneck'>Bottleneck</msg>
      <msg name='%Read'>Read</msg>
      <msg name='%Untyped'>Untyped</msg>
      <msg name='%Typed'>Typed</msg>
      <msg name='%SLM'>SLM</msg>
      <msg name='%Write'>Write</msg>
      <msg name='%GPU'>GPU</msg>
      <msg name='%euArray'>Execution Unit</msg>
      <msg name='%Sampler'>Sampler</msg>
      <msg name='%L1'>L1</msg>
      <msg name='%L2'>L2</msg>
      <msg name='%PCIe'>PCIe</msg>
      <msg name='%Total'>Total</msg>
      <msg name='%UntypedRead'>Untyped Read</msg>
      <msg name='%UntypedWrite'>Untyped Write</msg>
      <msg name='%TypedRead'>Typed Read</msg>
      <msg name='%TypedWrite'>Typed Write</msg>
      <msg name='%MissRate'>Miss Rate</msg>
      <msg name='%MissRatio'>Miss Ratio</msg>
      <msg name='%SLMRead'>SLM Read</msg>
      <msg name='%SLMWrite'>SLM Write</msg>
      <msg name='%SLM'>SLM</msg>
      <msg name='%L3'>L3</msg>
      <msg name='%GTI'>GTI</msg>
      <msg name='%Uncore'>Uncore</msg>
      <msg name='%System'>System</msg>
      <msg name='%LLC'>LLC</msg>
      <msg name='%DRAMDGR'>DRAM</msg>
      <msg name='%EDRAMDGR'>eDRAM</msg>
      <msg name='%Utilization'>Utilization</msg>
      <msg name='%CPU'>CPU</msg>
      <msg name='%CPUCores'>CPU core</msg>
      <msg name='%sS'>SubSlice</msg>
      <msg name='%slice'>Slice</msg>
      <msg name='%ModuleEntryPoint'>Module Entry Point</msg>
      <msg name="%IPTModuleKernelTaskCount">Count</msg>
      <msg name="%IPTModuleKernelTaskCountDescription">The total number of kernel-mode entries.</msg>
      <msg name="%IPTModuleKernelTaskFrequency">Frequency, count/sec</msg>
      <msg name="%IPTModuleKernelTaskFrequencyDescription">The total number of kernel-mode entries calculated per second.</msg>
      <msg name="%IPTModuleKernelTaskMetrics">Kernel-mode Entries</msg>
      <msg name="%ContextSwitchArea">OS Scheduling Impact</msg>
      <msg name="%KernelEntriesArea">OS Kernel Activity</msg>
      <msg name="%KernelEntriesOvertime">Kernel-mode Entries Count</msg>
      <msg name='%CATSupport'>Cache Allocation Technology</msg>
      <msg name='%L2CA'>Level 2 capability</msg>
      <msg name='%L3CA'>Level 3 capability</msg>
    </catalog>
</xmc>
