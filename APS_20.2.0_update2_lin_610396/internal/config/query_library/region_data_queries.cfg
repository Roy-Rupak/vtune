<?xml version="1.0" encoding="UTF-8"?>
<!--

 Copyright Â© 2009-2020 Intel Corporation. All rights reserved.

 The information contained herein is the exclusive property of
 Intel Corporation and may not be disclosed, examined, or reproduced in
 whole or in part without explicit written authorization from the Company.

-->
<bag
  xmlns:boolean="http://www.w3.org/2001/XMLSchema#boolean"
  xmlns:byte="http://www.w3.org/2001/XMLSchema#byte"
  xmlns:short="http://www.w3.org/2001/XMLSchema#short"
  xmlns:int="http://www.w3.org/2001/XMLSchema#int"
  xmlns:long="http://www.w3.org/2001/XMLSchema#long"
  xmlns:unsignedByte="http://www.w3.org/2001/XMLSchema#unsignedByte"
  xmlns:unsignedShort="http://www.w3.org/2001/XMLSchema#unsignedShort"
  xmlns:unsignedInt="http://www.w3.org/2001/XMLSchema#unsignedInt"
  xmlns:unsignedLong="http://www.w3.org/2001/XMLSchema#unsignedLong"
  xmlns:float="http://www.w3.org/2001/XMLSchema#float"
  xmlns:double="http://www..org/2001/XMLSchema#double"
  xmlns:null="http://www.intel.com/2009/BagSchema#null"
  xmlns:blob="http://www.intel.com/2009/BagSchema#blob"
  >
  <queryLibrary xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:str="http://exslt.org/strings" str:keep_str_namespace=""
    xmlns:exsl="http://exslt.org/common" exsl:keep_exsl_namespace="">
    <infoQuery id="RegionProcess" displayName="%Process">
      <dbPath>region_data::dd_region.process</dbPath>
      <displayDbPathSuffix>name</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="RegionProcessID" displayName="%ProcessID">
      <dbPath>region_data::dd_region.process</dbPath>
      <displayDbPathSuffix>pid</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="RegionProcessStartTsc" displayName="%ProcessStartTsc">
      <dbPath>region_data::dd_region.process</dbPath>
      <displayDbPathSuffix>start_tsc</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="RegionProcessEndTsc" displayName="%ProcessEndTsc">
      <dbPath>region_data::dd_region.process</dbPath>
      <displayDbPathSuffix>end_tsc</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="BarrierProcess" displayName="%Process">
      <dbPath>barrier_data::dd_barrier.process</dbPath>
      <displayDbPathSuffix>name</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="BarrierProcessID" displayName="%ProcessID">
      <dbPath>barrier_data::dd_barrier.process</dbPath>
      <displayDbPathSuffix>pid</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="BarrierImbalanceProcess" displayName="%Process">
      <dbPath>barrier_imbalance_data::dd_process</dbPath>
      <displayDbPathSuffix>name</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="BarrierImbalanceProcessID" displayName="%ProcessID">
      <dbPath>barrier_imbalance_data::dd_process</dbPath>
      <displayDbPathSuffix>pid</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="ElapsedTimeProcess" displayName="%Process">
      <dbPath>elapsed_time_data::dd_process</dbPath>
      <displayDbPathSuffix>name</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="ElapsedTimeProcessID" displayName="%ProcessID">
      <dbPath>elapsed_time_data::dd_process</dbPath>
      <displayDbPathSuffix>pid</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="BarrierDomain" displayName="%BarrierDomain">
      <dbPath>barrier_data::dd_barrier.attribute</dbPath>
      <displayDbPathSuffix>domain.name</displayDbPathSuffix>
      <aliasForUnknown>%AliasUnknownBarrier</aliasForUnknown>
    </infoQuery>
    <infoQuery id="BarrierType" displayName="%BarrierType">
      <dbPath>barrier_data::dd_barrier.attribute.type</dbPath>
      <displayDbPathSuffix>name</displayDbPathSuffix>
      <aliasForUnknown>%AliasUnknownBarrierType</aliasForUnknown>
    </infoQuery>
    <infoQuery id="BarrierScheduleType" displayName="%BarrierScheduleType">
      <dbPath>barrier_data::dd_barrier.attribute.schedule_type</dbPath>
      <displayDbPathSuffix>name</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="BarrierChunk" displayName="%BarrierChunk">
      <dbPath>barrier_data::dd_barrier.attribute.chunk</dbPath>
    </infoQuery>
    <customMetricQuery id="BarrierIterationsCount" displayName="%BarrierIterationsCount">
      <boolean:useGlobalGrouper>true</boolean:useGlobalGrouper>
      <instanceDbTable>barrier_data::dd_barrier</instanceDbTable>
      <metricName>loop_iteration_count</metricName>
      <valueType>count</valueType>
      <instanceBandTable>parallel_region_and_barrier_per_process_metrics</instanceBandTable>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </customMetricQuery>
    <customMetricQuery id="BarrierIterationsCountMax" displayName="%BarrierIterationsCountMax">
      <queryInherit>/BarrierIterationsCount</queryInherit>
      <aggregationType>max</aggregationType>
    </customMetricQuery>
    <customMetricQuery id="BarrierIterationsCountMin" displayName="%BarrierIterationsCountMin">
      <queryInherit>/BarrierIterationsCount</queryInherit>
      <aggregationType>min</aggregationType>
    </customMetricQuery>
    <derivedQuery id="DerivedBarrierIterationsCountAvg" displayName="%BarrierIterationsCountAvg">
      <valueEval><![CDATA[ query("/BarrierIterationsCount") / query("/BarrierInstanceCount") + query("/BarrierChunk") - query("/BarrierChunk") ]]></valueEval>
      <issueEval><![CDATA[ ( query("/DerivedBarrierIterationsCountAvg") < query("/OpenMPThreadCount") * ( query("/BarrierChunk") - 1 )) && ( query("/DerivedBarrierIterationsCountAvg") > 0 )]]></issueEval>
      <valueType>count</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="DerivedBarrierIterationsCountMin" displayName="%BarrierIterationsCountMin">
      <valueEval><![CDATA[ query("/BarrierIterationsCountMin") + query("/BarrierChunk") - query("/BarrierChunk") ]]></valueEval>
      <issueEval><![CDATA[ ( query("/DerivedBarrierIterationsCountMin") < query("/OpenMPThreadCount") * ( query("/BarrierChunk") -1 )) && (query("/DerivedBarrierIterationsCountMin") > 0 ) ]]></issueEval>
      <valueType>count</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="DerivedBarrierIterationsCountMax" displayName="%BarrierIterationsCountMax">
      <valueEval><![CDATA[ query("/BarrierIterationsCountMax") + query("/BarrierChunk") - query("/BarrierChunk") ]]></valueEval>
      <issueEval><![CDATA[ ( query("/DerivedBarrierIterationsCountMax") < query("/OpenMPThreadCount") * ( query("/BarrierChunk") - 1 )) && (query("/DerivedBarrierIterationsCountMax") > 0 ) ]]></issueEval>
      <valueType>count</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
      </displayAttributes>
    </derivedQuery>
    <infoQuery id="Barrier" displayName="%BarrierDomain">
      <dbPath>barrier_data::dd_barrier</dbPath>
      <aliasForUnknown>%AliasUnknownBarrier</aliasForUnknown>
      <displayAttributes>
        <timelineIconType>duration</timelineIconType>
      </displayAttributes>
    </infoQuery>
    <infoQuery id="BarrierGlobal" displayName="%BarrierDomain">
      <xsl:if test="exsl:ctx('openmpProcessCount')=1">
        <queryInherit>/Barrier</queryInherit>
      </xsl:if>
    </infoQuery>
    <infoQuery id="Region" displayName="%Region">
      <dbPath>region_data::dd_region</dbPath>
      <displayAttributes>
        <timelineGraphColor>0,162,232</timelineGraphColor>
        <timelineIconType>duration</timelineIconType>
      </displayAttributes>
      <aliasForUnknown>%AliasUnknownRegion</aliasForUnknown>
      <valueType>int</valueType>
    </infoQuery>
    <infoQuery id="RegionGlobal" displayName="%Region">
      <xsl:if test="exsl:ctx('openmpProcessCount')=1">
        <queryInherit>/Region</queryInherit>
      </xsl:if>
    </infoQuery>
    <infoQuery id="RegionDomain" displayName="%RegionDomain">
      <dbPath>region_data::dd_region.bin.type.attributes</dbPath>
      <displayDbPathSuffix>domain.name</displayDbPathSuffix>
      <aliasForUnknown>%AliasUnknownRegionDomain</aliasForUnknown>
      <diveQuery>/SourceFunction</diveQuery>
      <diveSuffix>dive_target.function</diveSuffix>
      <displayAttributes>
        <diveInitialSelection>disDiveObjectStart</diveInitialSelection>
      </displayAttributes>
    </infoQuery>
    <infoQuery id="RegionDuration" displayName="%RegionDuration">
      <dbPath>region_data::dd_region.bin</dbPath>
      <displayDbPathSuffix>duration</displayDbPathSuffix>
      <displayAttributes>
        <timelineFormat>area</timelineFormat>
        <timelineGraphColor>0,162,232</timelineGraphColor>
      </displayAttributes>
    </infoQuery>
    <infoQuery id="RegionType" displayName="%RegionType">
      <dbPath>region_data::dd_region.bin.type.type_name</dbPath>
      <displayDbPathSuffix>name</displayDbPathSuffix>
      <aliasForUnknown>%AliasUnknownRegionType</aliasForUnknown>
    </infoQuery>
    <infoQuery id="OpenMPThreadCount" displayName="%OpenMPThreadCount">
      <dbPath>region_data::dd_region.bin.type.attributes.thread_count_ref</dbPath>
      <displayDbPathSuffix>count</displayDbPathSuffix>
      <description>%OpenMPThreadCountDescription</description>
    </infoQuery>
    <infoQuery id="OpenMPThreadCountAggregationSum" displayName="%OpenMPThreadCount">
      <queryInherit>/OpenMPThreadCount</queryInherit>
      <displayAttributes>
        <aggregation>AggregateSum</aggregation>
      </displayAttributes>
    </infoQuery>
    <timeQuery id="RegionTime" displayName="%RegionTime">
      <helpKeyword>configs.regiontime_regiontimedescription</helpKeyword>
      <description>%RegionTimeDescription</description>
      <boolean:useGlobalGrouper>true</boolean:useGlobalGrouper>
      <instanceDbTable>region_data::dd_region</instanceDbTable>
      <instanceBandTable>parallel_region_and_barrier_per_process_metrics</instanceBandTable>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </timeQuery>
    <infoQuery id="MpiCriticalRankFlag">
      <dbPath>elapsed_time_data::dd_process.is_critical_rank</dbPath>
      <displayDbPathSuffix>value</displayDbPathSuffix>
      <valueType>string</valueType>
    </infoQuery>
    <derivedQuery id="RegionTimeMpiCriticalRank" displayName="%RegionTime">
      <helpKeyword>configs.regiontime_regiontimedescription</helpKeyword>
      <description>%RegionTimeDescription</description>
      <valueEval><![CDATA[ query("/RegionTime/MpiCriticalRankFlag[%True]") ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="TotalOpenMPThreadCountMpiCriticalRank" displayName="%OpenMPThreadCount">
      <valueEval>$criticalRankOpenmpThreadCount</valueEval>
      <valueType>count</valueType>
    </derivedQuery>
    <derivedQuery id ="AvgRegionCPUUsage" displayName ="%CPUUsageAverage">
      <description>%CPUUsageAverageDescription</description>
      <valueEval>
        <xsl:choose>
          <xsl:when test="exsl:ctx('runsa:enable', 0) or (exsl:ctx('runsa:enable', 'na') = 'na' and exsl:ctx('runss:enable', 'na') = 'na' and not(exsl:IsTableExist('cpu_data')) and exsl:IsTableExist('pmu_data'))">
            <![CDATA[query("/PMUUserTime") / query("/RegionTime")]]>
          </xsl:when>
          <xsl:otherwise>
            <![CDATA[query("/CPUUserTime") / query("/RegionTime")]]>
          </xsl:otherwise>
        </xsl:choose>
      </valueEval>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
    </derivedQuery>
    <timeQuery id="BarrierTime" displayName="BarrierTime">
      <description>%RegionTimeDescription</description>
      <boolean:useGlobalGrouper>true</boolean:useGlobalGrouper>
      <instanceDbTable>barrier_data::dd_barrier</instanceDbTable>
      <instanceBandTable>parallel_region_and_barrier_per_process_metrics</instanceBandTable>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </timeQuery>
    <timeQuery id="ProcessElapsedTime" displayName="%ElapsedTime">
      <helpKeyword>configs.elapsedtime_elapsedtimedescription</helpKeyword>
      <description>%ElapsedTimeDescription</description>
      <boolean:useGlobalGrouper>true</boolean:useGlobalGrouper>
      <instanceDbTable>elapsed_time_data::dd_process</instanceDbTable>
      <instanceBandTable>parallel_region_and_barrier_per_process_metrics</instanceBandTable>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </timeQuery>
    <timeQuery id="GlobalElapsedTime" displayName="%GlobalElapsedTime">
      <helpKeyword>configs.globalelapsedtime_elapsedtimedescription</helpKeyword>
      <description>%ElapsedTimeDescription</description>
      <boolean:useGlobalGrouper>true</boolean:useGlobalGrouper>
      <instanceDbTable>global_elapsed_time_data</instanceDbTable>
      <instanceBandTable>global_time_interval_metrics</instanceBandTable>
      <issueEval>$shortCollectionMux</issueEval>
      <issueText>%ShortCollectionMuxRecommendationIssue</issueText>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </timeQuery>
    <derivedQuery id="GlobalElapsedTimeQueryAll" displayName="%GlobalElapsedTime">
      <helpKeyword>configs.globalelapsedtime_elapsedtimedescription</helpKeyword>
      <description>%ElapsedTimeDescription</description>
      <valueEval><![CDATA[ queryAll("/GlobalElapsedTime", true) ]]></valueEval>
      <valueType>time</valueType>
    </derivedQuery>
    <timeQuery id="RegionCpuUsageElapsedTime">
      <queryInherit>/CpuUsageElapsedTime</queryInherit>
      <instanceBandTable>parallel_region_metrics</instanceBandTable>
    </timeQuery>
    <timeQuery id="GPUElapsedTime" displayName="%GlobalElapsedTime">
      <xsl:choose>
        <xsl:when test="exsl:ctx('gsimClockDuration', 0) > 0">
          <queryInherit>/GPUComputeTaskTime</queryInherit>
        </xsl:when>
        <xsl:otherwise>
          <boolean:useGlobalGrouper>true</boolean:useGlobalGrouper>
          <instanceDbTable>gpu_elapsed_time_data</instanceDbTable>
          <instanceBandTable>dd_gpu_node</instanceBandTable>
          <displayAttributes>
            <boolean:canBeDoi>false</boolean:canBeDoi>
          </displayAttributes>
          <joinGroupInstanceDbTable>gpu_data</joinGroupInstanceDbTable>
        </xsl:otherwise>
      </xsl:choose>
    </timeQuery>
    <timeQuery id="GPUNodeElapsedTime" displayName="%GlobalElapsedTime">
      <instanceDbTable>gpu_node_elapsed_time_data</instanceDbTable>
      <instanceBandTable>dd_gpu_node</instanceBandTable>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </timeQuery>
    <instanceCountQuery id="RegionInstanceCount" displayName="%RegionCount">
      <boolean:useGlobalGrouper>true</boolean:useGlobalGrouper>
      <instanceDbTable>region_data::dd_region</instanceDbTable>
      <instanceBandTable>parallel_region_per_process_metrics</instanceBandTable>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </instanceCountQuery>
    <instanceCountQuery id="BarrierInstanceCount" displayName="%BarrierCount">
      <boolean:useGlobalGrouper>true</boolean:useGlobalGrouper>
      <instanceDbTable>barrier_data::dd_barrier.domain</instanceDbTable>
      <instanceBandTable>parallel_region_and_barrier_per_process_metrics</instanceBandTable>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </instanceCountQuery>
    <countQuery id="ImbalanceTsc" displayName="%ImbalanceTsc">
      <boolean:useGlobalGrouper>true</boolean:useGlobalGrouper>
      <instanceDbTable>barrier_imbalance_data::dd_process</instanceDbTable>
      <instanceBandTable>parallel_region_and_barrier_per_process_metrics</instanceBandTable>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </countQuery>
    <infoQuery id="RegionTypeMinValue">
      <dbPath>region_data::dd_region.bin.type</dbPath>
      <displayDbPathSuffix>min_value</displayDbPathSuffix>
      <aliasForUnknown>%AliasUnknownRegionType</aliasForUnknown>
    </infoQuery>
    <derivedQuery id="ImbalancePotentialGain" displayName="%ImbalanceTime">
      <helpKeyword>configs.imbalancetime_imbalancepotentialgaindescription</helpKeyword>
	  <valueEval><![CDATA[ ( query("/ImbalanceTsc") / 10000000000.0 ) / query("/OpenMPThreadCount") ]]></valueEval>
      <issueEval><![CDATA[ (query("/ImbalancePotentialGain") > (query("/TotalElapsedTimeNoPause") * .10)) ]]></issueEval>
      <description>%ImbalancePotentialGainDescription</description>
      <issueText>%ImbalancePotentialGainIssueText</issueText>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
      </displayAttributes>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="ImbalancePotentialGainPercentsElapsed" displayName="%ImbalanceTimePercentsElapced">
      <helpKeyword>configs.imbalancetimepercentselapced_imbalancepotentialgainpercentselapseddescription</helpKeyword>
	  <xsl:choose>
        <xsl:when test="(exsl:ctx('openmpProcessCount') = 1)">
          <valueEval><![CDATA[ query("/ImbalancePotentialGain") / query("/TotalElapsedTimeNoPause")]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/ImbalancePotentialGain") * 10000000000.0 / (query("/RegionProcessEndTsc") - query("/RegionProcessStartTsc") + 1)]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <issueEval><![CDATA[ (query("/ImbalancePotentialGain") > (query("/TotalElapsedTimeNoPause") * .10)) ]]></issueEval>
      <description>%ImbalancePotentialGainPercentsElapsedDescription</description>
      <issueText>%ImbalancePotentialGainIssueText</issueText>
      <valueType>ratio</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="TotalOpenMPThreadCount" displayName="%OpenMPThreadCount">
      <valueEval>$openmpThreadCount</valueEval>
      <valueType>count</valueType>
    </derivedQuery>
    <derivedQuery id="ImbalancePotentialGainForSummary">
      <queryInherit>/ImbalancePotentialGain</queryInherit>
      <valueEval><![CDATA[ ( query("/ImbalanceTsc") / 10000000000.0 ) / query("/TotalOpenMPThreadCount") ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="PMUUserTimeInsideRegions" displayName="%UserTimeInsideRegions">
      <valueEval><![CDATA[ query("/PMUUserTime/RegionType[%FastRegion]") + query("/PMUUserTime/RegionType[%GoodRegion]") + query("/PMUUserTime/RegionType[%SlowRegion]") ]]></valueEval>
      <valueType>time</valueType>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
    </derivedQuery>
    <derivedQuery id="CPUUserTimeInsideRegions" displayName="%UserTimeInsideRegions">
      <valueEval><![CDATA[ query("/CPUUserTime/RegionType[%FastRegion]") + query("/CPUUserTime/RegionType[%GoodRegion]") + query("/CPUUserTime/RegionType[%SlowRegion]") ]]></valueEval>
      <valueType>time</valueType>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMU" displayName="%RegionPotentialGain">
      <helpKeyword>configs.regionpotentialgain_regionpotentialgaindescription</helpKeyword>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
          <valueEval><![CDATA[ query("/ImbalancePotentialGain") + query("/PMUSpinBusyWaitOnLockWallTime") + query("/PMUOverheadWorkForkingWallTime") + query("/PMUOverheadWorkSchedulingAndTaskingWallTime") + query("/PMUOverheadReductionWallTime") + query("/PMUOverheadAtomicsWallTime") ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/RegionTime") - query("/PMUUserTimeInsideRegions") / query("/OpenMPThreadCount")]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <description>%RegionPotentialGainDescription</description>
      <minEval>0</minEval>
      <valueType>time</valueType>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
      </displayAttributes>
      <issueEval><![CDATA[ query("/RegionPotentialGainPMU") > (query("/TotalElapsedTimeNoPause") * .10) ]]></issueEval>
      <confidenceEval><![CDATA[ query("/ClocktickSamples") >= 10  * query("/OpenMPThreadCount") ]]></confidenceEval>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
      <issueText>%RegionPotentialGainForSummaryIssueText</issueText>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUMpiCriticalRank" displayName="%RegionPotentialGain">
      <helpKeyword>configs.regionpotentialgain_regionpotentialgaindescription</helpKeyword>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
          <valueEval><![CDATA[ query("/ImbalancePotentialGain/MpiCriticalRankFlag[%True]") + (query("/PMUSpinBusyWaitOnLockTime/MpiCriticalRankFlagBandBase[%True]") / query("/TotalOpenMPThreadCountMpiCriticalRank")) + query("/PMUMpiCriticalRankOverheadWorkForkingWallTime") + query("/PMUMpiCriticalRankOverheadWorkSchedulingAndTaskingWallTime") + query("/PMUMpiCriticalRankOverheadReductionWallTime") + query("/PMUMpiCriticalRankOverheadAtomicsWallTime") ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/RegionTime/MpiCriticalRankFlag[%True]") - query("/PMUUserTimeInsideRegions/MpiCriticalRankFlagBandBase[%True]") / query("/OpenMPThreadCount")]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <description>%RegionPotentialGainDescription</description>
      <minEval>0</minEval>
      <valueType>time</valueType>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
      </displayAttributes>
      <issueEval><![CDATA[ query("/RegionPotentialGainPMUMpiCriticalRank") > (queryAll("/MpiCriticalRankProcessElapsedTime") * .10) ]]></issueEval>
      <confidenceEval><![CDATA[ query("/ClocktickSamples/MpiCriticalRankFlagBandBase[%True]") >= 10  * query("/OpenMPThreadCount") ]]></confidenceEval>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
      <issueText>%RegionPotentialGainForSummaryIssueText</issueText>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUExpanded">
      <queryInherit>/RegionPotentialGainPMU</queryInherit>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
          <displayAttributes>
            <aggregation>AggregateSumByChildren</aggregation>
          </displayAttributes>
          <expand>
            <vectorQuery id="RegionPotentialGainPMUExpandedVector">
              <queryRef>/ImbalancePotentialGain/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/PMUSpinBusyWaitOnLockWallTime/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/PMUOverheadWorkForkingWallTime/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/PMUOverheadWorkSchedulingAndTaskingWallTime/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/PMUOverheadReductionWallTime/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/PMUOverheadAtomicsWallTime/OpenMPThreadCountAggregationSum</queryRef>
            </vectorQuery>
          </expand>
        </xsl:when>
        <xsl:otherwise>
          <expand>
            <queryRef>/OpenMPThreadCountAggregationSum</queryRef>
          </expand>
        </xsl:otherwise>
      </xsl:choose>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUPercentsElapsedExpanded">
      <queryInherit>/RegionPotentialGainPMUPercentElapsed</queryInherit>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
          <displayAttributes>
            <aggregation>AggregateSumByChildren</aggregation>
          </displayAttributes>
          <expand>
            <vectorQuery id="RegionPotentialGainPMUPercentsElapcedExpandedVector">
              <queryRef>/ImbalancePotentialGainPercentsElapsed/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/PMUSpinBusyWaitOnLockWallTimePercentsElapsed/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/PMUOverheadWorkForkingWallTimePercentsElapsed/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/PMUOverheadWorkSchedulingAndTaskingWallTimePercentsElapsed/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/PMUOverheadReductionWallTimePercentsElapsed/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/PMUOverheadAtomicsWallTimePercentsElapsed/OpenMPThreadCountAggregationSum</queryRef>
            </vectorQuery>
          </expand>
        </xsl:when>
        <xsl:otherwise>
          <expand>
            <queryRef>/OpenMPThreadCountAggregationSum</queryRef>
          </expand>
        </xsl:otherwise>
      </xsl:choose>
    </derivedQuery>
    <vectorQuery id="RegionCPUUsageChartSorting">
      <queryRef>/RegionPotentialGainPMUShort</queryRef>
      <queryRef>/RegionPotentialGainCPUShort</queryRef>
      <queryRef>/RegionCpuUsageElapsedTime</queryRef>
    </vectorQuery>
    <derivedQuery id="RegionPotentialGainPMUShort" displayName="%RegionPotentialGainShort">
      <queryInherit>/RegionPotentialGainPMU</queryInherit>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUMpiCriticalRankShort" displayName="%RegionPotentialGainShort">
      <queryInherit>/RegionPotentialGainPMUMpiCriticalRank</queryInherit>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUPercentElapsed" displayName="%RegionPotentialGainPercent">
      <helpKeyword>configs.regionpotentialgainpercent_regionpotentialgainpercentdescription</helpKeyword>
      <queryInherit>/RegionPotentialGainPMU</queryInherit>
      <xsl:choose>
        <xsl:when test="(exsl:ctx('openmpProcessCount') = 1)">
          <valueEval><![CDATA[ query("/RegionPotentialGainPMU") / query("/TotalElapsedTimeNoPause")]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/RegionPotentialGainPMU") * 10000000000.0 / (query("/RegionProcessEndTsc") - query("/RegionProcessStartTsc") + 1)]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <valueType>ratio</valueType>
      <description>%RegionPotentialGainPercentDescription</description>
      <minEval>0</minEval>
    </derivedQuery>
    <derivedQuery id="MpiCriticalRankProcessElapsedTime">
      <valueEval><![CDATA[ query("/ProcessElapsedTime/MpiCriticalRankFlag[%True]") ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUMpiCriticalRankPercentElapsed" displayName="%RegionPotentialGainPercent">
      <helpKeyword>configs.regionpotentialgainpercent_regionpotentialgainpercentdescription</helpKeyword>
      <queryInherit>/RegionPotentialGainPMUMpiCriticalRank</queryInherit>
      <valueEval><![CDATA[ query("/RegionPotentialGainPMUMpiCriticalRank") / queryAll("/MpiCriticalRankProcessElapsedTime") ]]></valueEval>
      <valueType>ratio</valueType>
      <description>%RegionPotentialGainPercentDescription</description>
      <minEval>0</minEval>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUPercentElapsedShort" displayName="%RegionPotentialGainPercentShort">
      <queryInherit>/RegionPotentialGainPMUPercentElapsed</queryInherit>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUMpiCriticalRankPercentElapsedShort" displayName="%RegionPotentialGainPercentShort">
      <queryInherit>/RegionPotentialGainPMUMpiCriticalRankPercentElapsed</queryInherit>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUForSummary">
      <queryInherit>/RegionPotentialGainPMU</queryInherit>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
          <valueEval><![CDATA[ query("/ImbalancePotentialGainForSummary") + query("/PMUSpinBusyWaitOnLockWallTimeForSummary") + query("/PMUOverheadWorkForkingWallTimeForSummary") + query("/PMUOverheadWorkSchedulingAndTaskingWallTimeForSummary") + query("/PMUOverheadReductionWallTimeForSummary") + query("/PMUOverheadAtomicsWallTimeForSummary") ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/RegionTime") - query("/PMUUserTimeInsideRegions") / query("/TotalOpenMPThreadCount")]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <description>%RegionPotentialGainForSummaryDescription</description>
      <issueEval><![CDATA[ query("/RegionPotentialGainPMUForSummary") > (query("/TotalElapsedTimeNoPause") * .10) ]]></issueEval>
      <issueText>%RegionPotentialGainForSummaryIssueText</issueText>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUMpiCriticalRankForSummary">
      <queryInherit>/RegionPotentialGainPMUMpiCriticalRank</queryInherit>
      <description>%RegionPotentialGainForSummaryDescription</description>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
         <valueEval><![CDATA[ (( query("/ImbalanceTsc/MpiCriticalRankFlag[%True]") / 10000000000.0 + query("/PMUSpinBusyWaitOnLockTime/MpiCriticalRankFlagBandBase[%True]") ) / query("/TotalOpenMPThreadCountMpiCriticalRank") ) + query("/PMUMpiCriticalRankOverheadWorkForkingWallTimeForSummary") + query("/PMUMpiCriticalRankOverheadWorkSchedulingAndTaskingWallTimeForSummary") +  query("/PMUMpiCriticalRankOverheadReductionWallTimeForSummary") + query("/PMUMpiCriticalRankOverheadAtomicsWallTimeForSummary")   ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/RegionTime/MpiCriticalRankFlag[%True]") - query("/PMUUserTimeInsideRegions/MpiCriticalRankFlagBandBase[%True]") / query("/TotalOpenMPThreadCountMpiCriticalRank")]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <issueEval><![CDATA[ query("/RegionPotentialGainPMUMpiCriticalRankForSummary") > (queryAll("/MpiCriticalRankProcessElapsedTime") * .10) ]]></issueEval>
      <issueText>%RegionPotentialGainForSummaryIssueText</issueText>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUPercentElapsedAsStringForSummary" displayName="%RegionPotentialGainPercentShort">
      <queryInherit>/RegionPotentialGainPMUForSummary</queryInherit>
      <valueEval><![CDATA[ " (" + %#(query("/RegionPotentialGainPMUForSummary") / query("/TotalElapsedTimeNoPause")) + ")" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPU" displayName="%RegionPotentialGain">
      <helpKeyword>configs.regionpotentialgain_regionpotentialgaindescription</helpKeyword>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
          <valueEval><![CDATA[ query("/ImbalancePotentialGain") + query("/CPUSpinBusyWaitOnLockWallTime") + query("/CPUOverheadWorkForkingWallTime") + query("/CPUOverheadWorkSchedulingAndTaskingWallTime") + query("/CPUOverheadReductionWallTime") + query("/CPUOverheadAtomicsWallTime") ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/RegionTime") - query("/CPUUserTimeInsideRegions") / query("/OpenMPThreadCount")]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <description>%RegionPotentialGainDescription</description>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
      </displayAttributes>
      <issueEval><![CDATA[ query("/RegionPotentialGainCPU") > (query("/TotalElapsedTimeNoPause") * .10)]]></issueEval>
      <confidenceEval><![CDATA[ query("/CPUSampleCount") >= 10 * query("/OpenMPThreadCount")]]></confidenceEval>
      <confidenceText>%CPUMetricConfidenceText</confidenceText>
      <issueText>%RegionPotentialGainForSummaryIssueText</issueText>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUMpiCriticalRank" displayName="%RegionPotentialGain">
      <helpKeyword>configs.regionpotentialgain_regionpotentialgaindescription</helpKeyword>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
          <valueEval><![CDATA[ query("/ImbalancePotentialGain/MpiCriticalRankFlag[%True]") + (query("/CPUSpinBusyWaitOnLockTime/MpiCriticalRankFlagBandBase[%True]") / query("/TotalOpenMPThreadCountMpiCriticalRank")) + query("/CPUMpiCriticalRankOverheadWorkForkingWallTime") + query("/CPUMpiCriticalRankOverheadWorkSchedulingAndTaskingWallTime") + query("/CPUMpiCriticalRankOverheadReductionWallTime") + query("/CPUMpiCriticalRankOverheadAtomicsWallTime") ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/RegionTime/MpiCriticalRankFlag[%True]") - query("/CPUUserTimeInsideRegions/MpiCriticalRankFlagBandBase[%True]") / query("/OpenMPThreadCount")]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <description>%RegionPotentialGainDescription</description>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
      </displayAttributes>
      <issueEval><![CDATA[ query("/RegionPotentialGainCPUMpiCriticalRank") > (queryAll("/MpiCriticalRankProcessElapsedTime") * .10)]]></issueEval>
      <confidenceEval><![CDATA[ query("/CPUSampleCount/MpiCriticalRankFlagBandBase[%True]") >= 10 * query("/OpenMPThreadCount")]]></confidenceEval>
      <confidenceText>%CPUMetricConfidenceText</confidenceText>
      <issueText>%RegionPotentialGainForSummaryIssueText</issueText>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUExpanded">
      <queryInherit>/RegionPotentialGainCPU</queryInherit>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
          <displayAttributes>
            <aggregation>AggregateSumByChildren</aggregation>
          </displayAttributes>
          <expand>
            <vectorQuery id="RegionPotentialGainCPUExpandedVector">
              <queryRef>/ImbalancePotentialGain/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/CPUSpinBusyWaitOnLockWallTime/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/CPUOverheadWorkForkingWallTime/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/CPUOverheadWorkSchedulingAndTaskingWallTime/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/CPUOverheadReductionWallTime/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/CPUOverheadAtomicsWallTime/OpenMPThreadCountAggregationSum</queryRef>
            </vectorQuery>
          </expand>
        </xsl:when>
        <xsl:otherwise>
          <expand>
            <queryRef>/OpenMPThreadCountAggregationSum</queryRef>
          </expand>
        </xsl:otherwise>
      </xsl:choose>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUPercentsElapsedExpanded">
      <queryInherit>/RegionPotentialGainCPUPercentElapsed</queryInherit>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
          <displayAttributes>
            <aggregation>AggregateSumByChildren</aggregation>
          </displayAttributes>
          <expand>
            <vectorQuery id="RegionPotentialGainCPUPercentsElapsedExpandedVector">
              <queryRef>/ImbalancePotentialGainPercentsElapsed/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/CPUSpinBusyWaitOnLockWallTimePercentsElapsed/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/CPUOverheadWorkForkingWallTimePercentsElapsed/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/CPUOverheadWorkSchedulingAndTaskingWallTimePercentsElapsed/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/CPUOverheadReductionWallTimePercentsElapsed/OpenMPThreadCountAggregationSum</queryRef>
              <queryRef>/CPUOverheadAtomicsWallTimePercentsElapsed/OpenMPThreadCountAggregationSum</queryRef>
            </vectorQuery>
          </expand>
        </xsl:when>
        <xsl:otherwise>
          <expand>
            <queryRef>/OpenMPThreadCountAggregationSum</queryRef>
          </expand>
        </xsl:otherwise>
      </xsl:choose>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUShort" displayName="%RegionPotentialGainShort">
      <queryInherit>/RegionPotentialGainCPU</queryInherit>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUMpiCriticalRankShort" displayName="%RegionPotentialGainShort">
      <queryInherit>/RegionPotentialGainCPUMpiCriticalRank</queryInherit>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUPercentElapsed" displayName="%RegionPotentialGainPercent">
      <helpKeyword>configs.regionpotentialgainpercent_regionpotentialgainpercentdescription</helpKeyword>
      <queryInherit>/RegionPotentialGainCPU</queryInherit>
      <xsl:choose>
        <xsl:when test="(exsl:ctx('openmpProcessCount') = 1)">
          <valueEval><![CDATA[ query("/RegionPotentialGainCPU") / query("/TotalElapsedTimeNoPause")]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/RegionPotentialGainCPU") * 10000000000.0 / (query("/RegionProcessEndTsc") - query("/RegionProcessStartTsc") + 1)]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <valueType>ratio</valueType>
      <description>%RegionPotentialGainPercentDescription</description>
      <minEval>0</minEval>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUMpiCriticalRankPercentElapsed" displayName="%RegionPotentialGainPercent">
      <helpKeyword>configs.regionpotentialgainpercent_regionpotentialgainpercentdescription</helpKeyword>
      <queryInherit>/RegionPotentialGainCPUMpiCriticalRank</queryInherit>
        <valueEval><![CDATA[ query("/RegionPotentialGainCPUMpiCriticalRank") / queryAll("/MpiCriticalRankProcessElapsedTime") ]]></valueEval>
      <valueType>ratio</valueType>
      <description>%RegionPotentialGainPercentDescription</description>
      <minEval>0</minEval>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUPercentElapsedShort" displayName="%RegionPotentialGainPercentShort">
      <queryInherit>/RegionPotentialGainCPUPercentElapsed</queryInherit>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUMpiCriticalRankPercentElapsedShort" displayName="%RegionPotentialGainPercentShort">
      <queryInherit>/RegionPotentialGainCPUMpiCriticalRankPercentElapsed</queryInherit>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUForSummary">
      <queryInherit>/RegionPotentialGainCPU</queryInherit>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
          <valueEval><![CDATA[ query("/ImbalancePotentialGainForSummary") + query("/CPUSpinBusyWaitOnLockWallTimeForSummary") + query("/CPUOverheadWorkForkingWallTimeForSummary") + query("/CPUOverheadWorkSchedulingAndTaskingWallTimeForSummary") + query("/CPUOverheadReductionWallTimeForSummary") + query("/CPUOverheadAtomicsWallTimeForSummary") ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/RegionTime") - query("/CPUUserTimeInsideRegions") / query("/TotalOpenMPThreadCount")]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <description>%RegionPotentialGainForSummaryDescription</description>
      <issueEval><![CDATA[ query("/RegionPotentialGainCPUForSummary") > (query("/TotalElapsedTimeNoPause") * .10)]]></issueEval>
      <issueText>%RegionPotentialGainForSummaryIssueText</issueText>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUMpiCriticalRankForSummary">
      <queryInherit>/RegionPotentialGainCPUMpiCriticalRank</queryInherit>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
         <valueEval><![CDATA[ (( query("/ImbalanceTsc/MpiCriticalRankFlag[%True]") / 10000000000.0 + query("/CPUSpinBusyWaitOnLockTime/MpiCriticalRankFlagBandBase[%True]") ) / query("/TotalOpenMPThreadCountMpiCriticalRank") ) + query("/CPUMpiCriticalRankOverheadWorkForkingWallTimeForSummary") + query("/CPUMpiCriticalRankOverheadWorkSchedulingAndTaskingWallTimeForSummary") +  query("/CPUMpiCriticalRankOverheadReductionWallTimeForSummary") + query("/CPUMpiCriticalRankOverheadAtomicsWallTimeForSummary")   ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/RegionTime/MpiCriticalRankFlag[%True]") - query("/CPUUserTimeInsideRegions/MpiCriticalRankFlagBandBase[%True]") / query("/TotalOpenMPThreadCountMpiCriticalRank")]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <description>%RegionPotentialGainForSummaryDescription</description>
      <issueEval><![CDATA[ query("/RegionPotentialGainCPUMpiCriticalRankForSummary") > (queryAll("/MpiCriticalRankProcessElapsedTime") * .10)]]></issueEval>
      <issueText>%RegionPotentialGainForSummaryIssueText</issueText>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUAndPercentElapsedAsStringForSummary">
      <queryInherit>/RegionPotentialGainPMUForSummary</queryInherit>
      <description>%RegionPotentialGainPercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/RegionPotentialGainPMUForSummary") + " (" + %#(query("/RegionPotentialGainPMUForSummary") / query("/TotalElapsedTimeNoPause")) + ")" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUAndPercentElapsedAsStringForSummary">
      <queryInherit>/RegionPotentialGainCPUForSummary</queryInherit>
      <description>%RegionPotentialGainPercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/RegionPotentialGainCPUForSummary") + " (" + %#(query("/RegionPotentialGainCPUForSummary") / query("/TotalElapsedTimeNoPause")) + ")" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUMpiCriticalRankAndPercentElapsedAsStringForSummary">
      <queryInherit>/RegionPotentialGainCPUMpiCriticalRankForSummary</queryInherit>
      <description>%RegionPotentialGainPercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/RegionPotentialGainCPUMpiCriticalRankForSummary") + " (" + %#(query("/RegionPotentialGainCPUMpiCriticalRankForSummary") / queryAll("/MpiCriticalRankProcessElapsedTime")) + ")" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPMUMpiCriticalRankAndPercentElapsedAsStringForSummary">
      <queryInherit>/RegionPotentialGainPMUMpiCriticalRankForSummary</queryInherit>
      <description>%RegionPotentialGainPercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/RegionPotentialGainPMUMpiCriticalRankForSummary") + " (" + %#(query("/RegionPotentialGainPMUMpiCriticalRankForSummary") / queryAll("/MpiCriticalRankProcessElapsedTime")) + ")" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainCPUPercentElapsedAsStringForSummary" displayName="%RegionPotentialGainPercentShort">
      <queryInherit>/RegionPotentialGainCPUForSummary</queryInherit>
      <valueEval><![CDATA[ " (" + %#(query("/RegionPotentialGainCPUForSummary") / query("/TotalElapsedTimeNoPause")) + ")" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="IdealRegionTimeCPU" displayName="%IdealRegionTime">
      <helpKeyword>configs.idealregiontime_idealregiontimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RegionTime") - query("/RegionPotentialGainCPU")]]></valueEval>
      <description>%IdealRegionTimeDescription</description>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="IdealRegionTimeCPUMpiCriticalRankSummary" displayName="%IdealRegionTime">
      <helpKeyword>configs.idealregiontime_idealregiontimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RegionTime/MpiCriticalRankFlag[%True]") - query("/RegionPotentialGainCPUForSummary")]]></valueEval>
      <description>%IdealRegionTimeDescription</description>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="IdealRegionTimeCPUMpiCriticalRank" displayName="%IdealRegionTime">
      <helpKeyword>configs.idealregiontime_idealregiontimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RegionTime/MpiCriticalRankFlag[%True]") - query("/RegionPotentialGainCPUMpiCriticalRank")]]></valueEval>
      <description>%IdealRegionTimeDescription</description>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="IdealRegionTimeCPUSummary" displayName="%IdealRegionTime">
      <helpKeyword>configs.idealregiontime_idealregiontimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RegionTime") - query("/RegionPotentialGainCPUForSummary")]]></valueEval>
      <description>%IdealRegionTimeDescription</description>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="IdealRegionTimePMU" displayName="%IdealRegionTime">
      <helpKeyword>configs.idealregiontime_idealregiontimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RegionTime") - query("/RegionPotentialGainPMU")]]></valueEval>
      <description>%IdealRegionTimeDescription</description>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="IdealRegionTimePMUMpiCriticalRank" displayName="%IdealRegionTime">
      <helpKeyword>configs.idealregiontime_idealregiontimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RegionTime/MpiCriticalRankFlag[%True]") - query("/RegionPotentialGainPMUMpiCriticalRank")]]></valueEval>
      <description>%IdealRegionTimeDescription</description>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="IdealRegionTimePMUSummary" displayName="%IdealRegionTime">
      <helpKeyword>configs.idealregiontime_idealregiontimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RegionTime") - query("/RegionPotentialGainPMUForSummary")]]></valueEval>
      <description>%IdealRegionTimeDescription</description>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="IdealRegionTimePMUMpiCriticalRankSummary" displayName="%IdealRegionTime">
      <helpKeyword>configs.idealregiontime_idealregiontimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RegionTime/MpiCriticalRankFlag[%True]") - query("/RegionPotentialGainPMUMpiCriticalRankForSummary")]]></valueEval>
      <description>%IdealRegionTimeDescription</description>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="IdealRegionTimePMUAndPercentElapsedAsString">
      <queryInherit>/IdealRegionTimePMU</queryInherit>
      <description>%IdealRegionTimePercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/IdealRegionTimePMUSummary") + " (" + %#(query("/IdealRegionTimePMUSummary") / query("/TotalElapsedTimeNoPause")) + ")" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="IdealRegionTimePMUMpiCriticalRankAndPercentElapsedAsString">
      <queryInherit>/IdealRegionTimePMUMpiCriticalRank</queryInherit>
      <description>%IdealRegionTimePercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/IdealRegionTimePMUMpiCriticalRankSummary") + " (" + %#(query("/IdealRegionTimePMUMpiCriticalRankSummary") / queryAll("/MpiCriticalRankProcessElapsedTime")) + ")" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="IdealRegionTimeCPUAndPercentElapsedAsString">
      <queryInherit>/IdealRegionTimePMU</queryInherit>
      <description>%IdealRegionTimePercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/IdealRegionTimeCPUSummary") + " (" + %#(query("/IdealRegionTimeCPUSummary") / query("/TotalElapsedTimeNoPause")) + ")" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="IdealRegionTimeCPUMpiCriticalRankAndPercentElapsedAsString">
      <queryInherit>/IdealRegionTimeCPUMpiCriticalRank</queryInherit>
      <description>%IdealRegionTimePercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/IdealRegionTimeCPUMpiCriticalRankSummary") + " (" + %#(query("/IdealRegionTimeCPUMpiCriticalRankSummary") / queryAll("/MpiCriticalRankProcessElapsedTime")) + ")" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <timeQuery id="OMPSerialTime" displayName="%SerialTime">
       <boolean:useGlobalGrouper>true</boolean:useGlobalGrouper>
       <instanceDbTable>omp_serial_time_data</instanceDbTable>
       <instanceBandTable>dd_omp_serial_time</instanceBandTable>
    </timeQuery>
    <derivedQuery id="SerialTime" displayName="%SerialTime">
      <helpKeyword>configs.serialtime_serialtimedescription</helpKeyword>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('omp_serial_time_data')">
            <valueEval><![CDATA[ query("/OMPSerialTime")]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <xsl:choose>
            <xsl:when test="(exsl:ctx('openmpProcessCount') = 1)">
              <valueEval><![CDATA[ query("/GlobalElapsedTime") - query("/RegionTime")]]></valueEval>
            </xsl:when>
            <xsl:otherwise>
              <valueEval><![CDATA[ query("/ProcessElapsedTime") - query("/RegionTime")]]></valueEval>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
      <description>%SerialTimeDescription</description>
      <issueText>%SerialTimeIssueText</issueText>
      <issueEval><![CDATA[ ( query("/SerialTime") > (query("/TotalElapsedTimeNoPause") * .15)) ]]></issueEval>
      <valueType>time</valueType>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="SerialTimeMpiCriticalRank" displayName="%SerialTime">
      <helpKeyword>configs.serialtime_serialtimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/ProcessElapsedTime/MpiCriticalRankFlag[%True]") - query("/RegionTime/MpiCriticalRankFlag[%True]")]]></valueEval>
      <description>%SerialTimeDescription</description>
      <issueText>%SerialTimeIssueText</issueText>
      <issueEval><![CDATA[ ( query("/SerialTimeMpiCriticalRank") > (queryAll("/MpiCriticalRankProcessElapsedTime") * .15)) ]]></issueEval>
      <valueType>time</valueType>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="IdealSerialTime" displayName="%IdealSerialTime">
      <helpKeyword>configs.idealserialtime_idealregiontimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/ProcessSerialTime") - query("/SerialSpinBusyWaitOnMPISpinningTime")]]></valueEval>
      <description>%IdealRegionTimeDescription</description>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="SerialTimeShort" displayName="%SerialTimeShort">
      <queryInherit>/SerialTime</queryInherit>
    </derivedQuery>
    <derivedQuery id="SerialTimePercentElapsedShort" displayName="%SerialTimePercentShort">
      <helpKeyword>configs.serialtimepercentshort_serialtimedescription</helpKeyword>
      <xsl:choose>
        <xsl:when test="(exsl:ctx('openmpProcessCount') = 1)">
          <valueEval><![CDATA[ query("/SerialTime") / query("/TotalElapsedTimeNoPause")]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/SerialTime") / query("/ProcessElapsedTime")]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <issueText>%SerialTimeIssueText</issueText>
      <issueEval><![CDATA[ ( query("/SerialTime") > (query("/TotalElapsedTimeNoPause") * .15)) ]]></issueEval>
      <valueType>ratio</valueType>
      <minEval>0</minEval>
      <description>%SerialTimeDescription</description>
    </derivedQuery>
    <derivedQuery id="SerialTimeAndPercentElapsedAsString">
      <queryInherit>/SerialTime</queryInherit>
      <description>%SerialTimePercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/SerialTime") + " (" + %#(query("/SerialTime") / query("/TotalElapsedTimeNoPause")) + ")" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="SerialTimeMpiCriticalRankAndPercentElapsedAsString">
      <queryInherit>/SerialTimeMpiCriticalRank</queryInherit>
      <description>%SerialTimePercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/SerialTimeMpiCriticalRank") + " (" + %#(query("/SerialTimeMpiCriticalRank") / queryAll("/MpiCriticalRankProcessElapsedTime")) + ")" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="SerialTimeMPICritical" displayName="%SerialTime">
      <queryInherit>/SerialTime</queryInherit>
      <valueEval><![CDATA[ ( queryMin("/GenericProcess", "/SerialTimeShort", "/SpinBusyWaitOnMPISpinningTime") ) ]]></valueEval>
      <issueEval><![CDATA[ ( query("/SerialTimeMPICritical") > (query("/GlobalElapsedTime") * .15)) ]]></issueEval>
    </derivedQuery>
    <derivedQuery id="SerialTimeMPICriticalPercentElapsedAsString">
      <queryInherit>/SerialTimeMPICritical</queryInherit>
      <valueType>string</valueType>
      <valueEval><![CDATA[ t#query("/SerialTimeMPICritical") + " (" + %#(query("/SerialTimeMPICritical") / query("/GlobalElapsedTime")) + ")" ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="ProcessSerialTime" displayName="%SerialTime">
      <helpKeyword>configs.serialtime_serialtimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/ProcessElapsedTime") - query("/RegionTime")]]></valueEval>
      <description>%SerialTimeDescription</description>
      <issueText>%SerialTimeIssueText</issueText>
      <issueEval><![CDATA[ ( query("/SerialTime") > (query("/TotalElapsedTimeNoPause") * .15)) ]]></issueEval>
      <valueType>time</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="ProcessSerialTimeShort" displayName="%SerialTimeShort">
      <helpKeyword>configs.serialtimeshort_serialtimepercentelapseddescription</helpKeyword>
      <queryInherit>/ProcessSerialTime</queryInherit>
      <description>%SerialTimePercentElapsedDescription</description>
    </derivedQuery>
    <derivedQuery id="SerialTimeCPUAndPercentElapsedAsString">
      <queryInherit>/SerialTimeAndPercentElapsedAsString</queryInherit>
      <issueEval><![CDATA[ ( query("/SerialTime") > (query("/TotalElapsedTimeNoPause") * .15)) ]]></issueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="SerialTimePMUAndPercentElapsedAsString">
      <queryInherit>/SerialTimeAndPercentElapsedAsString</queryInherit>
      <issueEval><![CDATA[ ( query("/SerialTime") > (query("/TotalElapsedTimeNoPause") * .15)) ]]></issueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="OpenMPSectionHeader" displayName="%OpenMPSectionHeader">
      <helpKeyword>configs.openmpsectionheader_openmpsectionheaderdescription</helpKeyword>
      <valueEval><![CDATA[ query("/TotalElapsedTimeNoPause")]]></valueEval>
      <description>%OpenMPSectionHeaderDescription</description>
    </derivedQuery>
    <countQuery id="OpenMPThreadCountCumulative" displayName="%OpenMPThreadCountCumulative">
      <boolean:useGlobalGrouper>true</boolean:useGlobalGrouper>
      <instanceDbTable>openmp_thread_count_data::dd_region</instanceDbTable>
      <instanceBandTable>parallel_region_per_process_metrics</instanceBandTable>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </countQuery>
    <derivedQuery id="RegionPotentialGainExpanded">
      <xsl:choose>
        <xsl:when test="exsl:ctx('runsa:enable', 0) or (exsl:ctx('runsa:enable', 'na') = 'na' and exsl:ctx('runss:enable', 'na') = 'na' and not(exsl:IsTableExist('cpu_data')) and exsl:IsTableExist('pmu_data'))">
          <queryInherit>/RegionPotentialGainPMUExpanded</queryInherit>
        </xsl:when>
        <xsl:otherwise>
          <queryInherit>/RegionPotentialGainCPUExpanded</queryInherit>
        </xsl:otherwise>
      </xsl:choose>
      <displayAttributes>
        <boolean:expand>true</boolean:expand>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGain">
      <xsl:choose>
        <xsl:when test="exsl:ctx('runsa:enable', 0) or (exsl:ctx('runsa:enable', 'na') = 'na' and exsl:ctx('runss:enable', 'na') = 'na' and not(exsl:IsTableExist('cpu_data')) and exsl:IsTableExist('pmu_data'))">
          <queryInherit>/RegionPotentialGainPMU</queryInherit>
        </xsl:when>
        <xsl:otherwise>
          <queryInherit>/RegionPotentialGainCPU</queryInherit>
        </xsl:otherwise>
      </xsl:choose>
      <expand>
        <queryRef>/OpenMPThreadCountAggregationSum</queryRef>
      </expand>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainMPICritical">
      <queryInherit>/RegionPotentialGainPMU</queryInherit>
      <valueEval><![CDATA[ ( queryMin("/GenericProcess", "/RegionPotentialGain", "/SpinBusyWaitOnMPISpinningTime") ) ]]></valueEval>
      <issueEval><![CDATA[ query("/RegionPotentialGainMPICritical") > (query("/GlobalElapsedTime") * .10) ]]></issueEval>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainMPICriticalPercentElapsedAsString">
      <queryInherit>/RegionPotentialGainMPICritical</queryInherit>
      <valueType>string</valueType>
      <valueEval><![CDATA[ t#query("/RegionPotentialGainMPICritical") + " (" + %#(query("/RegionPotentialGainMPICritical") / query("/GlobalElapsedTime")) + ")" ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="RegionPotentialGainPercentsElapsedExpanded">
      <xsl:choose>
        <xsl:when test="exsl:ctx('runsa:enable', 0) or (exsl:ctx('runsa:enable', 'na') = 'na' and exsl:ctx('runss:enable', 'na') = 'na' and not(exsl:IsTableExist('cpu_data')) and exsl:IsTableExist('pmu_data'))">
          <queryInherit>/RegionPotentialGainPMUPercentsElapsedExpanded</queryInherit>
        </xsl:when>
        <xsl:otherwise>
          <queryInherit>/RegionPotentialGainCPUPercentsElapsedExpanded</queryInherit>
        </xsl:otherwise>
      </xsl:choose>
    </derivedQuery>
    <derivedQuery id="ParallelSpinBusyWaitOnMPISpinningTime">
      <queryInherit>/SpinBusyWaitOnMPISpinningTime</queryInherit>
      <valueEval><![CDATA[ query("/SpinBusyWaitOnMPISpinningTime/RegionType[%FastRegion]") + query("/SpinBusyWaitOnMPISpinningTime/RegionType[%GoodRegion]") + query("/SpinBusyWaitOnMPISpinningTime/RegionType[%SlowRegion]") ]]></valueEval>
      <valueType>time</valueType>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="SerialSpinBusyWaitOnMPISpinningTime">
      <queryInherit>/SpinBusyWaitOnMPISpinningTime</queryInherit>
      <valueEval><![CDATA[ query("/SpinBusyWaitOnMPISpinningTime") - query("/ParallelSpinBusyWaitOnMPISpinningTime") ]]></valueEval>
      <valueType>time</valueType>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="FullProcessElapsedTime" displayName="%ProcessElapsedTime">
      <xsl:choose>
        <xsl:when test="(exsl:ctx('openmpProcessCount') = 1)">
          <valueEval><![CDATA[ query("/TotalElapsedTimeNoPause") ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ (query("/RegionProcessEndTsc") - query("/RegionProcessStartTsc") + 1) /  10000000000.0 ]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <valueType>double</valueType>
      <minEval>0</minEval>
      <displayAttributes>
        <boolean:canBeDoi>false</boolean:canBeDoi>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id ="ParallelExecutionWallTimePMUAndPercentElapsedAsString" displayName ="%ParallelExecutionWallTime">
      <helpKeyword>configs.parallelexecutionwalltime_parallelexecutionwalltimepercentelapseddescription</helpKeyword>
      <description>%ParallelExecutionWallTimePercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/RegionTime") + " (" + %#(query("/RegionTime") / query("/TotalElapsedTimeNoPause")) + ")" ]]></valueEval>
      <valueType>string</valueType>
      <displayAttributes>
        <boolean:expand>true</boolean:expand>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
      <expand>
        <vectorQuery id = "ParallelExecutionWallTimeExpanded">
          <queryRef>/IdealRegionTimePMUAndPercentElapsedAsString</queryRef>
          <queryRef>/RegionPotentialGainPMUAndPercentElapsedAsStringForSummary</queryRef>
        </vectorQuery>
      </expand>
    </derivedQuery>
    <derivedQuery id ="ParallelExecutionWallTimePMUMpiCriticalRankAndPercentElapsedAsString" displayName ="%ParallelExecutionWallTime">
      <helpKeyword>configs.parallelexecutionwalltime_parallelexecutionwalltimepercentelapseddescription</helpKeyword>
      <description>%ParallelExecutionWallTimePercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/RegionTime/MpiCriticalRankFlag[%True]") + " (" + %#(query("/RegionTime/MpiCriticalRankFlag[%True]") / queryAll("/MpiCriticalRankProcessElapsedTime")) + ")" ]]></valueEval>
      <valueType>string</valueType>
      <displayAttributes>
        <boolean:expand>true</boolean:expand>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
      <expand>
        <vectorQuery id = "ParallelExecutionWallTimeExpanded">
          <queryRef>/IdealRegionTimePMUMpiCriticalRankAndPercentElapsedAsString</queryRef>
          <queryRef>/RegionPotentialGainPMUAndPercentElapsedAsStringForSummary</queryRef>
        </vectorQuery>
      </expand>
    </derivedQuery>
    <derivedQuery id ="ParallelExecutionWallTimeCPUAndPercentElapsedAsString" displayName ="%ParallelExecutionWallTime">
      <helpKeyword>configs.parallelexecutionwalltime_parallelexecutionwalltimepercentelapseddescription</helpKeyword>
      <description>%ParallelExecutionWallTimePercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/RegionTime") + " (" + %#(query("/RegionTime") / query("/TotalElapsedTimeNoPause")) + ")" ]]></valueEval>
      <valueType>string</valueType>
      <displayAttributes>
        <boolean:expand>true</boolean:expand>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
      <expand>
        <vectorQuery id = "ParallelExecutionWallTimeExpanded">
          <queryRef>/IdealRegionTimeCPUAndPercentElapsedAsString</queryRef>
          <queryRef>/RegionPotentialGainCPUAndPercentElapsedAsStringForSummary</queryRef>
        </vectorQuery>
      </expand>
    </derivedQuery>
    <derivedQuery id ="ParallelExecutionWallTimeCPUMpiCriticalRankAndPercentElapsedAsString" displayName ="%ParallelExecutionWallTime">
      <helpKeyword>configs.parallelexecutionwalltime_parallelexecutionwalltimepercentelapseddescription</helpKeyword>
      <description>%ParallelExecutionWallTimePercentElapsedDescription</description>
      <valueEval><![CDATA[ t#query("/RegionTime/MpiCriticalRankFlag[%True]") + " (" + %#(query("/RegionTime/MpiCriticalRankFlag[%True]") / queryAll("/MpiCriticalRankProcessElapsedTime")) + ")" ]]></valueEval>
      <valueType>string</valueType>
      <displayAttributes>
        <boolean:expand>true</boolean:expand>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
      <expand>
        <vectorQuery id = "ParallelExecutionWallTimeExpanded">
          <queryRef>/IdealRegionTimeCPUAndPercentElapsedAsString</queryRef>
          <queryRef>/RegionPotentialGainCPUAndPercentElapsedAsStringForSummary</queryRef>
        </vectorQuery>
      </expand>
    </derivedQuery>
    <timeQuery id="OpenMPElapsedTime">
      <xsl:choose>
        <xsl:when test="(exsl:ctx('openmpProcessCount') = 1)">
          <queryInherit>/ProcessElapsedTime</queryInherit>
          <issueEval>$shortCollectionMux</issueEval>
          <issueText>%ShortCollectionMuxRecommendationIssue</issueText>
        </xsl:when>
        <xsl:otherwise>
          <queryInherit>/GlobalElapsedTime</queryInherit>
        </xsl:otherwise>
      </xsl:choose>
    </timeQuery>
    <derivedQuery id="MPIImbalance" displayName ="%MPIImbalance">
      <helpKeyword>configs.mpiimbalance_mpiimbalancedescription</helpKeyword>
      <description>%MPIImbalanceDescription</description>
      <valueType>time</valueType>
      <valueEval><![CDATA[ query("/SpinBusyWaitOnMPISpinningTime") / $mpiRankCount ]]></valueEval>
      <issues>
        <issue>
          <issueEval><![CDATA[ ( (query("/MPIImbalance") > (query("/GlobalElapsedTime") * .15)) && (query("/SpinBusyWaitOnMPISpinningTimeMPICritical") <= (query("/GlobalElapsedTime") * .03)) ) ]]></issueEval>
          <issueText>%MPIImbalanceLowBusyWaitIssueText</issueText>
        </issue>
        <issue>
            <issueEval><![CDATA[ ( (query("/MPIImbalance") > (query("/GlobalElapsedTime") * .15)) && (query("/SpinBusyWaitOnMPISpinningTimeMPICritical") > (query("/GlobalElapsedTime") * .03)) ) ]]></issueEval>
            <issueText>%MPIImbalanceHighBusyWaitIssueText</issueText>
        </issue>
      </issues>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="MPIImbalanceSummary" displayName ="%MPIImbalance">
      <helpKeyword>configs.mpiimbalance_mpiimbalancedescription</helpKeyword>
      <description>%MPIImbalanceDescription</description>
      <valueType>time</valueType>
      <valueEval><![CDATA[ query("/SpinBusyWaitOnMPISpinningTimeSummary") / $mpiRankCount ]]></valueEval>
      <issues>
        <issue>
          <issueEval><![CDATA[ ( (query("/MPIImbalanceSummary") > (query("/GlobalElapsedTime") * .15)) && (query("/SpinBusyWaitOnMPISpinningTimeMPICriticalSummary") <= (query("/GlobalElapsedTime") * .03)) ) ]]></issueEval>
          <issueText>%MPIImbalanceLowBusyWaitIssueText</issueText>
        </issue>
        <issue>
            <issueEval><![CDATA[ ( (query("/MPIImbalanceSummary") > (query("/GlobalElapsedTime") * .15)) && (query("/SpinBusyWaitOnMPISpinningTimeMPICriticalSummary") > (query("/GlobalElapsedTime") * .03)) ) ]]></issueEval>
            <issueText>%MPIImbalanceHighBusyWaitIssueText</issueText>
        </issue>
      </issues>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="MPIImbalancePercentElapsedAsString">
      <queryInherit>/MPIImbalanceSummary</queryInherit>
      <valueType>string</valueType>
      <valueEval><![CDATA[ t#query("/MPIImbalanceSummary") + " (" + %#(query("/MPIImbalanceSummary") / query("/GlobalElapsedTime")) + ")" ]]></valueEval>
    </derivedQuery>
    <derivedQuery displayName="%CriticalMPIRank" id="CriticalMPIRank">
      <description>%CriticalMPIRankDescription</description>
      <valueEval>""</valueEval>
    </derivedQuery>
  </queryLibrary>
</bag>
