<?xml version="1.0" encoding="UTF-8"?>
<!--

 Copyright Â© 2009-2020 Intel Corporation. All rights reserved.

 The information contained herein is the exclusive property of
 Intel Corporation and may not be disclosed, examined, or reproduced in
 whole or in part without explicit written authorization from the Company.

-->
<bag
  xmlns:boolean="http://www.w3.org/2001/XMLSchema#boolean"
  xmlns:int="http://www.w3.org/2001/XMLSchema#int"
  xmlns:double="http://www..org/2001/XMLSchema#double"
  >
  <queryLibrary xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:str="http://exslt.org/strings" str:keep_str_namespace=""
    xmlns:exsl="http://exslt.org/common" exsl:keep_exsl_namespace="">
    <xsl:variable name="GPUComputingTasksCollected" select="exsl:IsNonEmptyTableExist('gpu_compute_task_data')"/>
    <xsl:variable name="GPUGTPinDataCollected" select="exsl:IsNonEmptyTableExist('gpu_gtpin_data')"/>
    <xsl:variable name="GPUOCLTasksCollected" select="string($collectGpuOpenCl) != 'false'"/>
    <xsl:variable name="FPGADataCollected" select="exsl:IsNonEmptyTableExist('accelerator_compute_task_data')"/>
    <xsl:variable name="isRunssMode" select="exsl:ctx('runss:enable', 0) or (exsl:ctx('runsa:enable', 'na') = 'na' and exsl:ctx('runss:enable', 'na') = 'na' and exsl:IsTableExist('cpu_data'))"/>
    <vectorQuery id="AsmPaneRowBy">
      <queryRef>/InternalAddressFlat</queryRef>
      <queryRef>/BasicBlockInternal/InternalAddress</queryRef>
      <queryRef>/FunctionRangeInternal/BasicBlockInternal/InternalAddress</queryRef>
    </vectorQuery>
    <vectorQuery id="GridInfoQueriesTail">
      <queryRef>/FunctionModule</queryRef>
      <queryRef>/SourceFunctionFull</queryRef>
      <queryRef>/SourceFunctionSourceFile</queryRef>
      <queryRef>/ModulePath</queryRef>
      <xsl:if test="not(exsl:is_compare_mode())">
        <queryRef>/FunctionRangeSize</queryRef>
        <queryRef>/FunctionStartAddress</queryRef>
        <queryRef>/GenericProcessID</queryRef>
        <queryRef>/GenericThreadID</queryRef>
      </xsl:if>
    </vectorQuery>
    <vectorQuery id="CommonDataQueries">
      <queryRef>/FrameTime</queryRef>
      <queryRef>/FrameCount</queryRef>
      <queryRef>/CounterCount/CounterType</queryRef>
      <queryRef>/GlobalCounterCount/GlobalCounterType</queryRef>
      <queryRef>/TaskTime</queryRef>
      <queryRef>/TaskCount</queryRef>
      <queryRef>/InterruptCount</queryRef>
    </vectorQuery>
    <vectorQuery id="RegionDataQueries">
      <xsl:if test="(exsl:ctx('openmpProcessCount') > 0)">
        <queryRef>/RegionPotentialGainExpanded</queryRef>
        <queryRef>/SpinBusyWaitOnMPISpinningTime</queryRef>
        <queryRef>/ProcessElapsedTime</queryRef>
        <queryRef>/OpenMPThreadCount</queryRef>
        <queryRef>/RegionInstanceCount</queryRef>
        <queryRef>/BarrierChunk</queryRef>
        <queryRef>/BarrierScheduleType</queryRef>
        <queryRef>/DerivedBarrierIterationsCountAvg</queryRef>
        <queryRef>/DerivedBarrierIterationsCountMax</queryRef>
        <queryRef>/DerivedBarrierIterationsCountMin</queryRef>
      </xsl:if>
    </vectorQuery>
    <derivedQuery id="SerialTimeWithExpansion" displayName="%SerialTime">
      <valueEval><![CDATA[ query("/SerialTime") ]]></valueEval>
      <valueType>time</valueType>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
      <expand>
        <vectorQuery id="SerialRegionDataQueries">
          <xsl:if test="(exsl:ctx('openmpProcessCount') > 0)">
            <queryRef>/IdealSerialTime</queryRef>
            <queryRef>/SerialSpinBusyWaitOnMPISpinningTime</queryRef>
          </xsl:if>
        </vectorQuery>
      </expand>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="SerialCPUTimeWithExpansion" displayName="%SerialCPUTime">
      <helpKeyword>configs.serialcputimewithexpansion_serialcputimedescription</helpKeyword>
      <description>%SerialCPUTimeDescription</description>
      <valueEval><![CDATA[ query("/SerialCPUTime") ]]></valueEval>
      <valueType>time</valueType>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
      <expand>
        <vectorQuery id="SerialCPURegionDataQueries">
          <xsl:if test="(exsl:ctx('openmpProcessCount') > 0)">
            <queryRef>/SerialSpinBusyWaitOnMPISpinningTime</queryRef>
            <queryRef>/SerialCPUOtherTime</queryRef>
          </xsl:if>
        </vectorQuery>
      </expand>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <vectorQuery id="GPUDataTransferQueries">
      <derivedQuery id="ComputingDataTransferredSize" displayName="%GPUComputeMemoryTransferSizeTotal">
        <queryInherit>/GPUComputeMemoryTransferSizeDerived</queryInherit>
        <displayAttributes>
          <boolean:expand>true</boolean:expand>
          <boolean:allowCollapse>true</boolean:allowCollapse>
        </displayAttributes>
        <expand>
          <vectorQuery id="ComputingDataTransferredSizeGroup">
            <queryRef>/GPUComputeMemoryTransferSizeInDerived</queryRef>
            <queryRef>/GPUComputeMemoryTransferSizeOutDerived</queryRef>
          </vectorQuery>
        </expand>
      </derivedQuery>
    </vectorQuery>
    <vectorQuery id="GPUInfoQueries">
      <derivedQuery id="ComputingSpaceSizeSlots" displayName="%ComputingSpaceSize">
        <queryInherit>/GPUComputeGlobalDimDerived</queryInherit>
        <displayAttributes>
          <boolean:expand>true</boolean:expand>
          <boolean:allowCollapse>false</boolean:allowCollapse>
        </displayAttributes>
        <expand>
          <vectorQuery id="ComputingSpaceSizeSlotsGroup">
            <queryRef>/GPUComputeGlobalDimDerived</queryRef>
            <queryRef>/GPUComputeLocalDimDerived</queryRef>
            <queryRef>/FPGAComputeGlobalDimDerived</queryRef>
            <queryRef>/FPGAComputeLocalDimDerived</queryRef>
          </vectorQuery>
        </expand>
      </derivedQuery>
    </vectorQuery>
    <vectorQuery id="CPUGPUInteractionDataQueries">
      <xsl:if test="$GPUComputingTasksCollected or $FPGADataCollected">
        <xsl:choose>
          <xsl:when test="exsl:is_experimental('gpu-data-transfer')">
            <queryRef>/GPUComputeTaskTimeDT/GPUDataTransferType</queryRef>
          </xsl:when>
          <xsl:otherwise>
            <derivedQuery id="GPUComputingTaskTimeSlots" displayName="%ComputingTask">
            <queryInherit>/GPUComputeTaskDuration</queryInherit>
            <displayAttributes>
              <boolean:expand>true</boolean:expand>
              <boolean:allowCollapse>false</boolean:allowCollapse>
            </displayAttributes>
            <expand>
              <vectorQuery id="GPUComputingTaskSlotsGroup">
                <queryRef>/GPUComputeTaskTimeDerived</queryRef>
                <queryRef>/GPUComputeTaskDuration</queryRef>
                <queryRef>/GPUComputeTaskCountDerived</queryRef>
                <queryRef>/GPUComputeSimdWidthDerived</queryRef>
                <xsl:if test="exsl:ctx('targetOS')!='MacOSX'">
                  <queryRef>/GPUComputeSVMUsageTypeDerived</queryRef>
                </xsl:if>
                <queryRef>/FPGAComputeTaskTimeDerived</queryRef>
                <queryRef>/FPGAComputeTaskDuration</queryRef>
                <queryRef>/FPGAComputeTaskCountDerived</queryRef>
              </vectorQuery>
            </expand>
          </derivedQuery>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <xsl:if test="$GPUOCLTasksCollected or $FPGADataCollected">
        <xsl:choose>
          <xsl:when test="exsl:is_experimental('gpu-data-transfer')">
            <vectorQueryInsert>/GPUDataTransferQueries</vectorQueryInsert>
          </xsl:when>
          <xsl:otherwise>
            <derivedQuery id="ComputingMemoryTransferSlots" displayName="%DataTransferred">
              <queryInherit>/GPUComputeMemoryTransferSizeDerived</queryInherit>
              <displayAttributes>
                <boolean:expand>true</boolean:expand>
                <boolean:allowCollapse>false</boolean:allowCollapse>
              </displayAttributes>
              <expand>
                <vectorQuery id="ComputingMemoryTransferSlotsGroup">
                  <queryRef>/GPUComputeMemoryTransferSizeDerived</queryRef>
                  <queryRef>/GPUComputeMemoryTransferBandwidth</queryRef>
                  <queryRef>/FPGAComputeMemoryTransferSizeDerived</queryRef>
                  <queryRef>/FPGAComputeMemoryTransferBandwidth</queryRef>
                </vectorQuery>
              </expand>
            </derivedQuery>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <xsl:if test="not(exsl:ctx('gpuHwCollection', 'novalue') = false)">
      <derivedQuery id="EUArraySlots" displayName="%GPUEUArray">
        <queryInherit>/GPUEUActive</queryInherit>
        <description>%GPUEUArrayMetricsDescription</description>
        <displayAttributes>
          <boolean:expand>true</boolean:expand>
          <boolean:allowCollapse>false</boolean:allowCollapse>
        </displayAttributes>
        <expand>
          <vectorQuery id="EUArraySlotsGroup">
            <derivedQuery id="ActiveEUArraySlotsGroup" displayName="%GPUEUActiveShort">
              <queryInherit>/GPUEUActive</queryInherit>
            </derivedQuery>
            <derivedQuery id="StalledEUArraySlotsGroup" displayName="%GPUEUStalledShort">
              <queryInherit>/GPUEUStalled</queryInherit>
            </derivedQuery>
            <derivedQuery id="IdleEUArraySlotsGroup" displayName="%GPUEUIdleShort">
              <queryInherit>/GPUEUIdle</queryInherit>
            </derivedQuery>
          </vectorQuery>
        </expand>
      </derivedQuery>
      <queryRef>/GPUEuThreadOccupancy</queryRef>
      <queryRef>/GPUCSThreadIssuedCount</queryRef>
      </xsl:if>
    </vectorQuery>
    <vectorQuery id="GPUDataQueries">
      <vectorQueryInsert>/CPUGPUInteractionDataQueries</vectorQueryInsert>
      <derivedQuery id="EUInstructions" displayName="%GPUEUInstructionsShort">
        <queryInherit>/GPUEuAvgIpcRate</queryInherit>
        <description>%GPUEuInstructionMetricsDescription</description>
        <displayAttributes>
          <boolean:expand>true</boolean:expand>
          <boolean:allowCollapse>false</boolean:allowCollapse>
        </displayAttributes>
        <expand>
          <vectorQuery id="EUInstructionsSlotsGroup">
            <derivedQuery id="EUAvgIpcRateSlotsGroup" displayName="%GPUEuAvgIpcRateShort">
              <queryInherit>/GPUEuAvgIpcRate</queryInherit>
            </derivedQuery>
            <derivedQuery id="EUFpuBothActiveSlotsGroup" displayName="%GPUEuFpuBothActiveShort">
              <queryInherit>/GPUEuFpuBothActive</queryInherit>
            </derivedQuery>
            <derivedQuery id="EUSendActiveSlotsGroup" displayName="%GPUEuSendActiveShort">
              <queryInherit>/GPUEuSendActive</queryInherit>
            </derivedQuery>
          </vectorQuery>
        </expand>
      </derivedQuery>
      <queryRef>/GPUL3ShaderBandwidth</queryRef>
      <queryRef>/GPUL3SamplerBandwidth</queryRef>
      <queryRef>/GTIL3TotalBandwidth</queryRef>
      <derivedQuery id="GPUMemoryAccessCoalescenceRatio" displayName="%GPUMemoryAccessCoalescenceRatio">
        <queryInherit>/GPUUntypedReadCoalRatio</queryInherit>
        <description>%GPUMemoryAccessCoalescenceRatioDescription</description>
        <displayAttributes>
          <boolean:expand>true</boolean:expand>
          <boolean:allowCollapse>false</boolean:allowCollapse>
        </displayAttributes>
        <expand>
          <vectorQuery id="GPUMemoryAccessCoalescenceRatioGroup">
            <derivedQuery id="UntypedReadGPUMemoryAccessCoalescenceRatioGroup" displayName="%GPUStringUntypedReads">
              <queryInherit>/GPUUntypedReadCoalRatio</queryInherit>
            </derivedQuery>
            <derivedQuery id="UntypedWriteGPUMemoryAccessCoalescenceRatioGroup" displayName="%GPUStringUntypedWrites">
              <queryInherit>/GPUUntypedWriteCoalRatio</queryInherit>
            </derivedQuery>
            <derivedQuery id="TypedReadGPUMemoryAccessCoalescenceRatioGroup" displayName="%GPUStringTypedReads">
              <queryInherit>/GPUTypedReadCoalRatio</queryInherit>
            </derivedQuery>
            <derivedQuery id="TypedWriteGPUMemoryAccessCoalescenceRatioGroup" displayName="%GPUStringTypedWrites">
              <queryInherit>/GPUTypedWriteCoalRatio</queryInherit>
            </derivedQuery>
          </vectorQuery>
        </expand>
      </derivedQuery>
      <derivedQuery id="GPUUntypedMemoryBandwidth" displayName="%GPUUntypedMemoryBandwidth">
        <queryInherit>/GPUUntypedMemoryReadBandwidth</queryInherit>
        <description>%GPUUntypedMemoryAccessBandwidthDescription</description>
        <displayAttributes>
          <boolean:expand>true</boolean:expand>
          <boolean:allowCollapse>false</boolean:allowCollapse>
        </displayAttributes>
        <expand>
          <vectorQuery id="GPUUntypedMemoryBandwidthSlotsGroup">
            <derivedQuery id="ReadGPUUntypedMemoryBandwidthSlotsGroup" displayName="%GPUMemoryReadShort">
              <queryInherit>/GPUUntypedMemoryReadBandwidth</queryInherit>
            </derivedQuery>
            <derivedQuery id="WriteGPUUntypedMemoryBandwidthSlotsGroup" displayName="%GPUMemoryWriteShort">
              <queryInherit>/GPUUntypedMemoryWriteBandwidth</queryInherit>
            </derivedQuery>
          </vectorQuery>
        </expand>
      </derivedQuery>
      <derivedQuery id="GPUSharedLocalMemoryBandwidth" displayName="%GPUSharedLocalMemoryBandwidth">
        <queryInherit>/GPUSharedLocalMemoryReadBandwidth</queryInherit>
        <description>%GPUSLMMemoryAccessBandwidthDescription</description>
        <displayAttributes>
          <boolean:expand>true</boolean:expand>
          <boolean:allowCollapse>false</boolean:allowCollapse>
        </displayAttributes>
        <expand>
          <vectorQuery id="GPUSharedLocalMemoryBandwidthSlotsGroup">
            <derivedQuery id="ReadGPUSharedLocalMemoryBandwidthSlotsGroup" displayName="%GPUMemoryReadShort">
              <queryInherit>/GPUSharedLocalMemoryReadBandwidth</queryInherit>
            </derivedQuery>
            <derivedQuery id="WriteGPUSharedLocalMemoryBandwidthSlotsGroup" displayName="%GPUMemoryWriteShort">
              <queryInherit>/GPUSharedLocalMemoryWriteBandwidth</queryInherit>
            </derivedQuery>
          </vectorQuery>
        </expand>
      </derivedQuery>
      <derivedQuery id="GPUTypedMemoryBandwidth" displayName="%GPUTypedMemoryBandwidth">
        <queryInherit>/GPUTypedMemoryReadBandwidth</queryInherit>
        <description>%GPUTypedMemoryAccessBandwidthDescription</description>
        <displayAttributes>
          <boolean:expand>true</boolean:expand>
          <boolean:allowCollapse>false</boolean:allowCollapse>
        </displayAttributes>
        <expand>
          <vectorQuery id="GPUTypedMemoryBandwidthSlotsGroup">
            <derivedQuery id="ReadGPUTypedMemoryBandwidthSlotsGroup" displayName="%GPUMemoryReadShort">
              <queryInherit>/GPUTypedMemoryReadBandwidth</queryInherit>
            </derivedQuery>
            <derivedQuery id="WriteGPUTypedMemoryBandwidthSlotsGroup" displayName="%GPUMemoryWriteShort">
              <queryInherit>/GPUTypedMemoryWriteBandwidth</queryInherit>
            </derivedQuery>
          </vectorQuery>
        </expand>
      </derivedQuery>
      <derivedQuery id="GPUMemoryBandwidth" displayName="%GPUMemoryBandwidth">
        <queryInherit>/GPUMemoryReadBandwidth</queryInherit>
        <displayAttributes>
          <boolean:expand>true</boolean:expand>
          <boolean:allowCollapse>false</boolean:allowCollapse>
        </displayAttributes>
        <expand>
          <vectorQuery id="GPUMemoryBandwidthSlotsGroup">
            <derivedQuery id="ReadGPUMemoryBandwidthSlotsGroup" displayName="%GPUMemoryReadShort">
              <queryInherit>/GPUMemoryReadBandwidth</queryInherit>
            </derivedQuery>
            <derivedQuery id="WriteGPUMemoryBandwidthSlotsGroup" displayName="%GPUMemoryWriteShort">
              <queryInherit>/GPUMemoryWriteBandwidth</queryInherit>
            </derivedQuery>
          </vectorQuery>
        </expand>
      </derivedQuery>
      <derivedQuery id="Sampler" displayName="%GPUSampler">
        <queryInherit>/GPUSamplerBusy</queryInherit>
        <displayAttributes>
          <boolean:expand>true</boolean:expand>
          <boolean:allowCollapse>false</boolean:allowCollapse>
        </displayAttributes>
        <expand>
          <vectorQuery id="SamplerSlotsGroup">
            <derivedQuery id="BusySamplerSlotsGroup" displayName="%GPUSamplerBusyShort">
              <queryInherit>/GPUSamplerBusy</queryInherit>
            </derivedQuery>
            <derivedQuery id="BottleneckSamplerSlotsGroup" displayName="%GPUSamplerBottleneckShort">
              <queryInherit>/GPUSamplerBottleneck</queryInherit>
            </derivedQuery>
          </vectorQuery>
        </expand>
      </derivedQuery>
      <derivedQuery id="eDRAMCounters" displayName="%eDRAM">
        <queryInherit>/eDRAMTotalBandwidth</queryInherit>
        <displayAttributes>
          <boolean:expand>true</boolean:expand>
        </displayAttributes>
        <expand>
            <vectorQuery>
                <queryRef>/eDRAMReadBandwidth</queryRef>
                <queryRef>/eDRAMWriteBandwidth</queryRef>
            </vectorQuery>
        </expand>
      </derivedQuery>
      <queryRef>/GPUL3MissRate</queryRef>
      <queryRef>/GPUShaderBarriers</queryRef>
      <queryRef>/GPUShaderAtomics</queryRef>
      <queryRef>/GPUDXTime/GPUNode</queryRef>
    </vectorQuery>
    <vectorQuery id="MemoryObjectsRowBySubset">
      <queryRef>/Function/PMUMemoryObject/PMUMemoryObjectStack</queryRef>
      <queryRef>/Function/PMUMemoryObjectAllocationSource/PMUMemoryObjectStack</queryRef>
      <queryRef>/Function/PMUMemoryObject/PMUMemoryObjectOffset/PMUMemoryObjectStack</queryRef>
      <queryRef>/PMUMemoryObject/Function/PMUMemoryObjectStack</queryRef>
      <queryRef>/PMUMemoryObjectAllocationSource/Function/PMUMemoryObjectStack</queryRef>
      <queryRef>/PMUMemoryObject/PMUMemoryObjectOffset/Function/PMUMemoryObjectStack</queryRef>
      <queryRef>/PMUMemoryObject/Function/ParentCallStack</queryRef>
      <queryRef>/PMUMemoryObject/PMUMemoryObjectOffset/PMUDataAddress</queryRef>
      <xsl:if test="exsl:IsNonEmptyTableExist('bandwidth_utilization_data')">
        <queryRef>/BandwidthDomain/BandwidthUtilizationType/PMUMemoryObject/PMUMemoryObjectStack</queryRef>
        <queryRef>/BandwidthDomain/BandwidthUtilizationType/PMUMemoryObjectAllocationSource/PMUMemoryObjectStack</queryRef>
      </xsl:if>
    </vectorQuery>
    <vectorQuery id="PMUGridRowBy">
      <xsl:if test="exsl:IsNonEmptyTableExist('pmu_mem_data') and exsl:ctx('collectMemObjects', 0)">
        <vectorQueryInsert>/MemoryObjectsRowBySubset</vectorQueryInsert>
      </xsl:if>
      <xsl:if test="exsl:IsNonEmptyTableExist('dd_process_in_container')">
        <queryRef>/ContainerName/GenericProcess/Function/GenericThread/ParentCallStack</queryRef>
        <queryRef>/ContainerId/GenericProcess/Function/GenericThread/ParentCallStack</queryRef>
      </xsl:if>
      <queryRef>/Function/ParentCallStack</queryRef>
      <xsl:if test="exsl:IsNonEmptyTableExist('bandwidth_utilization_data')">
        <queryRef>/BandwidthDomain/BandwidthUtilizationType/Function/ParentCallStack</queryRef>
      </xsl:if>
      <queryRef>/SourceFunction/Function/ParentCallStack</queryRef>
      <queryRef>/Function/GenericThread/HWContext/ParentCallStack</queryRef>
      <queryRef>/Function/GenericPackage/HWContext/GenericThread/ParentCallStack</queryRef>
      <queryRef>/GenericPackage/HWContext/Function/ParentCallStack</queryRef>
      <xsl:if test="exsl:IsNonEmptyTableExist('dd_core_type')">
        <queryRef>/PMUCoreType/PMUCore/HWContext/Function/ParentCallStack</queryRef>
        <queryRef>/PMUCoreType/HWContext/Function/ParentCallStack</queryRef>
      </xsl:if>
      <queryRef>/PMUCore/HWContext/Function/ParentCallStack</queryRef>
      <queryRef>/Module/Function/ParentCallStack</queryRef>
      <queryRef>/Module/BasicBlock/ParentCallStack</queryRef>
      <queryRef>/Module/RVA/ParentCallStack</queryRef>
      <queryRef>/Module/Function/FunctionRange/ParentCallStack</queryRef>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('dd_vm_info')">
          <queryRef>/GenericVM/GenericThread/Function/ParentCallStack</queryRef>
          <xsl:if test="exsl:IsNonEmptyTableExist('dd_core_type')">
            <queryRef>/PMUCoreType/PMUCore/GenericVM/GenericThread/Function/ParentCallStack</queryRef>
            <queryRef>/PMUCoreType/GenericVM/GenericThread/Function/ParentCallStack</queryRef>
          </xsl:if>
          <queryRef>/PMUCore/GenericVM/GenericThread/Function/ParentCallStack</queryRef>
          <queryRef>/GenericVM/GenericProcess/Function/GenericThread/ParentCallStack</queryRef>
          <queryRef>/GenericVM/GenericProcess/Module/Function/GenericThread/ParentCallStack</queryRef>
          <queryRef>/GenericVM/GenericProcess/Module/GenericThread/Function/ParentCallStack</queryRef>
          <queryRef>/GenericVM/GenericProcess/GenericThread/Module/Function/ParentCallStack</queryRef>
        </xsl:when>
        <xsl:otherwise>
          <queryRef>/GenericThread/Function/ParentCallStack</queryRef>
          <xsl:if test="exsl:IsNonEmptyTableExist('dd_core_type')">
            <queryRef>/PMUCoreType/PMUCore/GenericThread/Function/ParentCallStack</queryRef>
            <queryRef>/PMUCoreType/GenericThread/Function/ParentCallStack</queryRef>
          </xsl:if>
          <queryRef>/PMUCore/GenericThread/Function/ParentCallStack</queryRef>
          <queryRef>/GenericProcess/Function/GenericThread/ParentCallStack</queryRef>
          <queryRef>/GenericProcess/Module/Function/GenericThread/ParentCallStack</queryRef>
          <queryRef>/GenericProcess/Module/GenericThread/Function/ParentCallStack</queryRef>
          <queryRef>/GenericProcess/GenericThread/Module/Function/ParentCallStack</queryRef>
        </xsl:otherwise>
      </xsl:choose>
      <queryRef>/Class/Function/ParentCallStack</queryRef>
      <queryRef>/SourceFile/Class/Function/ParentCallStack</queryRef>
      <xsl:if test="exsl:IsNonEmptyTableExist('task_data')">
        <queryRef>/TaskDomain/TaskType/Function/ParentCallStack</queryRef>
        <queryRef>/TaskType/Function/ParentCallStack</queryRef>
        <queryRef>/TaskDomain/TaskType/TaskDurationType/Function/ParentCallStack</queryRef>
        <queryRef>/TaskType/TaskDurationType/Function/ParentCallStack</queryRef>
      </xsl:if>
      <queryRef>/FrameDomain/Frame/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/Module/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/GenericThread/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/TaskDomain/TaskType/Function/ParentCallStack</queryRef>
      <queryRef>/RegionDomain/Function/ParentCallStack</queryRef>
      <queryRef>/RegionDomain/BarrierDomain/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/RegionDomain/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/RegionDomain/BarrierDomain/Function/ParentCallStack</queryRef>
      <queryRef>/RegionDomain/Module/Function/ParentCallStack</queryRef>
      <queryRef>/RegionDomain/Thread/Function/ParentCallStack</queryRef>
      <queryRef>/RegionDomain/RegionType/Function/ParentCallStack</queryRef>
      <queryRef>/RegionDomain/RegionType/Thread/Function/ParentCallStack</queryRef>
      <xsl:if test="exsl:IsNonEmptyTableExist('pmu_mem_data') and not(exsl:ctx('collectMemObjects', 0))">
        <vectorQueryInsert>/MemoryObjectsRowBySubset</vectorQueryInsert>
      </xsl:if>
      <xsl:if test="exsl:IsNonEmptyTableExist('dd_memory_access')">
        <queryRef>/PMUCacheline/Function/ParentCallStack</queryRef>
        <queryRef>/PMUCacheline/Function/SourceFile/SourceLine/ParentCallStack</queryRef>
        <xsl:if test="exsl:IsNonEmptyTableExist('dd_core_type')">
          <queryRef>/PMUCacheline/GenericPackage/PMUCoreType/PMUCore/HWContext/Function/ParentCallStack</queryRef>
          <queryRef>/PMUCacheline/GenericPackage/PMUCoreType/HWContext/Function/ParentCallStack</queryRef>
        </xsl:if>
        <queryRef>/PMUCacheline/GenericPackage/PMUCore/HWContext/Function/ParentCallStack</queryRef>
        <queryRef>/PMUCacheline/PMUDataAddress/Function/ParentCallStack</queryRef>
      </xsl:if>
      <xsl:if test="exsl:IsNonEmptyTableExist('interrupt_data')">
        <queryRef>/InterruptCore/Interrupt/InterruptDurationType/Function/ParentCallStack</queryRef>
        <queryRef>/Interrupt/InterruptDurationType/Function/ParentCallStack</queryRef>
      </xsl:if>
    </vectorQuery>
    <vectorQuery id="OpenMPGridRowBy">
      <xsl:if test="(exsl:ctx('openmpProcessCount') = 1)">
        <queryRef>/RegionDomain/BarrierDomain/Function/ParentCallStack</queryRef>
        <queryRef>/RegionDomain/BarrierDomain</queryRef>
        <queryRef>/RegionDomain/Function/ParentCallStack</queryRef>
        <queryRef>/RegionDomain/Module/Function/ParentCallStack</queryRef>
        <queryRef>/RegionDomain/Thread/Function/ParentCallStack</queryRef>
        <queryRef>/RegionDomain/RegionType/Function/ParentCallStack</queryRef>
        <queryRef>/RegionDomain/RegionType/Thread/Function/ParentCallStack</queryRef>
      </xsl:if>
      <queryRef>/GenericProcess/RegionDomain/BarrierDomain/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/RegionDomain/BarrierDomain</queryRef>
      <queryRef>/GenericProcess/RegionDomain/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/RegionDomain/Module/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/RegionDomain/Thread/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/RegionDomain/RegionType/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/RegionDomain/RegionType/Thread/Function/ParentCallStack</queryRef>
    </vectorQuery>
    <vectorQuery id="PMUAsmPaneRowBy">
      <queryRef>/PMUInternalAddressFlat</queryRef>
      <queryRef>/PMUBasicBlockInternal/PMUInternalAddress</queryRef>
      <queryRef>/PMUFunctionRangeInternal/PMUBasicBlockInternal/PMUInternalAddress</queryRef>
    </vectorQuery>
    <vectorQuery id="CPUGridRowBy">
      <queryRef>/Function/ParentCallStack</queryRef>
      <queryRef>/SourceFunction/Function/ParentCallStack</queryRef>
      <queryRef>/SyncObject/Function/ParentCallStack</queryRef>
      <queryRef>/SyncObject/Thread/Function/ParentCallStack</queryRef>
      <queryRef>/Module/Function/ParentCallStack</queryRef>
      <queryRef>/Module/BasicBlock/ParentCallStack</queryRef>
      <queryRef>/Module/RVA/CPUParentCallStack</queryRef>
      <queryRef>/Module/Function/FunctionRange/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/Function/GenericThread/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/Module/Function/GenericThread/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/Module/GenericThread/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/GenericThread/Module/Function/ParentCallStack</queryRef>
      <queryRef>/GenericThread/Function/ParentCallStack</queryRef>
      <queryRef>/Class/Function/ParentCallStack</queryRef>
      <queryRef>/SourceFile/Class/Function/ParentCallStack</queryRef>
      <queryRef>/TaskDomain/TaskType/Function/ParentCallStack</queryRef>
      <queryRef>/TaskType/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/Frame/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/Module/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/Thread/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/TaskDomain/TaskType/Function/ParentCallStack</queryRef>
      <queryRef>/RegionDomain/Function/ParentCallStack</queryRef>
      <queryRef>/RegionDomain/BarrierDomain/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/RegionDomain/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/RegionDomain/BarrierDomain/Function/ParentCallStack</queryRef>
      <queryRef>/RegionDomain/Module/Function/ParentCallStack</queryRef>
      <queryRef>/RegionDomain/Thread/Function/ParentCallStack</queryRef>
      <queryRef>/RegionDomain/RegionType/Function/ParentCallStack</queryRef>
      <queryRef>/RegionDomain/RegionType/Thread/Function/ParentCallStack</queryRef>
    </vectorQuery>
    <vectorQuery id="FPGAGridRowBy">
      <xsl:choose>
        <xsl:when test="exsl:ctx('useAOCLProfile', 0)">
          <queryRef>/FPGAComputeTaskTypeVector/FPGADeviceChannel</queryRef>
        </xsl:when>
        <xsl:otherwise>
          <queryRef>/FPGAComputeTaskType/FPGAComputeTaskInstance</queryRef>
          <queryRef>/FPGAComputeTaskPurpose/FPGAComputeTaskType/FPGAComputeTaskInstance</queryRef>
          <queryRef>/FPGAComputeTaskPurpose/FPGASourceComputeTask</queryRef>
        </xsl:otherwise>
      </xsl:choose>
      <queryRef>/Function/ParentCallStack</queryRef>
      <queryRef>/SourceFunction/Function/ParentCallStack</queryRef>
      <queryRef>/Module/Function/ParentCallStack</queryRef>
      <queryRef>/Module/BasicBlock/ParentCallStack</queryRef>
      <queryRef>/Module/RVA/CPUParentCallStack</queryRef>
      <queryRef>/Module/Function/FunctionRange/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/Function/GenericThread/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/Module/Function/GenericThread/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/Module/GenericThread/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/GenericThread/Module/Function/ParentCallStack</queryRef>
      <queryRef>/GenericThread/Function/ParentCallStack</queryRef>
      <queryRef>/TaskDomain/TaskType/Function/ParentCallStack</queryRef>
      <queryRef>/TaskType/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/Frame/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/Module/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/Thread/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/TaskDomain/TaskType/Function/ParentCallStack</queryRef>
    </vectorQuery>
    <vectorQuery id="GPUGridRowBy">
      <vectorQueryInsert>/CPUGPUGridRowBy</vectorQueryInsert>
      <queryRef>/Function/ParentCallStack</queryRef>
      <queryRef>/SourceFunction/Function/ParentCallStack</queryRef>
      <queryRef>/Module/Function/ParentCallStack</queryRef>
      <queryRef>/Module/BasicBlock/ParentCallStack</queryRef>
      <queryRef>/Module/RVA/CPUParentCallStack</queryRef>
      <queryRef>/Module/Function/FunctionRange/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/Function/GenericThread/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/Module/Function/GenericThread/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/Module/GenericThread/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/GenericThread/Module/Function/ParentCallStack</queryRef>
      <queryRef>/GenericThread/Function/ParentCallStack</queryRef>
      <queryRef>/TaskDomain/TaskType/Function/ParentCallStack</queryRef>
      <queryRef>/TaskType/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/Frame/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/Module/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/Thread/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/TaskDomain/TaskType/Function/ParentCallStack</queryRef>
    </vectorQuery>
    <vectorQuery id="CPUGPUInteractionGridRowBy">
      <xsl:choose>
        <xsl:when test="$GPUGTPinDataCollected">
          <queryRef>/GPUComputeTaskTypeVector/GPUFunction/GPUParentCallStack</queryRef>
          <queryRef>/GPUSourceComputeTaskGTPinDataNew/GPUFunction/GPUParentCallStack</queryRef>
        </xsl:when>
        <xsl:otherwise>
          <queryRef>/GPUComputeTaskTypeDerived</queryRef>
          <queryRef>/GPUSourceComputeTaskNew</queryRef>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('dma_packet_data')">
          <queryRef>/GPUDMAPacketPerfTagType</queryRef>
          <xsl:if test="exsl:ctx('targetOS')!='MacOSX' and exsl:is_experimental('gpu-frame-grouping')">
            <queryRef>/BandwidthDomain/BandwidthUtilizationType/GPUDMAPacketPerfTagType</queryRef>
          </xsl:if>
        </xsl:when>
        <xsl:when test="exsl:IsNonEmptyTableExist('gpu_compute_task_data') and exsl:is_experimental('gpu-frame-grouping')">
          <queryRef>/BandwidthDomain/BandwidthUtilizationType/GPUComputeTaskType</queryRef>
        </xsl:when>
      </xsl:choose>
         <queryRef>/Function/ParentCallStack</queryRef>
         <queryRef>/GenericThread/Function/ParentCallStack</queryRef>
         <xsl:if test="exsl:IsNonEmptyTableExist('task_data')">
           <queryRef>/TaskType/Function/ParentCallStack</queryRef>
           <queryRef>/TaskType/GenericThread/Function/ParentCallStack</queryRef>
         </xsl:if>
    </vectorQuery>
    <vectorQuery id="inKernelProfilingGridRowBy">
      <xsl:choose>
        <xsl:when test="$GPUGTPinDataCollected">
          <queryRef>/GPUComputeTaskTypeVector/GPUFunction/GPUParentCallStack</queryRef>
          <queryRef>/GPUSourceComputeTaskGTPinDataNew/GPUFunction/GPUParentCallStack</queryRef>
          <queryRef>/GPUComputeTaskTypeVector/GPUSourceFunction/GPUParentCallStack</queryRef>
          <queryRef>/GPUSourceComputeTaskGTPinDataNew/GPUSourceFunction/GPUParentCallStack</queryRef>
        </xsl:when>
        <xsl:otherwise>
          <queryRef>/GPUComputeTaskTypeDerived</queryRef>
          <queryRef>/GPUSourceComputeTaskNew</queryRef>
          <xsl:choose>
            <xsl:when test="exsl:IsNonEmptyTableExist('dma_packet_data')">
              <queryRef>/GPUDMAPacketPerfTagType</queryRef>
              <xsl:if test="exsl:ctx('targetOS')!='MacOSX' and exsl:is_experimental('gpu-frame-grouping')">
                <queryRef>/BandwidthDomain/BandwidthUtilizationType/GPUDMAPacketPerfTagType</queryRef>
               </xsl:if>
            </xsl:when>
            <xsl:when test="exsl:IsNonEmptyTableExist('gpu_compute_task_data') and exsl:is_experimental('gpu-frame-grouping')">
              <queryRef>/BandwidthDomain/BandwidthUtilizationType/GPUComputeTaskType</queryRef>
            </xsl:when>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </vectorQuery>
    <vectorQuery id="CPUGPUGridRowBy">
      <xsl:if test="$GPUComputingTasksCollected">
        <xsl:choose>
          <xsl:when test="(exsl:ctx('appRunsCount', 1) > 1)">
            <xsl:choose>
              <xsl:when test="$GPUGTPinDataCollected">
                <queryRef>/GPUComputeTaskType</queryRef>
                <queryRef>/GPUComputeTaskTypeVector</queryRef>
                <queryRef>/GPUComputeTaskPurposeVector/GPUComputeTaskTypeVector</queryRef>
                <queryRef>/GPUComputeTaskTypeVector/GPUFunction/GPUParentCallStack</queryRef>
                <queryRef>/GPUComputeTaskTypeVector/GPUSourceFunction/GPUParentCallStack</queryRef>
              </xsl:when>
              <xsl:otherwise>
                <queryRef>/GPUComputeTaskType</queryRef>
                <queryRef>/GPUComputeTaskPurpose/GPUComputeTaskType</queryRef>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:when>
          <xsl:otherwise>
            <xsl:choose>
              <xsl:when test="$GPUGTPinDataCollected">
                <queryRef>/GPUComputeTaskTypeVector/GPUComputeTaskInstance</queryRef>
                <queryRef>/GPUComputeTaskPurposeVector/GPUComputeTaskTypeVector/GPUComputeTaskInstance</queryRef>
                <queryRef>/GPUComputeTaskTypeVector/GPUFunction/GPUParentCallStack</queryRef>
                <queryRef>/GPUComputeTaskTypeVector/GPUSourceFunction/GPUParentCallStack</queryRef>
              </xsl:when>
              <xsl:otherwise>
                <queryRef>/GPUComputeTaskType/GPUComputeTaskInstance</queryRef>
                <queryRef>/GPUComputeTaskPurpose/GPUComputeTaskType/GPUComputeTaskInstance</queryRef>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:choose>
          <xsl:when test="$GPUGTPinDataCollected">
            <queryRef>/GPUComputeTaskPurposeVector/GPUSourceComputeTaskVector</queryRef>
          </xsl:when>
          <xsl:otherwise>
            <queryRef>/GPUComputeTaskPurpose/GPUSourceComputeTask</queryRef>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <xsl:if test="exsl:ctx('targetOS')!='MacOSX'">
        <xsl:choose>
          <xsl:when test="exsl:IsNonEmptyTableExist('dd_vm_info')">
            <queryRef>/GPUVM/GPUDMAPacketPerfTagType</queryRef>
            <queryRef>/GenericVirtualMachine/GenericProcess/GenericThread/Function</queryRef>
          </xsl:when>
          <xsl:otherwise>
            <queryRef>/GPUDMAPacketPerfTagType</queryRef>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:if test="exsl:is_experimental('gpu-frame-grouping')">
          <queryRef>/GPUDMAPacketSubmissionId</queryRef>
        </xsl:if>
      </xsl:if>
      <xsl:if test="exsl:IsNonEmptyTableExist('packet_stage_data')">
        <queryRef>/PacketStage/Function/ParentCallStack</queryRef>
        <queryRef>/PacketStage/GenericThread/Function/ParentCallStack</queryRef>
        <xsl:if test="exsl:IsNonEmptyTableExist('task_data')">
          <queryRef>/PacketStage/TaskType/Function/ParentCallStack</queryRef>
          <queryRef>/PacketStage/TaskType/GenericThread/Function/ParentCallStack</queryRef>
        </xsl:if>
      </xsl:if>
      <xsl:if test="exsl:IsNonEmptyTableExist('bandwidth_utilization_data')">
        <xsl:if test="exsl:is_experimental('gpu-frame-grouping')">
          <xsl:if test="$GPUComputingTasksCollected">
            <xsl:choose>
              <xsl:when test="(exsl:ctx('appRunsCount', 1) > 1)">
                <queryRef>/BandwidthDomain/BandwidthUtilizationType/GPUComputeTaskPurpose/GPUComputeTaskType</queryRef>
              </xsl:when>
              <xsl:otherwise>
                <queryRef>/BandwidthDomain/BandwidthUtilizationType/GPUComputeTaskPurpose/GPUComputeTaskType/GPUComputeTaskInstance</queryRef>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:if>
        </xsl:if>
        <xsl:if test="exsl:ctx('targetOS')!='MacOSX'">
          <queryRef>/BandwidthDomain/BandwidthUtilizationType/GPUDMAPacketPerfTagType</queryRef>
          <xsl:if test="exsl:is_experimental('gpu-frame-grouping')">
            <queryRef>/BandwidthDomain/BandwidthUtilizationType/GPUDMAPacketSubmissionId</queryRef>
          </xsl:if>
        </xsl:if>
      </xsl:if>
    </vectorQuery>
    <vectorQuery id="GPUGTPinGridRowBy">
      <queryRef>/GPUComputeTaskTypeVector/Function/GPUParentCallStack</queryRef>
      <queryRef>/GPUComputeTaskTypeVector/SourceFunction/GPUParentCallStack</queryRef>
    </vectorQuery>
    <vectorQuery id="GSIMGridRowBy">
      <queryRef>/GPUComputeTaskTypeVector/GSIMGenericFunction/GSIMGenericParentCallstack</queryRef>
      <queryRef>/GPUComputeTaskTypeVector/GSIMGenericSourceFunction/GSIMGenericParentCallstack</queryRef>
      <queryRef>/GPUSourceComputeTaskVector/GSIMGenericFunction/GSIMGenericParentCallstack</queryRef>
      <queryRef>/GPUSourceComputeTaskVector/GSIMGenericSourceFunction/GSIMGenericParentCallstack</queryRef>
    </vectorQuery>
    <vectorQuery id="TopDownGridRowBy">
      <queryRef>/CallStack</queryRef>
      <queryRef>/SourceCallStack</queryRef>
    </vectorQuery>
    <vectorQuery id="DeiceTopDownGridRowBy">
      <queryRef>/CounterDeviceRecursive</queryRef>
    </vectorQuery>
    <vectorQuery id="CPUAsmPaneRowBy">
      <queryRef>/CPUInternalAddressFlat</queryRef>
      <queryRef>/CPUBasicBlockInternal/CPUInternalAddress</queryRef>
      <queryRef>/CPUFunctionRangeInternal/CPUBasicBlockInternal/CPUInternalAddress</queryRef>
    </vectorQuery>
    <vectorQuery id="WaitGridRowBy">
      <queryRef>/SyncObject/Function/ParentCallStack</queryRef>
      <queryRef>/SyncObject/Thread/Function/ParentCallStack</queryRef>
      <queryRef>/Function/ParentCallStack</queryRef>
      <queryRef>/SourceFunction/Function/ParentCallStack</queryRef>
      <queryRef>/SourceFile/Function/ParentCallStack</queryRef>
      <queryRef>/Module/Function/ParentCallStack</queryRef>
      <queryRef>/Thread/Function/ParentCallStack</queryRef>
      <queryRef>/Function/Thread/ParentCallStack</queryRef>
      <xsl:if test="exsl:IsNonEmptyTableExist('task_data')">
        <queryRef>/TaskDomain/TaskType/Function/ParentCallStack</queryRef>
        <queryRef>/TaskDomain/TaskType/SyncObject/Function/ParentCallStack</queryRef>
      </xsl:if>
      <queryRef>/Class/Function/ParentCallStack</queryRef>
      <queryRef>/SourceFile/Class/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/Frame/SyncObject/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/SyncObject/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/SyncObject/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/Thread/SyncObject/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/TaskDomain/TaskType/SyncObject/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/Module/Function/ParentCallStack</queryRef>
      <queryRef>/FrameDomain/FrameType/Frame/Function/ParentCallStack</queryRef>
      <xsl:if test="exsl:IsNonEmptyTableExist('dd_region')">
        <queryRef>/RegionDomain/Function/ParentCallStack</queryRef>
        <queryRef>/RegionDomain/BarrierDomain/Function/ParentCallStack</queryRef>
        <queryRef>/GenericProcess/RegionDomain/Function/ParentCallStack</queryRef>
        <queryRef>/GenericProcess/RegionDomain/BarrierDomain/Function/ParentCallStack</queryRef>
        <queryRef>/RegionDomain/Module/Function/ParentCallStack</queryRef>
        <queryRef>/RegionDomain/Thread/Function/ParentCallStack</queryRef>
        <queryRef>/RegionDomain/RegionType/Function/ParentCallStack</queryRef>
        <queryRef>/RegionDomain/RegionType/Thread/Function/ParentCallStack</queryRef>
      </xsl:if>
      <queryRef>/GenericProcess/Function/GenericThread/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/Module/Function/GenericThread/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/Module/GenericThread/Function/ParentCallStack</queryRef>
      <queryRef>/GenericProcess/GenericThread/Module/Function/ParentCallStack</queryRef>
    </vectorQuery>
    <vectorQuery id="WaitAsmPaneRowBy">
      <queryRef>/WaitInternalAddressFlat</queryRef>
      <queryRef>/WaitBasicBlockInternal/WaitInternalAddress</queryRef>
      <queryRef>/WaitFunctionRangeInternal/WaitBasicBlockInternal/WaitInternalAddress</queryRef>
    </vectorQuery>
    <vectorQuery id="CPUTimelineRowBy">
      <queryRef>/GenericThread</queryRef>
      <queryRef>/GenericProcess</queryRef>
      <queryRef>/GenericProcess/GenericThread</queryRef>
      <queryRef>/GenericProcess/GenericThread/Module</queryRef>
      <queryRef>/GenericProcess/Module</queryRef>
    </vectorQuery>
    <vectorQuery id="PMUTimelineRowBy">
      <xsl:choose>
        <xsl:when test="exsl:IsNonEmptyTableExist('dd_vm_info')">
          <queryRef>/GenericVM/GenericThread</queryRef>
          <queryRef>/HWContext</queryRef>
          <queryRef>/GenericCore/HWContext</queryRef>
          <xsl:if test="exsl:IsNonEmptyTableExist('dd_core_type')">
            <queryRef>/GenericCoreType/HWContext</queryRef>
            <queryRef>/GenericCoreType/GenericCore/HWContext</queryRef>
          </xsl:if>
          <queryRef>/GenericPackage/GenericCore/HWContext</queryRef>
          <xsl:if test="exsl:IsNonEmptyTableExist('dd_core_type')">
            <queryRef>/GenericPackage/GenericCoreType/HWContext</queryRef>
            <queryRef>/GenericPackage/GenericCoreType/GenericCore/HWContext</queryRef>
            <queryRef>/GenericVM/GenericThread/GenericCoreType</queryRef>
          </xsl:if>
          <queryRef>/GenericVM/GenericThread/Module</queryRef>
          <queryRef>/GenericVM/GenericThread/HWContext</queryRef>
          <queryRef>/HWContext/GenericThread</queryRef>
          <queryRef>/GenericVM/GenericProcess</queryRef>
          <xsl:if test="exsl:IsNonEmptyTableExist('dd_core_type')">
            <queryRef>/GenericVM/GenericProcess/GenericCoreType</queryRef>
          </xsl:if>
          <queryRef>/GenericVM/GenericProcess/GenericThread</queryRef>
          <queryRef>/GenericVM/GenericProcess/GenericThread/Module</queryRef>
          <queryRef>/GenericVM/GenericProcess/Module</queryRef>
        </xsl:when>
        <xsl:otherwise>
          <queryRef>/GenericThread</queryRef>
          <queryRef>/HWContext</queryRef>
          <queryRef>/GenericCore/HWContext</queryRef>
          <xsl:if test="exsl:IsNonEmptyTableExist('dd_core_type')">
            <queryRef>/GenericCoreType/HWContext</queryRef>
            <queryRef>/GenericCoreType/GenericCore/HWContext</queryRef>
          </xsl:if>
          <queryRef>/GenericPackage/GenericCore/HWContext</queryRef>
          <xsl:if test="exsl:IsNonEmptyTableExist('dd_core_type')">
            <queryRef>/GenericPackage/GenericCoreType/HWContext</queryRef>
            <queryRef>/GenericPackage/GenericCoreType/GenericCore/HWContext</queryRef>
            <queryRef>/GenericThread/GenericCoreType</queryRef>
          </xsl:if>
          <queryRef>/GenericThread/Module</queryRef>
          <queryRef>/GenericThread/HWContext</queryRef>
          <queryRef>/HWContext/GenericThread</queryRef>
          <queryRef>/GenericProcess</queryRef>
          <xsl:if test="exsl:IsNonEmptyTableExist('dd_core_type')">
            <queryRef>/GenericProcess/GenericCoreType</queryRef>
          </xsl:if>
          <queryRef>/GenericProcess/GenericThread</queryRef>
          <queryRef>/GenericProcess/GenericThread/Module</queryRef>
          <queryRef>/GenericProcess/Module</queryRef>
        </xsl:otherwise>
      </xsl:choose>
    </vectorQuery>
    <vectorQuery  id="GPUPacketRowBy">
      <queryRef>/GPUNode</queryRef>
      <xsl:if test="not(contains(exsl:ctx('androidBoardPlatform', ''), 'sofia'))">
        <queryRef>/GPUDMAPacketPerfTagType</queryRef>
      </xsl:if>
    </vectorQuery>
    <vectorQuery id="GPUQueueRowBy">
      <queryRef>/GPUNode</queryRef>
      <xsl:if test="not(contains(exsl:ctx('androidBoardPlatform', ''), 'sofia'))">
        <queryRef>/GPUQueuePacketPerfTagType</queryRef>
      </xsl:if>
    </vectorQuery>
    <vectorQuery id="GPUPerfTagType">
      <queryRef>/GPUDMAPacketPerfTagType</queryRef>
      <queryRef>/GPUQueuePacketPerfTagType</queryRef>
    </vectorQuery>
    <vectorQuery id="GPUProcessName">
      <queryRef>/GPUProcess</queryRef>
      <queryRef>/GPUQueueProcess</queryRef>
    </vectorQuery>
    <vectorQuery id="GPUPacketQueueRowBy">
      <queryRef>/GPUNode</queryRef>
      <xsl:if test="not(contains(exsl:ctx('androidBoardPlatform', ''), 'sofia'))">
        <queryRef>/GPUPerfTagType</queryRef>
      </xsl:if>
    </vectorQuery>
    <vectorQuery id="GPUPacketQueueRowByProcess">
      <queryRef>/GPUNode</queryRef>
      <xsl:if test="not(contains(exsl:ctx('androidBoardPlatform', ''), 'sofia'))">
        <queryRef>/GPUProcessName</queryRef>
      </xsl:if>
    </vectorQuery>
    <vectorQuery id="MemoryUsageRowBy">
      <queryRef>/Process</queryRef>
      <queryRef>/Process/Module</queryRef>
      <queryRef>/Process/Thread</queryRef>
      <queryRef>/Process/Thread/Module</queryRef>
      <queryRef>/Thread</queryRef>
      <queryRef>/Thread/Module</queryRef>
      <queryRef>/Module</queryRef>
      <queryRef>/Module/MemoryAllocCallStack</queryRef>
      <queryRef>/Function</queryRef>
      <queryRef>/Function/Module</queryRef>
    </vectorQuery>
    <vectorQuery id="BottomUpGroupingItems">
      <queryRef>/BarrierDomain</queryRef>
      <queryRef>/BarrierType</queryRef>
      <queryRef>/GPUDMAPacketPerfTagType</queryRef>
      <queryRef>/GPUDMAPacketSubmissionId</queryRef>
    </vectorQuery>
    <vectorQuery id="PMUSamplesDataColumns">
      <queryRef>/CPUGPUUsageElapsedTime/CPUGPUUsageUtilization</queryRef>
      <queryRef>/PMUSampleCount/PMUEventType</queryRef>
      <queryRef>/QuantumWaitAndInactiveTimeExpanded</queryRef>
      <queryRef>/ContextSwitchCountByReason</queryRef>
    </vectorQuery>
    <vectorQuery id="PMUSamplesGUIandCLIColumns">
      <vectorQueryInsert>/PMUSamplesDataColumns</vectorQueryInsert>
      <vectorQueryInsert>/CommonDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/RegionDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/GPUInfoQueries</vectorQueryInsert>
      <vectorQueryInsert>/GPUDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/GridInfoQueriesTail</vectorQueryInsert>
    </vectorQuery>
    <vectorQuery id="PMUEventsDataColumns">
      <queryRef>/CPUGPUUsageElapsedTime/CPUGPUUsageUtilization</queryRef>
      <xsl:if test="exsl:ctx('PMU') = 'lwt-simics'">
        <queryRef>/DerivedClockticks</queryRef>
        <queryRef>/DerivedInstructionsRetired</queryRef>
        <queryRef>/CPI</queryRef>
      </xsl:if>
      <queryRef>/PMUEventCount/PMUEventType</queryRef>
      <queryRef>/QuantumWaitAndInactiveTimeExpanded</queryRef>
      <queryRef>/ContextSwitchCountByReason</queryRef>
    </vectorQuery>
    <vectorQuery id="PMUEventsGUIandCLIColumns">
      <vectorQueryInsert>/PMUEventsDataColumns</vectorQueryInsert>
      <vectorQueryInsert>/CommonDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/RegionDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/GPUInfoQueries</vectorQueryInsert>
      <vectorQueryInsert>/GPUDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/GridInfoQueriesTail</vectorQueryInsert>
    </vectorQuery>
    <vectorQuery id="IPTBBEventsDataColumns">
      <queryRef>/CPUGPUUsageElapsedTime/CPUGPUUsageUtilization</queryRef>
      <xsl:if test="exsl:ctx('PMU') = 'lwt-simics'">
        <queryRef>/DerivedClockticks</queryRef>
        <queryRef>/DerivedInstructionsRetired</queryRef>
        <queryRef>/CPI</queryRef>
      </xsl:if>
      <queryRef>/IPTBBEventCount/IPTBBEventType</queryRef>
      <queryRef>/QuantumWaitAndInactiveTimeExpanded</queryRef>
      <queryRef>/ContextSwitchCountByReason</queryRef>
    </vectorQuery>
    <vectorQuery id="IPTDEventsGUIandCLIColumns">
      <vectorQueryInsert>/IPTBBEventsDataColumns</vectorQueryInsert>
      <vectorQueryInsert>/CommonDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/RegionDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/GPUInfoQueries</vectorQueryInsert>
      <vectorQueryInsert>/GPUDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/GridInfoQueriesTail</vectorQueryInsert>
    </vectorQuery>
    <vectorQuery id="IPTDSamplesDataColumns">
      <queryRef>/CPUGPUUsageElapsedTime/CPUGPUUsageUtilization</queryRef>
      <queryRef>/IPTBBSampleCount/IPTBBEventType</queryRef>
      <queryRef>/QuantumWaitAndInactiveTimeExpanded</queryRef>
      <queryRef>/ContextSwitchCountByReason</queryRef>
    </vectorQuery>
    <vectorQuery id="IPTDSamplesGUIandCLIColumns">
      <vectorQueryInsert>/IPTDSamplesDataColumns</vectorQueryInsert>
      <vectorQueryInsert>/CommonDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/RegionDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/GPUInfoQueries</vectorQueryInsert>
      <vectorQueryInsert>/GPUDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/GridInfoQueriesTail</vectorQueryInsert>
    </vectorQuery>
    <vectorQuery id="UncoreDataColumns">
      <queryRef>/UncoreEventCount/UncoreEventType</queryRef>
    </vectorQuery>
    <vectorQuery id="WaitAndContextSwitchDataMetrics">
      <queryRef>/SchedTime</queryRef>
      <queryRef>/ContextSwitchCount</queryRef>
      <xsl:if test="not(exsl:ctx('hideContextSwitchesType',0))">
        <queryRef>/InactiveSyncWaitCount</queryRef>
        <queryRef>/PreemptionWaitCount</queryRef>
        <queryRef>/QuantumWaitTime</queryRef>
        <queryRef>/QuantumInactiveTime</queryRef>
      </xsl:if>
    </vectorQuery>
    <vectorQuery id="MemoryAllocAsmPaneRowBy">
      <queryRef>/MemoryAllocInternalAddressFlat</queryRef>
      <queryRef>/MemoryAllocBasicBlockInternal/MemoryAllocInternalAddress</queryRef>
      <queryRef>/MemoryAllocFunctionRangeInternal/MemoryAllocBasicBlockInternal/MemoryAllocInternalAddress</queryRef>
    </vectorQuery>
    <vectorQuery id="ViewpointGpuGUIandCLIColumns">
      <vectorQueryInsert>/GPUDataQueries</vectorQueryInsert>
      <vectorQueryInsert>/GPUInfoQueries</vectorQueryInsert>
      <queryRef>/GPUGTPinCycles</queryRef>
    </vectorQuery>
  </queryLibrary>
</bag>
