<?xml version="1.0" encoding="UTF-8"?>
<!--

 Copyright Â© 2009-2020 Intel Corporation. All rights reserved.

 The information contained herein is the exclusive property of
 Intel Corporation and may not be disclosed, examined, or reproduced in
 whole or in part without explicit written authorization from the Company.

-->
<bag
  xmlns:boolean="http://www.w3.org/2001/XMLSchema#boolean"
  xmlns:byte="http://www.w3.org/2001/XMLSchema#byte"
  xmlns:short="http://www.w3.org/2001/XMLSchema#short"
  xmlns:int="http://www.w3.org/2001/XMLSchema#int"
  xmlns:long="http://www.w3.org/2001/XMLSchema#long"
  xmlns:unsignedByte="http://www.w3.org/2001/XMLSchema#unsignedByte"
  xmlns:unsignedShort="http://www.w3.org/2001/XMLSchema#unsignedShort"
  xmlns:unsignedInt="http://www.w3.org/2001/XMLSchema#unsignedInt"
  xmlns:unsignedLong="http://www.w3.org/2001/XMLSchema#unsignedLong"
  xmlns:float="http://www.w3.org/2001/XMLSchema#float"
  xmlns:double="http://www..org/2001/XMLSchema#double"
  xmlns:null="http://www.intel.com/2009/BagSchema#null"
  xmlns:blob="http://www.intel.com/2009/BagSchema#blob"
  >
  <queryLibrary xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:exsl="http://exslt.org/common" exsl:keep_exsl_namespace="">
    <xsl:variable name="sniperHasL3Cache">
      <xsl:if test="exsl:ctx('PMU') = 'sniper'">
        <xsl:copy-of select="document('config://include/sniper_common.xsl')//constants/hasL3Cache"/>
      </xsl:if>
    </xsl:variable>
    <xsl:variable name="sniperHasDRAMCache">
      <xsl:if test="exsl:ctx('PMU') = 'sniper'">
        <xsl:copy-of select="document('config://include/sniper_common.xsl')//constants/hasDRAMCache"/>
      </xsl:if>
    </xsl:variable>
    <infoQuery id="PMUMemoryObjectType" displayName="%MemoryObjectType">
      <dbPath>pmu_mem_data::dd_pmu_mem_connection.memory_object.object_info.type</dbPath>
      <displayDbPathSuffix>name</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="PMUMemoryObjectAddress" displayName="%MemoryObjectAddress">
      <dbPath>pmu_mem_data::dd_pmu_mem_connection.memory_object</dbPath>
      <displayDbPathSuffix>address</displayDbPathSuffix>
      <displayAttributes>
        <format>hex</format>
      </displayAttributes>
      <valueType>uint</valueType>
    </infoQuery>
    <infoQuery id="PMUMemoryObjectSize" displayName="%MemoryObjectSize">
      <dbPath>pmu_mem_data::dd_pmu_mem_connection.memory_object.object_info</dbPath>
      <displayDbPathSuffix>size</displayDbPathSuffix>
      <valueType>memory</valueType>
    </infoQuery>
    <infoQuery id="PMUMemoryObjectOffset" displayName="%Offset">
      <dbPath>pmu_mem_data::dd_pmu_mem_connection.offset</dbPath>
      <valueType>uint</valueType>
    </infoQuery>
    <derivedQuery id="PMUMemoryObjectAllocSourceLocationFileAndLine" displayName="%MemoryObjectAllocSourceFileLine">
      <valueEval><![CDATA[ query("/PMUMemoryObjectAllocSourceFile") + ":" + query("/PMUMemoryObjectAllocSourceLine") ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <infoQuery id="PMUMemoryObjectAllocationSource" displayName="%MemoryObjectAllocationSource">
      <queryInherit>/PMUMemoryObjectAllocRVA</queryInherit>
      <displayEval><![CDATA[ ( query("/PMUMemoryObjectAllocSourceLine") > 0 ) ? query("/PMUMemoryObjectAllocSourceLocationFileAndLine") : query("/PMUMemoryObjectAllocFunction") ]]></displayEval>
      <displayAttributes>
        <diveInitialSelection>disDiveObjectStart</diveInitialSelection>
      </displayAttributes>
    </infoQuery>
    <derivedQuery id="PMUMemoryObjectSizeString">
      <valueEval><![CDATA[ ( query("/PMUMemoryObjectSize") > 0 ) ? ( " ( " + m#query("/PMUMemoryObjectSize") + ")" ) : "" ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="PMUMemoryGlobalObject">
      <valueEval><![CDATA[ query("/PMUMemoryObjectAllocModule" ) + "!" + query("/PMUMemoryObjectAllocFunction") + query("/PMUMemoryObjectSizeString") ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="PMUMemoryDynamicObject">
      <valueEval><![CDATA[ ( ( query("/PMUMemoryObjectAllocSourceLine") > 0 ) ? query("/PMUMemoryObjectAllocSourceLocationFileAndLine") : query("/PMUMemoryObjectAllocFunction") ) + query("/PMUMemoryObjectSizeString") ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <infoQuery id="PMUMemoryObject" displayName="%MemoryObject">
      <dbPath>pmu_mem_data::dd_pmu_mem_connection.memory_object.object_info</dbPath>
      <displayDbPathSuffix>alloc_cs.bottom_user_cs.code_loc.rva</displayDbPathSuffix>
      <displayEval><![CDATA[ ( query("/PMUMemoryObjectType") == "stack" ) ? "[Stack]" : ( ( query("/PMUMemoryObjectType") == "global" ) ? query("/PMUMemoryGlobalObject") : ( ( query("/PMUMemoryObjectType") == "code" ) ? "[" + query("/PMUMemoryObjectAllocModule") + "]" : query("/PMUMemoryDynamicObject" ) ) ) ]]></displayEval>
      <displayAttributes>
        <diveInitialSelection>disDiveObjectStart</diveInitialSelection>
      </displayAttributes>
    </infoQuery>
    <infoQuery id="PMUMemoryObjectStack" displayName="%MemoryObjectStack">
      <queryInherit>/PMUMemoryObjectAllocCallStack</queryInherit>
      <displayAttributes>
        <diveInitialSelection>disDiveObjectStart</diveInitialSelection>
      </displayAttributes>
    </infoQuery>
    <xsl:variable name="isHTOn">
      <xsl:choose>
        <xsl:when test="exsl:ctx('isHTEnabled', 'na') != 'na'">
          <xsl:choose>
            <xsl:when test="exsl:ctx('isHTEnabled')">
              true
            </xsl:when>
            <xsl:otherwise>
              false
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:choose>
            <xsl:when test="exsl:ctx('logicalCPUCount') > exsl:ctx('physicalCoreCount')">
              true
            </xsl:when>
            <xsl:otherwise>
              false
            </xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <derivedQuery id="PMULoads" displayName="%Loads">
      <valueType>count</valueType>
      <boolean:valueSummable>true</boolean:valueSummable>
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'snb' or exsl:ctx('PMU') = 'snbep' or exsl:ctx('PMU') = 'ivybridge' or exsl:ctx('PMU') = 'ivytown' or exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'haswell_server' or exsl:ctx('PMU') = 'broadwell' or exsl:ctx('PMU') = 'broadwell_de' or exsl:ctx('PMU') = 'broadwell_server'">
          <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[MEM_UOPS_RETIRED.ALL_LOADS_PS]")
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'skylake' or exsl:ctx('PMU') = 'skylake_server' or exsl:ctx('PMU') = 'cascadelake_server'">
          <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[MEM_INST_RETIRED.ALL_LOADS_PS]")
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'snowridge'">
          <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[MEM_UOPS_RETIRED.ALL_LOADS]")
          ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[MEM_INST_RETIRED.ALL_LOADS]")
          ]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
    </derivedQuery>
    <derivedQuery id="PMUMemoryObjectLoads" displayName="%Loads">
      <valueType>count</valueType>
      <boolean:valueSummable>true</boolean:valueSummable>
      <valueEval><![CDATA[
            query("/PMUEventCountForMemoryObjects/PMUEventType[MEM_UOPS_RETIRED.ALL_LOADS_PS]")
          ]]>
      </valueEval>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
    </derivedQuery>
    <derivedQuery id="PMUStores" displayName="%Stores">
      <valueType>count</valueType>
      <boolean:valueSummable>true</boolean:valueSummable>
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'snb' or exsl:ctx('PMU') = 'snbep' or exsl:ctx('PMU') = 'ivybridge' or exsl:ctx('PMU') = 'ivytown' or exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'haswell_server' or exsl:ctx('PMU') = 'broadwell' or exsl:ctx('PMU') = 'broadwell_de' or exsl:ctx('PMU') = 'broadwell_server'">
          <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[MEM_UOPS_RETIRED.ALL_STORES_PS]")
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'skylake' or exsl:ctx('PMU') = 'skylake_server' or exsl:ctx('PMU') = 'cascadelake_server'">
          <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[MEM_INST_RETIRED.ALL_STORES_PS]")
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'snowridge'">
          <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[MEM_UOPS_RETIRED.ALL_STORES]")
          ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[MEM_INST_RETIRED.ALL_STORES]")
          ]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'ivybridge' or exsl:ctx('PMU') = 'ivytown'">
          <notApplicableGroupings>
            <vectorQuery id="notApplicableGroupingsGroup">
              <vectorQueryInsert>/PMUMemoryObjectGroupingQueries</vectorQueryInsert>
            </vectorQuery>
          </notApplicableGroupings>
        </xsl:when>
      </xsl:choose>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
    </derivedQuery>
    <derivedQuery id="PMUMemoryObjectStores" displayName="%Stores">
      <valueType>count</valueType>
      <boolean:valueSummable>true</boolean:valueSummable>
      <valueEval><![CDATA[
            query("/PMUEventCountForMemoryObjects/PMUEventType[MEM_UOPS_RETIRED.ALL_STORES_PS]")
          ]]>
      </valueEval>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
    </derivedQuery>
    <derivedQuery id="HighUtilizationLLCMissCount" displayName="%LLCMissCount">
      <valueEval><![CDATA[
            query("/LLCMissCount/BandwidthUtilizationType[%HighBandwidth]") / queryAll("/LLCMissCount", true)
          ]]>
      </valueEval>
      <valueType>ratio</valueType>
    </derivedQuery>
    <derivedQuery id="HighUtilizationLLCInputRequestsKNL" displayName="%LLCInputRequestsKNL">
      <valueEval><![CDATA[
            query("/LLCInputRequestsKNL/BandwidthUtilizationType[%HighBandwidth]") / queryAll("/LLCInputRequestsKNL", true)
          ]]>
      </valueEval>
      <valueType>ratio</valueType>
    </derivedQuery>
    <derivedQuery id="LLCMissCount" displayName="%LLCMissCount">
      <xsl:if test="exsl:ctx('PMU') = 'knl'">
        <xsl:attribute name="displayName">%LLCMissCountKNL</xsl:attribute>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'knl'">
          <description>%LLCMissCountMAKNLDescription</description>
        </xsl:when>
        <xsl:otherwise>
          <description>%LLCMissCountMADescription</description>
        </xsl:otherwise>
      </xsl:choose>
      <valueType>count</valueType>
      <boolean:valueSummable>true</boolean:valueSummable>
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'snb'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_MISC_RETIRED.LLC_MISS_PS]") )
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'snbep'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_RETIRED.LLC_MISS]") )
          ]]></valueEval>
          <notApplicableGroupings>
            <vectorQuery id="notApplicableGroupingsGroup">
              <vectorQueryInsert>/PMUMemoryObjectGroupingQueries</vectorQueryInsert>
            </vectorQuery>
          </notApplicableGroupings>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'ivybridge' or exsl:ctx('PMU') = 'ivytown'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_RETIRED.LLC_MISS_PS]") )
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'haswell_server' or exsl:ctx('PMU') = 'broadwell' or exsl:ctx('PMU') = 'broadwell_de' or exsl:ctx('PMU') = 'broadwell_server'">
          <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_RETIRED.L3_MISS_PS]")
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'knl' or exsl:ctx('PMU') = 'silvermont' or exsl:ctx('PMU') = 'airmont'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_UOPS_RETIRED.L2_MISS_LOADS_PS]") )
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'goldmont' or exsl:ctx('PMU') = 'goldmont_plus' or exsl:ctx('PMU') = 'snowridge'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_RETIRED.DRAM_HIT]") )
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'skylake' or exsl:ctx('PMU') = 'skylake_server' or exsl:ctx('PMU') = 'cascadelake_server'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_RETIRED.L3_MISS_PS]") )
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'sniper'">
          <valueEval>
            <xsl:choose>
              <xsl:when test="$sniperHasL3Cache='true'">query("/PMUEventCount/PMUEventType[L3_LOADS.MISS]")</xsl:when>
              <xsl:otherwise>query("/PMUEventCount/PMUEventType[L2_LOADS.MISS]")</xsl:otherwise>
            </xsl:choose>
          </valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_RETIRED.L3_MISS]") )
          ]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
    </derivedQuery>
    <derivedQuery id="LocalDRAMCount" displayName="%LocalDRAMCount">
      <helpKeyword>configs.localdramcount_localdramcountdescription</helpKeyword>
      <description>%LocalDRAMCountDescription</description>
      <valueType>count</valueType>
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'ivytown'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_LLC_MISS_RETIRED.LOCAL_DRAM]") )
          ]]></valueEval>
          <notApplicableGroupings>
            <vectorQuery id="notApplicableGroupingsGroup">
              <vectorQueryInsert>/PMUMemoryObjectGroupingQueries</vectorQueryInsert>
            </vectorQuery>
          </notApplicableGroupings>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'haswell_server' or exsl:ctx('PMU') = 'broadwell' or exsl:ctx('PMU') = 'broadwell_de' or exsl:ctx('PMU') = 'broadwell_server'">
          <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM_PS]")
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'skylake_server' or exsl:ctx('PMU') = 'cascadelake_server'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_L3_MISS_RETIRED.LOCAL_DRAM_PS]") )
          ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_L3_MISS_RETIRED.LOCAL_DRAM]") )
          ]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
    </derivedQuery>
    <derivedQuery id="RemoteDRAMCount" displayName="%RemoteDRAMCount">
      <helpKeyword>configs.remotedramcount_remotedramcountdescription</helpKeyword>
      <description>%RemoteDRAMCountDescription</description>
      <valueType>count</valueType>
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'ivytown'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_LLC_MISS_RETIRED.REMOTE_DRAM]") )
          ]]></valueEval>
          <notApplicableGroupings>
            <vectorQuery id="notApplicableGroupingsGroup">
              <vectorQueryInsert>/PMUMemoryObjectGroupingQueries</vectorQueryInsert>
            </vectorQuery>
          </notApplicableGroupings>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'haswell_server' or exsl:ctx('PMU') = 'broadwell' or exsl:ctx('PMU') = 'broadwell_de' or exsl:ctx('PMU') = 'broadwell_server'">
          <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_DRAM_PS]")
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'skylake_server' or exsl:ctx('PMU') = 'cascadelake_server'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_L3_MISS_RETIRED.REMOTE_DRAM_PS]") )
          ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_L3_MISS_RETIRED.REMOTE_DRAM]") )
          ]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
    </derivedQuery>
    <derivedQuery id="Local3DXPointAccessCount" displayName="%Local3DXPointAccessCount">
      <valueEval><![CDATA[ ( query("/PMUEventCount/PMUEventType[MEM_LOAD_RETIRED.LOCAL_PMM_PS]") ) ]]></valueEval>
      <helpKeyword>configs.local3dxpointaccesscount_local3dxpointaccesscountdescription</helpKeyword>
      <description>%Local3DXPointAccessCountDescription</description>
      <valueType>count</valueType>
    </derivedQuery>
    <derivedQuery id="Remote3DXPointAccessCount" displayName="%Remote3DXPointAccessCount">
      <valueEval><![CDATA[ ( query("/PMUEventCount/PMUEventType[MEM_LOAD_L3_MISS_RETIRED.REMOTE_PMM_PS]") ) ]]></valueEval>
      <helpKeyword>configs.remote3dxpointaccesscount_remote3dxpointaccesscountdescription</helpKeyword>
      <description>%Remote3DXPointAccessCountDescription</description>
      <valueType>count</valueType>
    </derivedQuery>
    <derivedQuery id="RemoteCacheCount" displayName="%RemoteCacheCount">
      <helpKeyword>configs.remotecachecount_remotecachecountdescription</helpKeyword>
      <description>%RemoteCacheCountDescription</description>
      <valueType>count</valueType>
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'ivytown'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_LLC_MISS_RETIRED.REMOTE_HITM]") + query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_LLC_MISS_RETIRED.REMOTE_FWD]") )
          ]]></valueEval>
          <notApplicableGroupings>
            <vectorQuery id="notApplicableGroupingsGroup">
              <vectorQueryInsert>/PMUMemoryObjectGroupingQueries</vectorQueryInsert>
            </vectorQuery>
          </notApplicableGroupings>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'haswell_server' or exsl:ctx('PMU') = 'broadwell' or exsl:ctx('PMU') = 'broadwell_de' or exsl:ctx('PMU') = 'broadwell_server'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM_PS]") + query("/PMUEventCount/PMUEventType[MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_FWD_PS]") )
          ]]></valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'skylake_server' or exsl:ctx('PMU') = 'cascadelake_server'">
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_L3_MISS_RETIRED.REMOTE_HITM_PS]") + query("/PMUEventCount/PMUEventType[MEM_LOAD_L3_MISS_RETIRED.REMOTE_FWD]") )
          ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[
            ( query("/PMUEventCount/PMUEventType[MEM_LOAD_L3_MISS_RETIRED.REMOTE_HITM]") + query("/PMUEventCount/PMUEventType[MEM_LOAD_L3_MISS_RETIRED.REMOTE_FWD]") )
          ]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
    </derivedQuery>
    <derivedQuery id="LLCMissCountGroup">
        <queryInherit>/LLCMissCount</queryInherit>
        <displayAttributes>
            <boolean:expand>false</boolean:expand>
            <boolean:allowCollapse>true</boolean:allowCollapse>
        </displayAttributes>
        <expand>
            <vectorQuery id="LLCMissCountGroupExpanded">
                <queryRef>/LocalDRAMCount</queryRef>
                <queryRef>/RemoteDRAMCount</queryRef>
                <xsl:if test="exsl:ctx('is3DXPPresent', 0)">
                  <queryRef>/Local3DXPointAccessCount</queryRef>
                  <queryRef>/Remote3DXPointAccessCount</queryRef>
                </xsl:if>
                <queryRef>/RemoteCacheCount</queryRef>
            </vectorQuery>
        </expand>
    </derivedQuery>
    <derivedQuery id="2LMCacheHitRatioGroup">
        <queryInherit>/2LMCacheHitRatio</queryInherit>
        <displayAttributes>
            <boolean:expand>false</boolean:expand>
            <boolean:allowCollapse>true</boolean:allowCollapse>
        </displayAttributes>
        <expand>
            <vectorQuery id="2LMCacheHitRatioGroupExpanded">
                <queryRef>/2LMCacheHits</queryRef>
                <queryRef>/2LMCacheMisses</queryRef>
            </vectorQuery>
        </expand>
    </derivedQuery>
    <derivedQuery id="TotalLatency" displayName="%TotalLatency">
      <valueType>count</valueType>
      <boolean:valueSummable>true</boolean:valueSummable>
      <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[Total_Latency_MEM_TRANS_RETIRED.LOAD_LATENCY_GT_4]")
          ]]>
      </valueEval>
    </derivedQuery>
    <derivedQuery id="TotalLatencyPercent" displayName="%TotalLatency">
      <queryInherit>/TotalLatency</queryInherit>
      <boolean:valueSummable>true</boolean:valueSummable>
      <displayAttributes>
        <selfFormat>percent</selfFormat>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="LatencyLoads" displayName="%LatencyLoads">
      <valueType>count</valueType>
      <boolean:valueSummable>true</boolean:valueSummable>
      <valueEval><![CDATA[
            query("/PMUEventCount/PMUEventType[MEM_TRANS_RETIRED.LOAD_LATENCY_GT_4]")
          ]]>
      </valueEval>
    </derivedQuery>
    <derivedQuery id="AvgLatency" displayName="%AvgLatency">
      <helpKeyword>configs.avglatency_avglatencydescription</helpKeyword>
      <description>%AvgLatencyDescription</description>
      <valueType>count</valueType>
      <boolean:valueSummable>false</boolean:valueSummable>
      <valueEval><![CDATA[
            query("/TotalLatency") / query("/LatencyLoads")
          ]]>
      </valueEval>
      <displayAttributes>
        <selfFormat>count</selfFormat>
        <timelineObjectType>interval</timelineObjectType>
      </displayAttributes>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
    </derivedQuery>
    <derivedQuery id="RemoteToLocalPercent" displayName="%RemoteToLocalPercent">
      <helpKeyword>configs.remotetolocalpercent_remotetolocalpercentdescription</helpKeyword>
      <description>%RemoteToLocalPercentDescription</description>
      <xsl:choose>
        <xsl:when test="exsl:ctx('numaVersion', '') != '' and exsl:ctx('PMU') = 'broadwell_server' and (exsl:ctx('Hypervisor', 'None') = 'None' or (exsl:ctx('Hypervisor', 'None') = 'Microsoft Hv' and exsl:ctx('HypervisorType', 'None') = 'Hyper-V'))">
          <valueEval>
            <![CDATA[( query("/PMUEventCount/PMUEventType[OFFCORE_RESPONSE:request=ALL_READS:response=LLC_MISS.REMOTE_DRAM]") / ( query("/PMUEventCount/PMUEventType[OFFCORE_RESPONSE:request=ALL_READS:response=LLC_MISS.LOCAL_DRAM]") + query("/PMUEventCount/PMUEventType[OFFCORE_RESPONSE:request=ALL_READS:response=LLC_MISS.REMOTE_DRAM]") ))]]>
          </valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('numaVersion', '') != '' and exsl:ctx('PMU') = 'cascadelake_server' and (exsl:ctx('Hypervisor', 'None') = 'None' or (exsl:ctx('Hypervisor', 'None') = 'Microsoft Hv' and exsl:ctx('HypervisorType', 'None') = 'Hyper-V'))">
          <valueEval>
            <![CDATA[( query("/PMUEventCount/PMUEventType[OCR.ALL_READS.L3_MISS_REMOTE_HOP1_DRAM.ANY_SNOOP]") + query("/Remote3DXPointAccessCount")) / ( query("/PMUEventCount/PMUEventType[OCR.ALL_READS.L3_MISS_LOCAL_DRAM.ANY_SNOOP]") + query("/PMUEventCount/PMUEventType[OCR.ALL_READS.L3_MISS_REMOTE_HOP1_DRAM.ANY_SNOOP]") + query("/Local3DXPointAccessCount") + query("/Remote3DXPointAccessCount"))]]>
          </valueEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('numaVersion', '') = '' and exsl:ctx('is3DXPPresent', 0)">
          <valueEval>
            <![CDATA[(query("/RemoteDRAMCount") + query("/Remote3DXPointAccessCount")) / (query("/LocalDRAMCount") + query("/RemoteDRAMCount") + query("/Local3DXPointAccessCount") + query("/Remote3DXPointAccessCount"))]]>
          </valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval>
            <![CDATA[(query("/RemoteDRAMCount") / (query("/LocalDRAMCount") + query("/RemoteDRAMCount")))]]>
          </valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <valueType>ratio</valueType>
      <notApplicableGroupings>
        <vectorQuery id="notApplicableGroupingsGroup">
          <vectorQueryInsert>/PMUMemoryObjectGroupingQueries</vectorQueryInsert>
        </vectorQuery>
      </notApplicableGroupings>
      <issueText>%RemoteToLocalRatioIssueTextAll</issueText>
      <issueEval><![CDATA[ (  ( ( query("/RemoteToLocalPercent") ) > 0.15  ) && (query("/DRAMBound") > 0.1 ) && ( query("/PMUHotspot") > 0.05 ) ) ]]></issueEval>
    </derivedQuery>
    <derivedQuery id="CacheBound" displayName="%CacheBound">
      <helpKeyword>configs.cachebound_cachebounddescriptiontext</helpKeyword>
      <queryInherit>/GeMetricBaseClockticks</queryInherit>
      <description>%CacheBoundDescriptionText</description>
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'knl'">
          <valueEval><![CDATA[ ( ( query("/L1HitKNL") > 0 ? query("/L1HitKNL") : 0 ) + ( query("/LLCHitKNL") > 0 ? query("/LLCHitKNL") : 0 ) ) ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ ( ( query("/L1Bound") > 0 ? query("/L1Bound") : 0 ) + ( query("/L2Bound") > 0 ? query("/L2Bound") : 0 ) + ( query("/L3Bound") > 0 ? query("/L3Bound") : 0 ) ) ]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <valueType>number</valueType>
      <issueText>%CacheBoundIssueText</issueText>
      <issueEval><![CDATA[ (  ( query("/CacheBound") ) > 0.2 ) ]]></issueEval>
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'broadwell' or exsl:ctx('PMU') = 'broadwell_de' or exsl:ctx('PMU') = 'broadwell_server' or exsl:ctx('PMU') = 'skylake' or exsl:ctx('PMU') = 'skylake_server' or exsl:ctx('PMU') = 'cascadelake_server'">
          <confidenceEval><![CDATA[
            ( ( ( query("/PMUSampleCount/PMUEventType[CYCLE_ACTIVITY.STALLS_MEM_ANY]") >= 10 ) ) && ( query("/ClocktickSamples") >= 10 ) && ( query("/Reliability") >= 0.5 ) && ( $shortCollectionMux ? $FALSE : $TRUE ) )
          ]]></confidenceEval>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'knl'">
          <confidenceEval><![CDATA[
            ( ( ( query("/PMUSampleCount/PMUEventType[MEM_UOPS_RETIRED.ALL_LOADS]") >= 10 ) ) && ( query("/ClocktickSamples") >= 10 ) && ( query("/Reliability") >= 0.5 ) && ( $shortCollectionMux ? $FALSE : $TRUE ) )
          ]]></confidenceEval>
        </xsl:when>
        <xsl:otherwise>
          <confidenceEval><![CDATA[
            ( ( ( query("/PMUSampleCount/PMUEventType[CYCLE_ACTIVITY.STALLS_LDM_PENDING]") >= 10 ) ) && ( query("/ClocktickSamples") >= 10 ) && ( query("/Reliability") >= 0.5 ) && ( $shortCollectionMux ? $FALSE : $TRUE ) )
          ]]></confidenceEval>
        </xsl:otherwise>
      </xsl:choose>
    </derivedQuery>
    <derivedQuery id="CacheBoundPercentage" displayName="%CacheBound">
      <helpKeyword>configs.cachebound_cachebounddescriptiontext</helpKeyword>
      <queryInherit>/GeMetricBaseFraction</queryInherit>
      <description>%CacheBoundDescriptionText</description>
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'knl'">
          <valueEval><![CDATA[ ( ( query("/L1HitKNL") > 0 ? query("/L1HitKNL") : 0 ) + ( query("/LLCHitKNL") > 0 ? query("/LLCHitKNL") : 0 ) ) ]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ ( ( query("/L1Bound") > 0 ? query("/L1Bound") : 0 ) + ( query("/L2Bound") > 0 ? query("/L2Bound") : 0 ) + ( query("/L3Bound") > 0 ? query("/L3Bound") : 0 ) ) ]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <valueType>ratio</valueType>
      <displayAttributes>
        <selfFormat>ratio</selfFormat>
        <totalFormat>ratio</totalFormat>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="DRAMBoundGroupHPC">
      <queryInherit>/DRAMBound</queryInherit>
      <xsl:choose>
        <xsl:when test="($isHTOn = 'true') and (exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'haswell_server')">
          <valueEval>$NULL</valueEval>
          <issueEval>$FALSE</issueEval>
          <displayAttributes>
            <boolean:expand>true</boolean:expand>
            <boolean:allowCollapse>false</boolean:allowCollapse>
          </displayAttributes>
          <expand>
            <vectorQuery id="DRAMBoundGroupHPCExpanded">
              <xsl:if test="exsl:ctx('PMU') = 'ivybridge' or exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'broadwell' or exsl:ctx('PMU') = 'broadwell_de' or exsl:ctx('PMU') = 'broadwell_server' or exsl:ctx('PMU') = 'skylake' or exsl:ctx('PMU') = 'skylake_server' or exsl:ctx('PMU') = 'cascadelake_server'">
                <queryRef>/LLCMiss</queryRef>
              </xsl:if>
              <queryRef>/RemoteToLocalPercent</queryRef>
              <queryRef>/LocalDRAM</queryRef>
              <queryRef>/RemoteDRAM</queryRef>
              <queryRef>/RemoteCache</queryRef>
            </vectorQuery>
          </expand>
        </xsl:when>
        <xsl:otherwise>
          <displayAttributes>
            <boolean:expand>false</boolean:expand>
            <boolean:allowCollapse>true</boolean:allowCollapse>
          </displayAttributes>
          <vectorQuery id="DRAMBoundGroupHPCExpanded">
            <queryRef>/MEMBandwidth</queryRef>
          </vectorQuery>
        </xsl:otherwise>
      </xsl:choose>
    </derivedQuery>
    <derivedQuery id="3DXPointBoundGroupSummary">
      <queryInherit>/IXP_Bound</queryInherit>
      <displayAttributes>
        <boolean:expand>true</boolean:expand>
        <boolean:allowCollapse>true</boolean:allowCollapse>
      </displayAttributes>
      <expand>
        <vectorQuery id="3DXPointBoundGroupSummaryExpanded">
          <queryRef>/3DXPointBandwidthBoundUncoreMA</queryRef>
        </vectorQuery>
      </expand>
    </derivedQuery>
    <derivedQuery id="3DXPointBoundGroupHPCSummary">
      <queryInherit>/IXP_Bound</queryInherit>
      <displayAttributes>
        <boolean:expand>true</boolean:expand>
        <boolean:allowCollapse>true</boolean:allowCollapse>
      </displayAttributes>
      <expand>
        <xsl:choose>
          <xsl:when test="exsl:ctx('useCountingMode', 0)">
            <vectorQuery id="Average3DXPointBoundGroupHPCSummaryExpanded">
              <queryRef>/Average3DXPointBandwidthBoundUncore</queryRef>
            </vectorQuery>
          </xsl:when>
          <xsl:otherwise>
            <vectorQuery id="3DXPointBoundGroupHPCSummaryExpanded">
              <queryRef>/3DXPointBandwidthBoundUncoreMA</queryRef>
            </vectorQuery>
          </xsl:otherwise>
        </xsl:choose>
      </expand>
    </derivedQuery>
    <derivedQuery id="3DXPointBoundGroup">
      <queryInherit>/IXP_Bound</queryInherit>
      <displayAttributes>
        <boolean:expand>false</boolean:expand>
        <boolean:allowCollapse>true</boolean:allowCollapse>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="DRAMBoundGroupHPCPC">
      <queryInherit>/DRAMBoundForHPCPC</queryInherit>
      <displayAttributes>
        <boolean:expand>true</boolean:expand>
        <boolean:allowCollapse>true</boolean:allowCollapse>
      </displayAttributes>
      <xsl:if test="exsl:ctx('collectMemBandwidth', 0)">
        <expand>
          <vectorQuery id="DRAMBandwidthBoundExpanded">
            <xsl:choose>
              <xsl:when test="exsl:ctx('useCountingMode', 0)">
                <queryRef>/AverageDRAMBandwidth</queryRef>
              </xsl:when>
              <xsl:otherwise>
                <queryRef>/DRAMBandwidthBoundUncoreMA</queryRef>
              </xsl:otherwise>
            </xsl:choose>
          </vectorQuery>
        </expand>
      </xsl:if>
    </derivedQuery>
    <derivedQuery id="L1BoundNonGE">
      <queryInherit>/L1Bound</queryInherit>
      <issues>
        <issue>
          <issueEval><![CDATA[
            ( ( ( (query("/L1Bound") > 0.07) && ( query("/BackendBound") > 0.2 ) && ( query("/MemBound") > 0.2 ) ) ) && ( query("/PMUHotspot") > 0.05 ) )
          ]]></issueEval>
          <issueText>%L1BoundNonGEIssueTextAll</issueText>
        </issue>
      </issues>
    </derivedQuery>
    <derivedQuery id="MemEfficiency" displayName="%MemEfficiency">
      <helpKeyword>configs.memefficiency_memefficiencydescription</helpKeyword>
      <description>%MemEfficiencyDescription</description>
      <valueType>string</valueType>
      <valueEval><![CDATA[ %#(1 - query("/MemBound")) ]]></valueEval>
      <issueText>%MemEfficiencyIssue</issueText>
      <issueEval><![CDATA[ ( query("/MemBound") >= 0.2 )]]></issueEval>
    </derivedQuery>
    <derivedQuery id="LLCInputRequestsPrefetcherKNL" displayName="%LLCInputRequestsPrefetcherKNL">
      <description>%LLCInputRequestsPrefetcherKNLDescription</description>
      <valueType>count</valueType>
      <boolean:valueSummable>true</boolean:valueSummable>
      <valueEval><![CDATA[ ( query("/PMUEventCount/PMUEventType[L2_PREFETCHER.ALLOC_XQ]") ) ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="LLCInputRequestsKNL" displayName="%LLCInputRequestsKNL">
      <description>%LLCInputRequestsKNLDescription</description>
      <valueType>count</valueType>
      <boolean:valueSummable>true</boolean:valueSummable>
      <valueEval><![CDATA[ ( query("/LLCMissCount") + query("/LLCInputRequestsPrefetcherKNL") ) ]]></valueEval>
    </derivedQuery>
    <derivedQuery displayName="%LLCInputRequestsKNLForUnits" id="LLCInputRequestsKNLForUnits">
      <queryInherit>/LLCInputRequestsKNL</queryInherit>
    </derivedQuery>
    <derivedQuery id="LLCPrefetcherFractionKNL" displayName="%LLCPrefetcherFractionKNL">
      <description>%LLCPrefetcherFractionKNLDescription</description>
      <valueType>ratio</valueType>
      <valueEval><![CDATA[ query("/PMUEventCount/PMUEventType[L2_PREFETCHER.ALLOC_XQ]") / query("/LLCInputRequestsKNL") ]]></valueEval>
      <issueText>%LLCPrefetcherFractionKNLIssue</issueText>
      <issueEval><![CDATA[ ( ( query("/LLCPrefetcherFractionKNL") >= 0.7 ) && ( (queryOptional("/DRAMBandwidthBoundUncore") > 0.1) || (queryOptional("/MCDRAMBandwidthBoundUncore") > 0.1) || (queryOptional("/MCDRAMFlatBandwidthBoundUncore") > 0.1) || (queryOptional("/MCDRAMCacheBandwidthBoundUncore") > 0.1) ) && (query("/LLCMissKNL") <= 0.15) )]]></issueEval>
      <unitOfMeasureQueryId>LLCInputRequestsKNLForUnits</unitOfMeasureQueryId>
    </derivedQuery>
    <derivedQuery id="LLCDemandFractionKNL" displayName="%LLCDemandFractionKNL">
      <description>%LLCDemandFractionKNLDescription</description>
      <valueType>ratio</valueType>
      <valueEval><![CDATA[ query("/PMUEventCount/PMUEventType[MEM_UOPS_RETIRED.L2_MISS_LOADS_PS]") / query("/LLCInputRequestsKNL") ]]></valueEval>
      <unitOfMeasureQueryId>LLCInputRequestsKNLForUnits</unitOfMeasureQueryId>
    </derivedQuery>
    <derivedQuery id="LLCMissKNLHPCGroup">
      <queryInherit>/LLCMissKNLHPC</queryInherit>
      <expand>
        <vectorQuery>
          <queryRef>/LLCDemandFractionKNL</queryRef>
          <queryRef>/LLCPrefetcherFractionKNL</queryRef>
        </vectorQuery>
      </expand>
    </derivedQuery>
    <infoQuery id="MemoryObjectAllocSourceLine">
      <dbPath>memory_object_data::dd_memory_object.object_info.alloc_cs.bottom_user_cs.code_loc.src_loc</dbPath>
      <displayDbPathSuffix>line</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="MemoryObjectInstanceAllocSourceFile">
      <dbPath>memory_object_data::dd_memory_object.object_info.alloc_cs.bottom_user_cs.code_loc.src_loc.src_file</dbPath>
      <displayDbPathSuffix>name</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="MemoryObjectAllocFunction">
      <dbPath>memory_object_data::dd_memory_object.object_info.alloc_cs.bottom_user_cs.code_loc.func_range.func_inst</dbPath>
      <displayDbPathSuffix>function.name</displayDbPathSuffix>
    </infoQuery>
    <derivedQuery id="MemoryObjectInstanceAllocSourceLocationFileAndLine">
      <valueEval><![CDATA[ query("/MemoryObjectInstanceAllocSourceFile") + ":" + query("/MemoryObjectAllocSourceLine") ]]></valueEval>
    </derivedQuery>
    <infoQuery id="MemoryObjectLocation" displayName="%MemoryObject">
      <dbPath>memory_object_data::dd_memory_object.object_info</dbPath>
      <displayDbPathSuffix>alloc_cs.bottom_user_cs.code_loc.rva</displayDbPathSuffix>
      <displayEval>
          <![CDATA[ ( query("/MemoryObjectType") == "stack" ) ? "[Stack]" : ( ( ( query("/MemoryObjectAllocSourceLine") > 0 ) ? query("/MemoryObjectInstanceAllocSourceLocationFileAndLine") :
              query("/MemoryObjectAllocFunction") ) + ( ( query("/MemoryObjectSize") > 0 ) ? (" (" + m#query("/MemoryObjectSize") + ")" ) : "" ) ) ]]>
      </displayEval>
      <displayAttributes>
        <diveInitialSelection>disDiveObjectStart</diveInitialSelection>
      </displayAttributes>
    </infoQuery>
    <infoQuery id="MemoryObjectInstance" displayName="%MemoryObjectInstance">
      <dbPath>memory_object_data</dbPath>
      <instanceBandTable>dd_memory_object</instanceBandTable>
      <aliasForUnknown>%AliasUnknownTaskType</aliasForUnknown>
    </infoQuery>
    <infoQuery id="MemoryObjectInstanceStart" displayName="%MemoryObjectInstanceStart">
      <dbPath>memory_object_data.start_tsc</dbPath>
      <aliasForUnknown>%AliasUnknownTaskType</aliasForUnknown>
    </infoQuery>
    <infoQuery id="MemoryObjectInstanceEnd" displayName="%MemoryObjectInstanceEnd">
      <dbPath>memory_object_data.end_tsc</dbPath>
      <aliasForUnknown>%AliasUnknownTaskType</aliasForUnknown>
    </infoQuery>
    <instanceCountQuery id="MemoryObjectInstanceCount" displayName="%MemoryObjectCountQuery">
      <instanceDbTable>memory_object_data::dd_memory_object</instanceDbTable>
    </instanceCountQuery>
    <xsl:if test="exsl:ctx('PMU','') = 'sniper'">
      <derivedQuery id="SniperPMULoads" displayName="%Loads">
        <valueType>count</valueType>
        <displayAttributes>
          <selfFormat>count</selfFormat>
        </displayAttributes>
        <description>%LoadsDescription</description>
        <valueEval>query(&quot;/PMUEventCount/PMUEventType[L1D_LOADS]&quot;)</valueEval>
        <confidenceEval>
          <![CDATA[ ( query("/PMUSampleCount") >= 10 ) && ( query("/Reliability") >= 0.5 ) ]]>
        </confidenceEval>
        <confidenceText>%PMUMetricConfidenceText</confidenceText>
      </derivedQuery>
      <derivedQuery id="SniperPMUStores" displayName="%Stores">
        <valueType>count</valueType>
        <displayAttributes>
          <selfFormat>count</selfFormat>
        </displayAttributes>
        <description>%StoresDescription</description>
        <valueEval>query(&quot;/PMUEventCount/PMUEventType[L1D_STORES]&quot;)</valueEval>
        <confidenceEval>
          <![CDATA[ ( query("/PMUSampleCount") >= 10 ) && ( query("/Reliability") >= 0.5 ) ]]>
        </confidenceEval>
        <confidenceText>%PMUMetricConfidenceText</confidenceText>
      </derivedQuery>
      <derivedQuery displayName="%L1Bound" id="SniperL1Bound">
          <queryInherit>/GeMetricBaseClockticks</queryInherit>
          <description>%L1BoundDescriptionAll</description>
          <helpKeyword>configs.l1bound_l1bounddescriptionall</helpKeyword>
          <valueEval>
              <![CDATA[ ( ( query("/PMUEventCount/PMUEventType[CYCLE_ACTIVITY.STALLS_MEM_ANY]") - query("/PMUEventCount/PMUEventType[CYCLE_ACTIVITY.STALLS_L1D_MISS]") ) / query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.REF]") )]]>
          </valueEval>
          <issueText>%L1BoundIssueTextAll</issueText>
          <issueEval>
              <![CDATA[ ( ( query("/SniperL1Bound") > 0.1 ) && ( query("/PMUHotspot") > 0.05 ) && ( query("/SniperMemBound") > 0.2 ) ) ]]>
          </issueEval>
          <confidenceEval>
              <![CDATA[( ( ( ( ( query("/PMUSampleCount/PMUEventType[CYCLE_ACTIVITY.STALLS_MEM_ANY]") >= 10 ) || ( query("/PMUSampleCount/PMUEventType[CYCLE_ACTIVITY.STALLS_L1D_MISS]") >= 10 ) ) && ( query("/PMUSampleCount/PMUEventType[CPU_CLK_UNHALTED.REF]") >= 10 ) ) ) && ( query("/Reliability") >= 0.5 ) ) ]]>
          </confidenceEval>
      </derivedQuery>
      <derivedQuery displayName="%L2Bound" id="SniperL2Bound">
          <queryInherit>/GeMetricBaseClockticks</queryInherit>
          <description>%L2BoundDescriptionAll</description>
          <helpKeyword>configs.l2bound_l2bounddescriptionall</helpKeyword>
          <valueEval>
            <![CDATA[ ( ( query("/PMUEventCount/PMUEventType[CYCLE_ACTIVITY.STALLS_L1D_MISS]") - query("/PMUEventCount/PMUEventType[CYCLE_ACTIVITY.STALLS_L2_MISS]") ) / query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.REF]") )]]>
          </valueEval>
          <issueText>%L2BoundIssueTextAll</issueText>
          <issueEval>
              <![CDATA[ ( ( query("/SniperL2Bound") > 0.1 ) && ( query("/PMUHotspot") > 0.05 ) && ( query("/SniperMemBound") > 0.2 ) ) ]]>
          </issueEval>
          <confidenceEval>
              <![CDATA[( ( ( ( ( query("/PMUSampleCount/PMUEventType[CYCLE_ACTIVITY.STALLS_L1D_MISS]") >= 10 ) || ( query("/PMUSampleCount/PMUEventType[CYCLE_ACTIVITY.STALLS_L2_MISS]") >= 10 ) ) && ( query("/PMUSampleCount/PMUEventType[CPU_CLK_UNHALTED.REF]") >= 10 ) ) ) && ( query("/Reliability") >= 0.5 ) ) ]]>
          </confidenceEval>
      </derivedQuery>
      <derivedQuery displayName="%L3Bound" id="SniperL3Bound">
          <queryInherit>/GeMetricBaseClockticks</queryInherit>
          <description>%L3BoundDescriptionAll</description>
          <helpKeyword>configs.l3bound_l3bounddescriptionall</helpKeyword>
          <valueEval>
            <![CDATA[ ( ( query("/PMUEventCount/PMUEventType[CYCLE_ACTIVITY.STALLS_L2_MISS]") - query("/PMUEventCount/PMUEventType[CYCLE_ACTIVITY.STALLS_L3_MISS]") ) / query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.REF]") )]]>
          </valueEval>
          <issueText>%L3BoundIssueTextAll</issueText>
          <issueEval>
              <![CDATA[ ( ( query("/SniperL3Bound") > 0.1 ) && ( query("/PMUHotspot") > 0.05 ) && ( query("/SniperMemBound") > 0.2 ) ) ]]>
          </issueEval>
          <confidenceEval>
              <![CDATA[ ( ( ( ( query("/PMUSampleCount/PMUEventType[CYCLE_ACTIVITY.STALLS_L2_MISS]") >= 10 ) || ( query("/PMUSampleCount/PMUEventType[CYCLE_ACTIVITY.STALLS_L3_MISS]") >= 10 ) ) && ( query("/PMUSampleCount/PMUEventType[CPU_CLK_UNHALTED.REF]") >= 10 ) ) && ( query("/Reliability") >= 0.5 )) ]]>
          </confidenceEval>
      </derivedQuery>
      <xsl:variable name="LLCStalsMiss">
          <xsl:choose>
            <xsl:when test="$sniperHasL3Cache='true'">CYCLE_ACTIVITY.STALLS_L3_MISS</xsl:when>
            <xsl:otherwise>CYCLE_ACTIVITY.STALLS_L2_MISS</xsl:otherwise>
          </xsl:choose>
      </xsl:variable>
      <derivedQuery displayName="%MCDRAMBound" id="SniperMCDRAMBound">
          <queryInherit>/GeMetricBaseClockticks</queryInherit>
          <description>%MCDRAMBoundDescriptionAll</description>
          <helpKeyword>configs.mcdrambound_mcdrambounddescriptionall</helpKeyword>
          <valueEval>
              <xsl:text><![CDATA[ ( ( query("/PMUEventCount/PMUEventType[CYCLE_ACTIVITY.STALLS_DRAM_CACHE_MISS]") - query("/PMUEventCount/PMUEventType[]]></xsl:text>
              <xsl:value-of select="$LLCStalsMiss"/>
              <xsl:text><![CDATA[]") ) / query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.REF]") )]]></xsl:text>
          </valueEval>
          <issueText>%MCDRAMBoundIssueTextAll</issueText>
          <issueEval>
              <![CDATA[ ( ( query("/SniperMCDRAMBound") > 0.1 ) && ( query("/PMUHotspot") > 0.05 ) && ( query("/SniperMemBound") > 0.2 ) ) ]]>
          </issueEval>
          <confidenceEval>
              <xsl:text><![CDATA[ ( ( ( ( query("/PMUSampleCount/PMUEventType[]]></xsl:text>
              <xsl:value-of select="$LLCStalsMiss"/>
              <xsl:text><![CDATA[]") >= 10 ) || ( query("/PMUSampleCount/PMUEventType[CYCLE_ACTIVITY.STALLS_DRAM_CACHE_MISS]") >= 10 ) ) && ( query("/PMUSampleCount/PMUEventType[CPU_CLK_UNHALTED.REF]") >= 10 ) ) && ( query("/Reliability") >= 0.5 )) ]]></xsl:text>
          </confidenceEval>
      </derivedQuery>
      <xsl:variable name="BeforeDRAMStallsMiss">
          <xsl:choose>
            <xsl:when test="$sniperHasDRAMCache='true'">CYCLE_ACTIVITY.STALLS_DRAM_CACHE_MISS</xsl:when>
            <xsl:otherwise><xsl:value-of select="$LLCStalsMiss"/></xsl:otherwise>
          </xsl:choose>
      </xsl:variable>
      <derivedQuery displayName="%DRAMBound" id="SniperDRAMBound">
          <queryInherit>/GeMetricBaseClockticks</queryInherit>
          <description>%DRAMBoundDescriptionAll</description>
          <helpKeyword>configs.drambound_drambounddescriptionall</helpKeyword>
          <valueEval>
              <xsl:text><![CDATA[ ( ( query("/PMUEventCount/PMUEventType[]]></xsl:text>
              <xsl:value-of select="$BeforeDRAMStallsMiss"/>
              <xsl:text><![CDATA[]") ) / query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.REF]") )]]></xsl:text>
          </valueEval>
          <issueText>%DRAMBoundIssueTextAll</issueText>
          <issueEval>
              <![CDATA[ ( ( query("/SniperDRAMBound") > 0.1 ) && ( query("/PMUHotspot") > 0.05 ) && ( query("/SniperMemBound") > 0.2 ) ) ]]>
          </issueEval>
          <confidenceEval>
              <xsl:text><![CDATA[ ( ( query("/PMUSampleCount/PMUEventType[]]></xsl:text>
              <xsl:value-of select="$BeforeDRAMStallsMiss"/>
              <xsl:text><![CDATA[]") >= 10 ) && ( query("/PMUSampleCount/PMUEventType[CPU_CLK_UNHALTED.REF]") >= 10 ) && ( query("/Reliability") >= 0.5 )) ]]></xsl:text>
          </confidenceEval>
      </derivedQuery>
      <derivedQuery displayName="%MemBound" id="SniperMemBound">
          <queryInherit>/GeMetricBaseClockticks</queryInherit>
          <description>%MemBoundDescriptionAll</description>
          <helpKeyword>configs.membound_membounddescriptionall</helpKeyword>
          <valueEval>
              <![CDATA[ ( ( query("/PMUEventCount/PMUEventType[CYCLE_ACTIVITY.STALLS_MEM_ANY]") ) / query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.REF]") )]]>
          </valueEval>
          <issueText>%DRAMBoundIssueTextAll</issueText>
          <issueEval>
            <![CDATA[ ( ( query("/PMUHotspot") > 0.05 ) && ( query("/SniperMemBound") > 0.2 ) ) ]]>
          </issueEval>
          <confidenceEval>
              <![CDATA[ ( ( query("/PMUSampleCount/PMUEventType[CYCLE_ACTIVITY.STALLS_MEM_ANY]") >= 10 ) && ( query("/PMUSampleCount/PMUEventType[CPU_CLK_UNHALTED.REF]") >= 10 ) && ( query("/Reliability") >= 0.5 ) ) ]]>
          </confidenceEval>
          <expand>
            <vectorQuery id="MemBoundHierarchy">
              <queryRef>/SniperL1Bound</queryRef>
              <queryRef>/SniperL2Bound</queryRef>
              <xsl:if test="$sniperHasL3Cache='true'">
                <queryRef>/SniperL3Bound</queryRef>
              </xsl:if>
              <xsl:if test="$sniperHasDRAMCache='true'">
                <queryRef>/SniperMCDRAMBound</queryRef>
              </xsl:if>
              <queryRef>/SniperDRAMBound</queryRef>
            </vectorQuery>
          </expand>
      </derivedQuery>
      <vectorQuery id="SniperMemoryAccessDataColumns">
        <queryRef>/SniperMemBound</queryRef>
        <queryRef>/SniperPMULoads</queryRef>
        <queryRef>/SniperPMUStores</queryRef>
        <queryRef>/LLCMissCount</queryRef>
      </vectorQuery>
    </xsl:if>
    <derivedQuery id="PMULoadsAndStores" displayName="%LoadsAndStores">
      <valueType>count</valueType>
      <boolean:valueSummable>true</boolean:valueSummable>
      <valueEval>
        <xsl:choose>
          <xsl:when test="exsl:ctx('PMU') = 'sniper'">
            <![CDATA[query("/L1DRequestsAny") + query("/L1DRequestsMiss")]]>
          </xsl:when>
          <xsl:otherwise>
            <![CDATA[query("/PMULoads") + query("/PMUStores")]]>
          </xsl:otherwise>
        </xsl:choose>
      </valueEval>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
    </derivedQuery>
    <vectorQuery id="PMUMemoryObjectGroupingQueries">
      <queryRef>/PMUMemoryObject</queryRef>
      <queryRef>/PMUMemoryObjectAllocationSource</queryRef>
      <queryRef>/PMUMemoryObjectStack</queryRef>
      <queryRef>/PMUCacheline</queryRef>
      <queryRef>/PMUDataAddress</queryRef>
    </vectorQuery>
    <derivedQuery id="MemBoundForHPCPC">
      <xsl:choose>
        <xsl:when test="(exsl:ctx('PMU') = 'knl')">
          <queryInherit>/BackendBoundPipelineSlots</queryInherit>
          <displayAttributes>
            <boolean:expand>true</boolean:expand>
            <boolean:allowCollapse>true</boolean:allowCollapse>
          </displayAttributes>
        </xsl:when>
        <xsl:otherwise>
          <queryInherit>/MemBound</queryInherit>
          <displayAttributes>
            <boolean:expand>false</boolean:expand>
            <boolean:allowCollapse>true</boolean:allowCollapse>
          </displayAttributes>
        </xsl:otherwise>
      </xsl:choose>
      <expand>
        <vectorQuery>
          <xsl:choose>
            <xsl:when test="(exsl:ctx('PMU') = 'knl')">
              <queryRef>/LLCHitKNL</queryRef>
              <queryRef>/LLCMissKNLHPC</queryRef>
            </xsl:when>
            <xsl:otherwise>
              <queryRef>/L1BoundNonGE</queryRef>
              <xsl:choose>
                <xsl:when test="($isHTOn = 'true') and (exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'haswell_server')">
                  <queryRef>/L3Latency</queryRef>
                </xsl:when>
                <xsl:otherwise>
                   <queryRef>/L2Bound</queryRef>
                   <queryRef>/L3Bound</queryRef>
                </xsl:otherwise>
              </xsl:choose>
              <queryRef>/DRAMBoundForHPCPC</queryRef>
              <queryRef>/StoresBound</queryRef>
              <xsl:if test="exsl:ctx('is3DXPPresent', 0) and not(exsl:ctx('is3DXP2LMMode', 0))">
                <queryRef>/3DXPointBoundGroup</queryRef>
              </xsl:if>
            </xsl:otherwise>
          </xsl:choose>
        </vectorQuery>
      </expand>
    </derivedQuery>
    <vectorQuery id="MemoryBoundGroupHPCPCSummary">
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'knl'">
          <queryRef>/LLCHitKNL</queryRef>
          <queryRef>/LLCMissKNLHPCGroup</queryRef>
          <xsl:choose>
            <xsl:when test="exsl:ctx('useCountingMode', 0)">
              <queryRef>/AverageDRAMBandwidth</queryRef>
              <xsl:choose>
                <xsl:when test="exsl:ctx('hbmMemoryMode', '') = ''">
                  <queryRef>/AverageMCDRAMCacheBandwidth</queryRef>
                  <queryRef>/AverageMCDRAMFlatBandwidth</queryRef>
                </xsl:when>
                <xsl:otherwise>
                  <queryRef>/AverageMCDRAMBandwidth</queryRef>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
              <queryRef>/MCDRAMCacheBandwidthBoundUncore</queryRef>
              <queryRef>/MCDRAMFlatBandwidthBoundUncore</queryRef>
              <queryRef>/MCDRAMBandwidthBoundUncore</queryRef>
              <queryRef>/DRAMBandwidthBoundUncore</queryRef>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <queryRef>/CacheBound</queryRef>
          <queryRef>/DRAMBoundGroupHPCPC</queryRef>
          <queryRef>/RemoteToLocalPercent</queryRef>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:if test="exsl:ctx('is3DXPPresent', 0) and not(exsl:ctx('is3DXP2LMMode', 0))">
        <queryRef>/3DXPointBoundGroupHPCSummary</queryRef>
      </xsl:if>
      <xsl:if test="exsl:ctx('is3DXP2LMMode', 1)">
        <queryRef>/2LMCacheHitRatioGroup</queryRef>
      </xsl:if>
    </vectorQuery>
    <derivedQuery id="DRAMBoundGroupMABigCoresSummary">
      <queryInherit>/DRAMBound</queryInherit>
      <xsl:choose>
        <xsl:when test="($isHTOn = 'true') and (exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'haswell_server')">
          <valueEval>$NULL</valueEval>
          <issueEval>$FALSE</issueEval>
          <displayAttributes>
            <boolean:expand>true</boolean:expand>
            <boolean:allowCollapse>false</boolean:allowCollapse>
          </displayAttributes>
          <expand>
            <vectorQuery id="DRAMBoundGroupMASummaryBigCoresExpanded">
              <xsl:if test="exsl:ctx('collectMemBandwidth', 0)">
                <queryRef>/DRAMBandwidthBoundUncoreMA</queryRef>
              </xsl:if>
              <xsl:if test="exsl:ctx('PMU') = 'ivybridge' or exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'broadwell' or exsl:ctx('PMU') = 'broadwell_de' or exsl:ctx('PMU') = 'broadwell_server' or exsl:ctx('PMU') = 'skylake' or exsl:ctx('PMU') = 'skylake_server' or exsl:ctx('PMU') = 'cascadelake_server'">
                <queryRef>/LLCMiss</queryRef>
              </xsl:if>
              <queryRef>/LocalDRAM</queryRef>
              <queryRef>/RemoteDRAM</queryRef>
              <queryRef>/RemoteCache</queryRef>
            </vectorQuery>
          </expand>
        </xsl:when>
        <xsl:otherwise>
          <displayAttributes>
            <boolean:expand>false</boolean:expand>
            <boolean:allowCollapse>true</boolean:allowCollapse>
          </displayAttributes>
          <expand>
            <vectorQuery id="DRAMBoundGroupMASummaryBigCoresExpanded">
              <xsl:choose>
                <xsl:when test="exsl:ctx('collectMemBandwidth', 0)">
                  <queryRef>/DRAMBandwidthBoundUncoreMA</queryRef>
                </xsl:when>
                <xsl:otherwise>
                  <queryRef>/MEMBandwidth</queryRef>
                </xsl:otherwise>
              </xsl:choose>
            </vectorQuery>
          </expand>
        </xsl:otherwise>
      </xsl:choose>
    </derivedQuery>
    <vectorQuery id="MemoryAccessSummaryColumns">
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'sniper'">
          <vectorQueryInsert>/SniperMemoryAccessDataColumns</vectorQueryInsert>
        </xsl:when>
        <xsl:otherwise>
          <derivedQuery id="MemBoundMemoryAccessSummary">
            <xsl:choose>
              <xsl:when test="(exsl:ctx('PMU') = 'knl' or exsl:ctx('PMU') = 'snb' or exsl:ctx('PMU') = 'snbep')">
                <xsl:attribute name="displayName">%MemBound</xsl:attribute>
                <valueEval>$NULL</valueEval>
                <issueEval>$FALSE</issueEval>
                <displayAttributes>
                  <boolean:expand>true</boolean:expand>
                  <boolean:allowCollapse>false</boolean:allowCollapse>
                </displayAttributes>
              </xsl:when>
              <xsl:when test="exsl:ctx('PMU') = 'silvermont' or exsl:ctx('PMU') = 'airmont' or exsl:ctx('PMU') = 'goldmont' or exsl:ctx('PMU') = 'goldmont_plus'">
                <queryInherit>/BackendBoundPipelineSlots</queryInherit>
                <displayAttributes>
                  <boolean:expand>false</boolean:expand>
                  <boolean:allowCollapse>true</boolean:allowCollapse>
                </displayAttributes>
              </xsl:when>
              <xsl:otherwise>
                <queryInherit>/MemBound</queryInherit>
                <issueText>%MemBoundIssueTextMA</issueText>
                <displayAttributes>
                  <boolean:expand>false</boolean:expand>
                  <boolean:allowCollapse>true</boolean:allowCollapse>
                </displayAttributes>
              </xsl:otherwise>
            </xsl:choose>
            <expand>
              <vectorQuery>
                <xsl:choose>
                  <xsl:when test="(exsl:ctx('PMU') = 'knl')">
                    <queryRef>/LLCHitRateKNL</queryRef>
                    <queryRef>/LLCHitKNL</queryRef>
                    <queryRef>/LLCMissKNLHPCGroup</queryRef>
                    <xsl:choose>
                      <xsl:when test="exsl:ctx('hbmMemoryMode', '') = ''">
                        <queryRef>/MCDRAMCacheBandwidthBoundUncore</queryRef>
                        <queryRef>/MCDRAMFlatBandwidthBoundUncore</queryRef>
                      </xsl:when>
                      <xsl:otherwise>
                        <queryRef>/MCDRAMBandwidthBoundUncore</queryRef>
                      </xsl:otherwise>
                    </xsl:choose>
                    <queryRef>/DRAMBandwidthBoundUncoreMA</queryRef>
                  </xsl:when>
                  <xsl:when test="(exsl:ctx('PMU') = 'snb' or exsl:ctx('PMU') = 'snbep')">
                    <queryRef>/LLCMiss</queryRef>
                    <queryRef>/LLCHit</queryRef>
                    <queryRef>/DRAMBandwidthBoundUncoreMA</queryRef>
                  </xsl:when>
                  <xsl:when test="exsl:ctx('PMU') = 'silvermont' or exsl:ctx('PMU') = 'airmont' or exsl:ctx('PMU') = 'goldmont' or exsl:ctx('PMU') = 'goldmont_plus'">
                    <derivedQuery displayName="%MemoryLatency" id="MemoryLatencyGridSection">
                        <valueEval>""</valueEval>
                        <valueType>string</valueType>
                        <displayAttributes>
                            <boolean:expand>true</boolean:expand>
                            <boolean:allowCollapse>false</boolean:allowCollapse>
                        </displayAttributes>
                        <expand>
                            <vectorQuery id="MemoryLatencyGridGroup">
                                <queryRef>/LLCMiss</queryRef>
                                <queryRef>/LLCHit</queryRef>
                                <queryRef>/DTLBOverhead</queryRef>
                                <queryRef>/DTLBStoreOverhead</queryRef>
                                <queryRef>/ContestedAccesses</queryRef>
                                <queryRef>/PageWalk</queryRef>
                                <queryRef>/BusLock</queryRef>
                                <queryRef>/LockLatency</queryRef>
                            </vectorQuery>
                        </expand>
                    </derivedQuery>
                    <derivedQuery displayName="%MemoryReissues" id="MemoryReissuesGridSection">
                        <valueEval>""</valueEval>
                        <valueType>string</valueType>
                        <displayAttributes>
                            <boolean:expand>true</boolean:expand>
                            <boolean:allowCollapse>false</boolean:allowCollapse>
                        </displayAttributes>
                        <expand>
                            <vectorQuery id="MemoryReissuesGridGroup">
                                <queryRef>/SplitLoads</queryRef>
                                <queryRef>/SplitStores</queryRef>
                                <queryRef>/LoadsBlockedbyStoreForwarding</queryRef>
                                <queryRef>/4KAliasing</queryRef>
                            </vectorQuery>
                        </expand>
                    </derivedQuery>
                    <queryRef>/DRAMBandwidthBoundUncoreMA</queryRef>
                  </xsl:when>
                  <xsl:otherwise>
                    <queryRef>/L1BoundNonGE</queryRef>
                    <xsl:choose>
                      <xsl:when test="($isHTOn = 'true') and (exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'haswell_server')">
                        <queryRef>/L3Latency</queryRef>
                      </xsl:when>
                      <xsl:otherwise>
                        <queryRef>/L2Bound</queryRef>
                        <queryRef>/L3Bound</queryRef>
                      </xsl:otherwise>
                    </xsl:choose>
                    <queryRef>/DRAMBoundGroupMABigCoresSummary</queryRef>
                    <queryRef>/StoresBound</queryRef>
                  </xsl:otherwise>
                </xsl:choose>
                <queryRef>/RemoteToLocalPercent</queryRef>
                <xsl:if test="exsl:ctx('collectMemBandwidth', 0)">
                  <xsl:choose>
                    <xsl:when test="(exsl:ctx('PMU') = 'snbep') or (exsl:ctx('PMU') = 'ivytown') or
                                    (exsl:ctx('PMU') = 'haswell_server') or (exsl:ctx('PMU') = 'broadwell_server')">
                      <queryRef>/QPIBandwidthBoundUncore</queryRef>
                    </xsl:when>
                    <xsl:otherwise>
                      <queryRef>/UPIUtilizationBound</queryRef>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:if>
                <xsl:if test="exsl:ctx('is3DXPPresent', 0) and not(exsl:ctx('is3DXP2LMMode', 0))">
                  <queryRef>/3DXPointBoundGroupSummary</queryRef>
                </xsl:if>
              </vectorQuery>
            </expand>
          </derivedQuery>
          <queryRef>/PMULoads</queryRef>
          <queryRef>/PMUStores</queryRef>
          <queryRef>/LLCMissCountGroup</queryRef>
          <xsl:if test="exsl:ctx('is3DXP2LMMode', 1)">
            <queryRef>/2LMCacheHitRatioGroup</queryRef>
          </xsl:if>
          <queryRef>/AvgLatency</queryRef>
          <xsl:if test="exsl:ctx('hbmMemoryMode', '') = '' or exsl:ctx('hbmMemoryMode', '') = 'Cache' or exsl:ctx('hbmMemoryMode', '') = 'Hybrid'">
            <queryRef>/MCDRAMHitRate</queryRef>
            <queryRef>/MCDRAMHitMRate</queryRef>
          </xsl:if>
        </xsl:otherwise>
      </xsl:choose>
    </vectorQuery>
    <derivedQuery id="MemBoundMemoryAccess">
      <xsl:choose>
        <xsl:when test="(exsl:ctx('PMU') = 'knl' or exsl:ctx('PMU') = 'snb' or exsl:ctx('PMU') = 'snbep')">
          <xsl:attribute name="displayName">%MemBound</xsl:attribute>
          <valueEval>$NULL</valueEval>
          <issueEval>$FALSE</issueEval>
          <displayAttributes>
            <boolean:expand>true</boolean:expand>
            <boolean:allowCollapse>false</boolean:allowCollapse>
          </displayAttributes>
        </xsl:when>
        <xsl:when test="exsl:ctx('PMU') = 'silvermont' or exsl:ctx('PMU') = 'airmont' or exsl:ctx('PMU') = 'goldmont' or exsl:ctx('PMU') = 'goldmont_plus'">
          <queryInherit>/BackendBoundPipelineSlots</queryInherit>
          <displayAttributes>
            <boolean:expand>false</boolean:expand>
            <boolean:allowCollapse>true</boolean:allowCollapse>
          </displayAttributes>
        </xsl:when>
        <xsl:otherwise>
          <queryInherit>/MemBound</queryInherit>
          <issueText>%MemBoundIssueTextMA</issueText>
          <displayAttributes>
            <boolean:expand>false</boolean:expand>
            <boolean:allowCollapse>true</boolean:allowCollapse>
          </displayAttributes>
        </xsl:otherwise>
      </xsl:choose>
      <expand>
        <vectorQuery>
          <xsl:choose>
            <xsl:when test="(exsl:ctx('PMU') = 'knl')">
              <queryRef>/LLCHitRateKNL</queryRef>
              <queryRef>/LLCHitKNL</queryRef>
              <queryRef>/LLCMissKNLHPC</queryRef>
              <xsl:choose>
                <xsl:when test="exsl:ctx('hbmMemoryMode', '') = ''">
                  <queryRef>/MCDRAMCacheBandwidthBoundUncore</queryRef>
                  <queryRef>/MCDRAMFlatBandwidthBoundUncore</queryRef>
                </xsl:when>
                <xsl:otherwise>
                  <queryRef>/MCDRAMBandwidthBoundUncore</queryRef>
                </xsl:otherwise>
              </xsl:choose>
              <queryRef>/DRAMBandwidthBoundUncoreMA</queryRef>
            </xsl:when>
            <xsl:when test="(exsl:ctx('PMU') = 'snb' or exsl:ctx('PMU') = 'snbep')">
              <queryRef>/LLCMiss</queryRef>
              <queryRef>/LLCHit</queryRef>
            </xsl:when>
            <xsl:when test="exsl:ctx('PMU') = 'silvermont' or exsl:ctx('PMU') = 'airmont' or exsl:ctx('PMU') = 'goldmont' or exsl:ctx('PMU') = 'goldmont_plus'">
              <derivedQuery displayName="%MemoryLatency" id="MemoryLatencyGridSection">
                  <valueEval>""</valueEval>
                  <valueType>string</valueType>
                  <displayAttributes>
                      <boolean:expand>true</boolean:expand>
                      <boolean:allowCollapse>false</boolean:allowCollapse>
                  </displayAttributes>
                  <expand>
                      <vectorQuery id="MemoryLatencyGridGroup">
                          <queryRef>/LLCMiss</queryRef>
                          <queryRef>/LLCHit</queryRef>
                          <queryRef>/DTLBOverhead</queryRef>
                          <queryRef>/DTLBStoreOverhead</queryRef>
                          <queryRef>/ContestedAccesses</queryRef>
                          <queryRef>/PageWalk</queryRef>
                          <queryRef>/BusLock</queryRef>
                          <queryRef>/LockLatency</queryRef>
                      </vectorQuery>
                  </expand>
              </derivedQuery>
              <derivedQuery displayName="%MemoryReissues" id="MemoryReissuesGridSection">
                  <valueEval>""</valueEval>
                  <valueType>string</valueType>
                  <displayAttributes>
                      <boolean:expand>true</boolean:expand>
                      <boolean:allowCollapse>false</boolean:allowCollapse>
                  </displayAttributes>
                  <expand>
                      <vectorQuery id="MemoryReissuesGridGroup">
                          <queryRef>/SplitLoads</queryRef>
                          <queryRef>/SplitStores</queryRef>
                          <queryRef>/LoadsBlockedbyStoreForwarding</queryRef>
                          <queryRef>/4KAliasing</queryRef>
                      </vectorQuery>
                  </expand>
              </derivedQuery>
            </xsl:when>
            <xsl:otherwise>
              <xsl:if test="(exsl:ctx('PMU') != 'snb' and exsl:ctx('PMU') != 'snbep')">
                <queryRef>/L1BoundNonGE</queryRef>
              </xsl:if>
              <xsl:choose>
                <xsl:when test="($isHTOn = 'true') and (exsl:ctx('PMU') = 'haswell' or exsl:ctx('PMU') = 'crystalwell' or exsl:ctx('PMU') = 'haswell_server')">
                  <queryRef>/L3Latency</queryRef>
                </xsl:when>
                <xsl:otherwise>
                   <queryRef>/L2Bound</queryRef>
                   <queryRef>/L3Bound</queryRef>
                </xsl:otherwise>
              </xsl:choose>
              <queryRef>/DRAMBoundGroupHPC</queryRef>
              <queryRef>/StoresBound</queryRef>
              <xsl:if test="exsl:ctx('is3DXPPresent', 0) and not(exsl:ctx('is3DXP2LMMode', 0))">
                <queryRef>/3DXPointBoundGroup</queryRef>
              </xsl:if>
            </xsl:otherwise>
          </xsl:choose>
        </vectorQuery>
      </expand>
    </derivedQuery>
    <vectorQuery id="MemoryAccessDataColumns">
      <xsl:choose>
        <xsl:when test="exsl:ctx('PMU') = 'sniper'">
          <vectorQueryInsert>/SniperMemoryAccessDataColumns</vectorQueryInsert>
        </xsl:when>
        <xsl:otherwise>
          <queryRef>/MemBoundMemoryAccess</queryRef>
          <queryRef>/PMULoads</queryRef>
          <queryRef>/PMUStores</queryRef>
          <queryRef>/LLCMissCountGroup</queryRef>
          <xsl:if test="exsl:ctx('PMU') = 'knl'">
            <queryRef>/LLCInputRequestsPrefetcherKNL</queryRef>
          </xsl:if>
          <queryRef>/AvgLatency</queryRef>
          <xsl:if test="exsl:ctx('hbmMemoryMode', '') = '' or exsl:ctx('hbmMemoryMode', '') = 'Cache' or exsl:ctx('hbmMemoryMode', '') = 'Hybrid'">
            <queryRef>/MCDRAMHitRate</queryRef>
            <queryRef>/MCDRAMHitMRate</queryRef>
          </xsl:if>
        </xsl:otherwise>
      </xsl:choose>
    </vectorQuery>
  </queryLibrary>
</bag>
