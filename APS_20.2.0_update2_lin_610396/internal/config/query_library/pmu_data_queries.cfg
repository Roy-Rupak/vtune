<?xml version="1.0" encoding="UTF-8"?>
<!--

 Copyright Â© 2009-2020 Intel Corporation. All rights reserved.

 The information contained herein is the exclusive property of
 Intel Corporation and may not be disclosed, examined, or reproduced in
 whole or in part without explicit written authorization from the Company.

-->
<bag
  xmlns:boolean="http://www.w3.org/2001/XMLSchema#boolean"
  xmlns:byte="http://www.w3.org/2001/XMLSchema#byte"
  xmlns:short="http://www.w3.org/2001/XMLSchema#short"
  xmlns:int="http://www.w3.org/2001/XMLSchema#int"
  xmlns:long="http://www.w3.org/2001/XMLSchema#long"
  xmlns:unsignedByte="http://www.w3.org/2001/XMLSchema#unsignedByte"
  xmlns:unsignedShort="http://www.w3.org/2001/XMLSchema#unsignedShort"
  xmlns:unsignedInt="http://www.w3.org/2001/XMLSchema#unsignedInt"
  xmlns:unsignedLong="http://www.w3.org/2001/XMLSchema#unsignedLong"
  xmlns:float="http://www.w3.org/2001/XMLSchema#float"
  xmlns:double="http://www..org/2001/XMLSchema#double"
  xmlns:null="http://www.intel.com/2009/BagSchema#null"
  xmlns:blob="http://www.intel.com/2009/BagSchema#blob"
  >
  <queryLibrary xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:exsl="http://exslt.org/common" exsl:keep_exsl_namespace="">
    <infoQuery id="PMUPackageFrequency" displayName="%PackageFrequency">
      <dbPath>pmu_data::dd_sample.cpu.core.package</dbPath>
      <displayDbPathSuffix>freq_hz</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="PMUEventType" displayName="%PMUEventType">
      <dbPath>pmu_data::dd_sample.event_type.name</dbPath>
      <displayDbPathSuffix>value</displayDbPathSuffix>
      <helpKeywordCalcPolicy>PMUEventHelpKeywordPolicy</helpKeywordCalcPolicy>
      <displayAttributes>
        <boolean:unitDistinctQuery>true</boolean:unitDistinctQuery>
      </displayAttributes>
      <confidenceTemplate><![CDATA[ ( ( ($useCountingMode || $useAggregatedCounting) ? 1 : ( query("/PMUSampleCount") >= 10 ) ) ) && ( query("/Reliability") >= 0.7 ) ]]></confidenceTemplate>
    </infoQuery>
    <infoQuery id="PMUEventTypeDistinct" displayName="%PMUEventType">
      <queryInherit>/PMUEventType</queryInherit>
      <dbPath>pmu_data::dd_sample.event_type</dbPath>
      <displayDbPathSuffix>name.value</displayDbPathSuffix>
    </infoQuery>
    <countQuery id="IPTBBEventCount" displayName="%PMUEventCount">
      <instanceDbTable>pmu_data_details::dd_sample</instanceDbTable>
      <displayAttributes>
        <selfFormat>count</selfFormat>
        <totalFormat>countAndBar</totalFormat>
        <boolean:allowCollapse>false</boolean:allowCollapse>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
	  <instanceBandTable>ipt_details_grouper</instanceBandTable>
    </countQuery>
	<instanceCountQuery id="IPTBBSampleCount" displayName="%PMUSampleCount">
      <instanceDbTable>pmu_data_details::dd_sample</instanceDbTable>
      <displayAttributes>
        <selfFormat>count</selfFormat>
        <totalFormat>countAndBar</totalFormat>
        <boolean:allowCollapse>false</boolean:allowCollapse>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
	  <instanceBandTable>ipt_details_grouper</instanceBandTable>
    </instanceCountQuery>
    <infoQuery id="IPTBBEventType" displayName="%PMUEventType">
      <dbPath>pmu_data_details::dd_sample.event_type.name</dbPath>
      <displayDbPathSuffix>value</displayDbPathSuffix>
      <helpKeywordCalcPolicy>PMUEventHelpKeywordPolicy</helpKeywordCalcPolicy>
      <displayAttributes>
        <boolean:unitDistinctQuery>true</boolean:unitDistinctQuery>
      </displayAttributes>
      <confidenceTemplate><![CDATA[ ( query("/IPTBBSampleCount") >= 10 ) && ( query("/Reliability") >= 0.5 ) ]]></confidenceTemplate>
    </infoQuery>
    <infoQuery id="PMUEventsPerSample" displayName="%PMUEventsPerSample">
      <dbPath>pmu_data::dd_sample.event_type</dbPath>
      <displayDbPathSuffix>events_per_sample</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="IsPrecise">
      <dbPath>pmu_data::dd_sample.event_type</dbPath>
      <displayDbPathSuffix>is_precise</displayDbPathSuffix>
    </infoQuery>
    <derivedQuery id="PMUEventIsPrecise" displayName="%PMUEventIsPrecise">
      <valueEval><![CDATA[ query("/IsPrecise") == 1 ? "%True" : ( query("/IsPrecise") == 0 ? "%False" : "" ) ]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <infoQuery id="PMUEventCoreType" displayName="%CoreType">
      <dbPath>pmu_data::dd_sample.event_type</dbPath>
      <displayDbPathSuffix>core_type.name</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="PMUTsxAbortReason" displayName="%PMUTsxAbortReason">
      <dbPath>pmu_data::dd_sample.tsx_info.abort_reason</dbPath>
      <displayDbPathSuffix>name</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="PMUTsxAbortCycles" displayName="%PMUTsxAbortCycles">
      <dbPath>pmu_data::dd_sample.tsx_info.abort_cycles</dbPath>
    </infoQuery>
    <infoQuery id="PMULoadLatency" displayName="%LoadLatency">
      <dbPath>pmu_data::dd_sample.mem_access.latency</dbPath>
    </infoQuery>
    <infoQuery id="PMUCacheline" displayName="%Cacheline">
      <dbPath>pmu_data::dd_sample.mem_access.cache_line</dbPath>
      <displayAttributes>
        <format>hex</format>
      </displayAttributes>
      <valueType>uint</valueType>
    </infoQuery>
    <infoQuery id="PMUDataAddress" displayName="%DataAddress">
      <dbPath>pmu_data::dd_sample.mem_access.virt_addr</dbPath>
      <displayAttributes>
        <format>hex</format>
      </displayAttributes>
      <valueType>uint</valueType>
    </infoQuery>
    <infoQuery id="MemoryObjectType" displayName="%MemoryObjectType">
      <dbPath>memory_object_data::dd_memory_object.object_info.type</dbPath>
      <displayDbPathSuffix>name</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="MemoryObjectAddress" displayName="%MemoryObjectAddress">
      <dbPath>memory_object_data::dd_memory_object</dbPath>
      <displayDbPathSuffix>address</displayDbPathSuffix>
      <displayAttributes>
        <format>hex</format>
      </displayAttributes>
      <valueType>uint</valueType>
    </infoQuery>
    <infoQuery id="MemoryObjectSize" displayName="%MemoryObjectSize">
      <dbPath>memory_object_data::dd_memory_object.object_info</dbPath>
      <displayDbPathSuffix>size</displayDbPathSuffix>
    </infoQuery>
    <infoQuery id="MemoryObjectAllocSourceFile" displayName="%SourceFile">
      <dbPath>memory_object_data::dd_memory_object.object_info.alloc_cs.code_loc.src_loc.src_file</dbPath>
      <displayDbPathSuffix>name</displayDbPathSuffix>
      <aliasForUnknown>%AliasUnknownSourceFile</aliasForUnknown>
    </infoQuery>
    <infoQuery id="MemoryObjectAllocSourceLocationSourceLine" displayName="%SourceLine">
      <dbPath>memory_object_data::dd_memory_object.object_info.alloc_cs.code_loc.src_loc</dbPath>
      <displayDbPathSuffix>line</displayDbPathSuffix>
      <aliasForUnknown>%AliasUnknownSourceFile</aliasForUnknown>
    </infoQuery>
    <infoQuery id="MemoryObjectAllocSourceLocationSourceFile" displayName="%MemoryObjectSourceLocationSourceFile">
      <dbPath>memory_object_data::dd_memory_object.object_info.alloc_cs.code_loc.src_loc</dbPath>
      <displayDbPathSuffix>src_file.name</displayDbPathSuffix>
      <aliasForUnknown>%AliasUnknownSourceFile</aliasForUnknown>
    </infoQuery>
    <infoQuery id="MemoryObjectAllocCallstack" displayName="%MemoryObjectAllocCallstack">
      <dbPath>memory_object_data::dd_memory_object.object_info.alloc_cs</dbPath>
      <displayDbPathSuffix>code_loc.func_range.func_inst.function.name</displayDbPathSuffix>
      <parentDbPathSuffix>parent</parentDbPathSuffix>
      <mergeDbPathSuffix>code_loc.func_range.func_inst</mergeDbPathSuffix>
      <attributionDbPathSuffix>bottom_user_cs</attributionDbPathSuffix>
      <aliasForUnknown>%AliasUnknownCallStack</aliasForUnknown>
    </infoQuery>
    <countQuery id="PMUEventCount" displayName="%PMUEventCount">
      <instanceDbTable>pmu_data::dd_sample</instanceDbTable>
      <displayAttributes>
        <selfFormat>count</selfFormat>
        <totalFormat>countAndBar</totalFormat>
        <boolean:allowCollapse>false</boolean:allowCollapse>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </countQuery>
    <countQuery id="PMUEventCountForGPUPacketStage" displayName="%PMUEventCount">
      <queryInherit>/PMUEventCount</queryInherit>
      <instanceBandTable>gpu_packet_stage_grouper</instanceBandTable>
    </countQuery>
    <countQuery id="PMUEventCountForMemoryObjects">
      <queryInherit>/PMUEventCount</queryInherit>
      <joinGroupInstanceDbTable>memory_object_data</joinGroupInstanceDbTable>
    </countQuery>
    <countQuery id="PMUEventCountForIstp">
      <queryInherit>/PMUEventCount</queryInherit>
      <joinGroupInstanceDbTable>istp_task_state_data_grouper</joinGroupInstanceDbTable>
    </countQuery>
    <countQuery id="GlobalPMUEventCount" displayName="%PMUEventCount">
      <queryInherit>/PMUEventCount</queryInherit>
      <instanceBandTable>global_time_interval_metrics</instanceBandTable>
    </countQuery>
    <countQuery id="MemoryObjectAllocBytes" displayName="%MemoryObjectAllocBytes">
      <instanceDbTable>memory_object_data::dd_memory_object</instanceDbTable>
      <instanceBandTable>memory_object_data_grouper</instanceBandTable>
    </countQuery>
    <infoQuery id="PMUSample" displayName="%PMUSample">
      <dbPath>pmu_data::dd_sample</dbPath>
      <displayAttributes>
        <align>bottom</align>
        <marker>end</marker>
        <timelineGraphColor>100,150,80</timelineGraphColor>
      </displayAttributes>
    </infoQuery>
    <instanceCountQuery id="PMUSampleCount" displayName="%PMUSampleCount">
      <instanceDbTable>pmu_data::dd_sample</instanceDbTable>
      <displayAttributes>
        <selfFormat>count</selfFormat>
        <totalFormat>countAndBar</totalFormat>
        <boolean:allowCollapse>false</boolean:allowCollapse>
        <boolean:detailedFormulaDisplayRepresentation>false</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </instanceCountQuery>
    <derivedQuery id="PMUOverheadTimeIssueFormula">
      <valueEval><![CDATA[ (query("/PMUOverheadTime") > (query("/RefTime") * .10)) && ((query("/PMUOverheadTime") / queryAll("/RefTime", true)) > .05) ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="PMUOverheadTime" displayName="%OverheadTime">
      <helpKeyword>configs.overheadtime_overheadtimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RefTime/PMUTypeCsFunctionType[%Overhead]") + queryOptional("/RefTime/PMUTypeCsFunctionType[%SystemOverhead]") + queryOptional("/RefTime/PMUTypeCsFunctionType[%Executor]") ]]></valueEval>
      <valueType>time</valueType>
      <issueEval><![CDATA[ query("/PMUOverheadTimeIssueFormula") ]]></issueEval>
      <issueText>%OverheadTimeIssueText</issueText>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <description>%OverheadTimeDescription</description>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
    </derivedQuery>
    <derivedQuery id="PMUSpinTimeIssueFormula">
      <valueEval><![CDATA[ (query("/PMUSpinTime") > (query("/RefTime") * .10)) && ((query("/PMUSpinTime") / queryAll("/RefTime", true)) > .05) ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="PMUSpinTime" displayName="%SpinTime">
      <helpKeyword>configs.spintime_spintimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RefTime/PMUTypeCsFunctionType[%Sync]") ]]></valueEval>
      <valueType>time</valueType>
      <issueEval><![CDATA[ query("/PMUSpinTimeIssueFormula") ]]></issueEval>
      <issueText>%SpinTimeIssueText</issueText>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <description>%SpinTimeDescription</description>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnBarrierTimeIssueFormula">
      <valueEval><![CDATA[ (query("/PMUSpinBusyWaitOnBarrierTime") > (query("/RefTime") * .10)) && ((query("/PMUSpinBusyWaitOnBarrierTime") / queryAll("/RefTime", true)) > .05) ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnBarrierTime" displayName="%SpinBusyWaitOnBarrierTime">
      <helpKeyword>configs.spinbusywaitonbarriertime_spinbusywaitonbarriertimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RefTime/PMUTypeCsFunctionSubtype[%BusyWaitOnBarrier]") ]]></valueEval>
      <valueType>time</valueType>
      <issueEval><![CDATA[ query("/PMUSpinBusyWaitOnBarrierTimeIssueFormula") ]]></issueEval>
      <issueText>%SpinBusyWaitOnBarrierTimeIssueText</issueText>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <description>%SpinBusyWaitOnBarrierTimeDescription</description>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnBarrierWallTime" displayName="%SpinBusyWaitOnBarrierWallTime">
      <helpKeyword>configs.spinbusywaitonbarrierwalltime_spinbusywaitonbarrierwalltimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/PMUSpinBusyWaitOnBarrierTime") / query("/OpenMPThreadCount") ]]></valueEval>
      <valueType>time</valueType>
      <description>%SpinBusyWaitOnBarrierWallTimeDescription</description>
      <issueEval><![CDATA[ (query("/PMUSpinBusyWaitOnBarrierWallTime") > (query("/TotalElapsedTimeNoPause") * .10)) * ((query("/RefTime") / queryAll("/RefTime", true)) > .05) ]]></issueEval>
      <issueText>%SpinBusyWaitOnBarrierTimeIssueText</issueText>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnBarrierWallTimeForSummary">
      <queryInherit>/PMUSpinBusyWaitOnBarrierWallTime</queryInherit>
      <valueEval><![CDATA[ query("/PMUSpinBusyWaitOnBarrierTime") / query("/TotalOpenMPThreadCount") ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnLockTimeIssueFormula">
      <valueEval><![CDATA[ (query("/PMUSpinBusyWaitOnLockTime") > (query("/RefTime") * .10)) && ((query("/PMUSpinBusyWaitOnLockTime") / queryAll("/RefTime", true)) > .05) ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnLockTime" displayName="%SpinBusyWaitOnLockTime">
      <helpKeyword>configs.spinbusywaitonlocktime_spinbusywaitonlocktimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RefTime/PMUTypeCsFunctionSubtype[%BusyWaitOnLock]") ]]></valueEval>
      <valueType>time</valueType>
      <issueEval><![CDATA[ query("/PMUSpinBusyWaitOnLockTimeIssueFormula") ]]></issueEval>
      <issueText>%SpinBusyWaitOnLockTimeIssueText</issueText>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <description>%SpinBusyWaitOnLockTimeDescription</description>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnLockWallTime" displayName="%SpinBusyWaitOnLockWallTime">
      <helpKeyword>configs.spinbusywaitonlockwalltime_spinbusywaitonlockwalltimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/PMUSpinBusyWaitOnLockTime") / query("/OpenMPThreadCount")  + query("/ProcessElapsedTime") - query("/ProcessElapsedTime") ]]></valueEval>
      <valueType>time</valueType>
      <description>%SpinBusyWaitOnLockWallTimeDescription</description>
      <issueEval><![CDATA[ (query("/PMUSpinBusyWaitOnLockWallTime") > (query("/TotalElapsedTimeNoPause") * .10)) ]]></issueEval>
      <issueText>%SpinBusyWaitOnLockTimeIssueText</issueText>
      <confidenceEval><![CDATA[ query("/ClocktickSamples") >= 10 * query("/OpenMPThreadCount") ]]></confidenceEval>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
      </displayAttributes>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnLockWallTimePercentsElapsed" displayName="%SpinBusyWaitOnLockTimePercentsElapsed">
      <helpKeyword>configs.spinbusywaitonlocktimepercentselapsed_spinbusywaitonlockwalltimepercentselapseddescription</helpKeyword>
      <xsl:choose>
        <xsl:when test="(exsl:ctx('openmpProcessCount') = 1)">
          <valueEval><![CDATA[ query("/PMUSpinBusyWaitOnLockWallTime") / query("/TotalElapsedTimeNoPause")]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/PMUSpinBusyWaitOnLockWallTime") * 10000000000.0 / (query("/ProcessEndTsc") - query("/ProcessStartTsc") + 1)]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <valueType>ratio</valueType>
      <minEval>0</minEval>
      <description>%SpinBusyWaitOnLockWallTimePercentsElapsedDescription</description>
      <issueEval><![CDATA[ (query("/PMUSpinBusyWaitOnLockWallTime") > (query("/TotalElapsedTimeNoPause") * .10)) ]]></issueEval>
      <issueText>%SpinBusyWaitOnLockTimeIssueText</issueText>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnLockWallTimeForSummary">
      <queryInherit>/PMUSpinBusyWaitOnLockWallTime</queryInherit>
      <valueEval><![CDATA[ query("/PMUSpinBusyWaitOnLockTime") / query("/TotalOpenMPThreadCount") ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnMPISpinningTimePerProcess" displayName="%SpinBusyWaitOnMPISpinningTime2">
      <helpKeyword>configs.spinbusywaitonmpispinningtime_spinbusywaitonmpispinningtimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RefTime/PMUTypeCsFunctionSubtype[%MPISpinning]") + query("/ProcessElapsedTime") - query("/ProcessElapsedTime") ]]></valueEval>
      <valueType>time</valueType>
      <issueEval><![CDATA[ (query("/PMUSpinBusyWaitOnMPISpinningTime") > (queryAll("/GlobalElapsedTime", true) * .10)) ]]></issueEval>
      <issueText>%SpinBusyWaitOnMPISpinningTimeIssueText</issueText>
      <description>%SpinBusyWaitOnMPISpinningTimeDescription</description>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnMPISpinningTimePerProcessSummary" displayName="%SpinBusyWaitOnMPISpinningTime2">
      <helpKeyword>configs.spinbusywaitonmpispinningtime_spinbusywaitonmpispinningtimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RefTime/PMUTypeCsFunctionSubtype[%MPISpinning]") ]]></valueEval>
      <valueType>time</valueType>
      <issueEval><![CDATA[ (query("/PMUSpinBusyWaitOnMPISpinningTime") > (queryAll("/GlobalElapsedTime", true) * .10)) ]]></issueEval>
      <issueText>%SpinBusyWaitOnMPISpinningTimeIssueText</issueText>
      <description>%SpinBusyWaitOnMPISpinningTimeDescription</description>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnMPISpinningTime" displayName="%SpinBusyWaitOnMPISpinningTime2">
      <helpKeyword>configs.spinbusywaitonmpispinningtime_spinbusywaitonmpispinningtimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RefTime/PMUTypeCsFunctionSubtype[%MPISpinning]") ]]></valueEval>
      <valueType>time</valueType>
      <issueEval><![CDATA[ (query("/PMUSpinBusyWaitOnMPISpinningTime") > (query("/TotalElapsedTimeNoPause") * .20)) ]]></issueEval>
      <issueText>%SpinBusyWaitOnMPISpinningTimeIssueText</issueText>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <description>%SpinBusyWaitOnMPISpinningTimeDescription</description>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnMPISpinningTimeForTimeline" displayName="%SpinBusyWaitOnMPISpinningTimeForTimeline">
      <helpKeyword>configs.spinbusywaitonmpispinningtimefortimeline_spinbusywaitonmpispinningtimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RefTime/PMUTypeCsFunctionSubtype[%MPISpinning]")]]></valueEval>
      <valueType>time</valueType>
      <description>%SpinBusyWaitOnMPISpinningTimeDescription</description>
      <displayAttributes>
        <timelineGraphColor>255,242,0</timelineGraphColor>
        <minimumResolutionms>0</minimumResolutionms>
        <selfFormat>timeAndBar</selfFormat>
        <totalFormat>percentAndBar</totalFormat>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <timelineObjectType>interval</timelineObjectType>
        <timeScalems>1000</timeScalems>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnMPISpinningTimeGlobal">
      <queryInherit>/PMUSpinBusyWaitOnMPISpinningTimeForTimeline</queryInherit>
      <maxEval>$logicalCPUCount * 100</maxEval>
    </derivedQuery>
    <derivedQuery id="PMUSpinBusyWaitOnMPISpinningTimePercentElapsed" displayName="%SpinBusyWaitOnMPISpinningTimePercentElapsed">
      <helpKeyword>configs.spinbusywaitonmpispinningtimepercentelapsed_spinbusywaitonmpispinningtimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RefTime/PMUTypeCsFunctionSubtype[%MPISpinning]") / query("/ProcessElapsedTime") ]]></valueEval>
      <valueType>ratio</valueType>
      <issueEval><![CDATA[ (query("/PMUSpinBusyWaitOnMPISpinningTime") > (query("/TotalElapsedTimeNoPause") * .20)) ]]></issueEval>
      <issueText>%SpinBusyWaitOnMPISpinningTimeIssueText</issueText>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <description>%SpinBusyWaitOnMPISpinningTimeDescription</description>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:canBeDoi>false</boolean:canBeDoi>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="PMUSpinOtherTime" displayName="%SpinOtherTime">
      <helpKeyword>configs.spinothertime_spinothertimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/PMUSpinTime") - queryOptional("/RefTime/PMUTypeCsFunctionSubtype[%BusyWaitOnBarrier]") - queryOptional("/RefTime/PMUTypeCsFunctionSubtype[%BusyWaitOnLock]") - queryOptional("/RefTime/PMUTypeCsFunctionSubtype[%MPISpinning]")]]></valueEval>
      <valueType>time</valueType>
      <description>%SpinOtherTimeDescription</description>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <minEval>0</minEval>
    </derivedQuery>
    <derivedQuery id="PMUSpinOtherWallTime" displayName="%SpinOtherTime">
      <helpKeyword>configs.spinothertime_spinothertimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/PMUSpinOtherTime") / query("/OpenMPThreadCount") ]]></valueEval>
      <valueType>time</valueType>
      <description>%SpinOtherTimeDescription</description>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
      </displayAttributes>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
    </derivedQuery>
    <derivedQuery id="PMUSpinOtherWallTimeForSummary">
      <queryInherit>/PMUSpinOtherWallTime</queryInherit>
      <valueEval><![CDATA[ query("/PMUSpinOtherTime") / query("/TotalOpenMPThreadCount") ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="PMUSpinOverheadOtherWallTime" displayName="%OverheadOtherTime">
      <helpKeyword>configs.overheadothertime_spinoverheadothertimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/PMUOverheadOtherWallTime") + query("/PMUSpinOtherWallTime")  + query("/ProcessElapsedTime") - query("/ProcessElapsedTime") ]]></valueEval>
      <valueType>time</valueType>
      <description>%SpinOverheadOtherTimeDescription</description>
      <confidenceEval><![CDATA[ query("/ClocktickSamples") >= 10 * query("/OpenMPThreadCount") ]]></confidenceEval>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
      </displayAttributes>
      <percentBases>
        <queryRef>/FullProcessElapsedTime</queryRef>
      </percentBases>
    </derivedQuery>
    <derivedQuery id="PMUSpinOverheadOtherWallTimePercentsElapsed" displayName="%OverheadOtherTimePercentsElapsed">
      <helpKeyword>configs.overheadothertimepercentselapsed_spinoverheadothertimepercentselapseddescription</helpKeyword>
      <xsl:choose>
        <xsl:when test="(exsl:ctx('openmpProcessCount') = 1)">
          <valueEval><![CDATA[ query("/PMUSpinOverheadOtherWallTime") / query("/TotalElapsedTimeNoPause")]]></valueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval><![CDATA[ query("/PMUSpinOverheadOtherWallTime") * 10000000000.0 / (query("/ProcessEndTsc") - query("/ProcessStartTsc") + 1)]]></valueEval>
        </xsl:otherwise>
      </xsl:choose>
      <valueType>ratio</valueType>
      <minEval>0</minEval>
      <description>%SpinOverheadOtherTimePercentsElapsedDescription</description>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <boolean:vtNullAsZero>false</boolean:vtNullAsZero>
        <boolean:disableFormulaDescription>true</boolean:disableFormulaDescription>
      </displayAttributes>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
    </derivedQuery>
    <derivedQuery id="PMUSpinOverheadOtherWallTimeForSummary">
      <queryInherit>/PMUSpinOverheadOtherWallTime</queryInherit>
      <valueEval><![CDATA[ query("/PMUOverheadOtherWallTimeForSummary") + query("/PMUSpinOtherWallTimeForSummary") ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="PMUOverheadAndSpinTime" displayName="%SpinAndOverheadTime">
      <helpKeyword>configs.spinandoverheadtime_overheadtimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/PMUOverheadTime")  + query("/PMUSpinTime") ]]></valueEval>
      <valueType>time</valueType>
      <issueEval><![CDATA[ query("/PMUOverheadAndSpinTime") > (query("/RefTime") * .10) ]]></issueEval>
      <issueText>%OverheadTimeIssueText</issueText>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <description>%OverheadTimeDescription</description>
      <displayAttributes>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <minimumResolutionms>0</minimumResolutionms>
        <timelineGraphColor>231,73,17</timelineGraphColor>
        <timelineObjectType>interval</timelineObjectType>
        <timeScalems>1000</timeScalems>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="PMUOverheadAndSpinTimeWithSummaryIssues" displayName="%SpinAndOverheadTime">
      <queryInherit>/PMUTimeSummary</queryInherit>
      <helpKeyword>configs.spinandoverheadtime_overheadtimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/PMUOverheadTime")  + query("/PMUSpinTime") ]]></valueEval>
      <valueType>time</valueType>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
      <description>%OverheadTimeDescription</description>
    </derivedQuery>
    <derivedQuery id="PMUOverheadAndSpinTimePercentage" displayName="%SpinAndOverheadTimePercentage">
      <queryInherit>/PMUOverheadAndSpinTimeWithSummaryIssues</queryInherit>
      <valueEval><![CDATA[ query("/PMUOverheadAndSpinTime") / queryAll("/RefTime", true) ]]></valueEval>
      <valueType>ratio</valueType>
    </derivedQuery>
    <derivedQuery id="PMUOverheadAndSpinTimeString" displayName="%SpinAndOverheadTime">
      <queryInherit>/PMUOverheadAndSpinTimeWithSummaryIssues</queryInherit>
      <valueEval><![CDATA[ t#query("/PMUOverheadAndSpinTime")  + " (" + %#query("/PMUOverheadAndSpinTimePercentage") + " of CPU Time)"]]></valueEval>
      <valueType>string</valueType>
    </derivedQuery>
    <derivedQuery id="PMUUserTime" displayName="%UserTime">
      <helpKeyword>configs.usertime_usertimedescription</helpKeyword>
      <valueEval><![CDATA[ query("/RefTime") - queryOptional("/PMUOverheadAndSpinTime")]]></valueEval>
      <description>%UserTimeDescription</description>
      <valueType>time</valueType>
      <displayAttributes>
        <timelineGraphColor>6,249,13</timelineGraphColor>
        <minimumResolutionms>0</minimumResolutionms>
        <selfFormat>timeAndBar</selfFormat>
        <totalFormat>percentAndBar</totalFormat>
        <boolean:detailedFormulaDisplayRepresentation>true</boolean:detailedFormulaDisplayRepresentation>
        <timelineObjectType>interval</timelineObjectType>
        <timeScalems>1000</timeScalems>
      </displayAttributes>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
    </derivedQuery>
    <derivedQuery id="PMUOverheadAndSpinTimeCapped" displayName="%SpinAndOverheadTime">
      <queryInherit>/PMUOverheadAndSpinTime</queryInherit>
    </derivedQuery>
    <derivedQuery id="PMUOverheadAndSpinTimeAllCoresCumulative" displayName="%SpinAndOverheadTime">
      <queryInherit>/PMUOverheadAndSpinTime</queryInherit>
      <maxEval>$logicalCPUCount * 100</maxEval>
    </derivedQuery>
    <derivedQuery id="Reliability" displayName="%Reliability">
      <helpKeyword>configs.reliability_reliabilitydescriptionall</helpKeyword>
      <queryInherit>/ClockticksPercentageQuery</queryInherit>
      <description>%ReliabilityDescriptionAll</description>
      <issueText>%ReliabilityIssueTextAll</issueText>
      <xsl:choose>
        <xsl:when test="exsl:ctx('allowMultipleRuns') = false or exsl:ctx('allowMultipleRuns') = ''">
          <xsl:choose>
            <xsl:when test="exsl:ctx('PMU') = 'airmont' or exsl:ctx('PMU') = 'goldmont' or exsl:ctx('PMU') = 'goldmont_plus' or exsl:ctx('PMU') = 'silvermont' or exsl:ctx('PMU') = 'lakemont' or exsl:ctx('PMU') = 'snowridge' or exsl:ctx('PMU') = 'elkhartlake'">
              <valueEval><![CDATA[
                ( ( queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE_P]") && queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE]") ) ? ( ( queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE_P]") < queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE]") ) ? ( queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE_P]") / ( queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE]") + 1)  ) : ( queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE]") / ( queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE_P]") + 1) ) ) : 1 )
              ]]></valueEval>
            </xsl:when>
            <xsl:otherwise>
              <valueEval><![CDATA[
                ( ( queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD_P]") && queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD]") ) ? ( ( queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD_P]") < queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD]") ) ? ( queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD_P]") / ( queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD]") + 1)  ) : ( queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD]") / ( queryOptional("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD_P]") + 1) ) ) : 1 )
              ]]></valueEval>
            </xsl:otherwise>
          </xsl:choose>
          <issueEval><![CDATA[
              ( ( query("/Reliability") < 0.7 ) && ( query("/PMUHotspot") > 0.05 ) )
            ]]></issueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval>1</valueEval>
        </xsl:otherwise>
      </xsl:choose>
    </derivedQuery>
    <derivedQuery id="ReliabilityForView">
      <queryInherit>/Reliability</queryInherit>
      <confidenceText>%PMUMetricConfidenceText</confidenceText>
      <xsl:choose>
        <xsl:when test="exsl:ctx('allowMultipleRuns') = false or exsl:ctx('allowMultipleRuns') = ''">
          <xsl:choose>
            <xsl:when test="exsl:ctx('PMU') = 'airmont' or exsl:ctx('PMU') = 'goldmont' or exsl:ctx('PMU') = 'goldmont_plus' or exsl:ctx('PMU') = 'silvermont' or exsl:ctx('PMU') = 'lakemont' or exsl:ctx('PMU') = 'snowridge' or exsl:ctx('PMU') = 'elkhartlake'">
              <valueEval><![CDATA[
                ( ( query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE_P]") < query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE]") ) ? ( query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE_P]") / query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE]")  ) : ( query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE]") / query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.CORE_P]") ) )
              ]]></valueEval>
              <confidenceEval><![CDATA[
                    ( ( query("/PMUSampleCount/PMUEventType[CPU_CLK_UNHALTED.CORE]") >= 10 ) && ( query("/PMUSampleCount/PMUEventType[CPU_CLK_UNHALTED.CORE_P]") >= 10 ) )
                  ]]></confidenceEval>
            </xsl:when>
            <xsl:otherwise>
              <valueEval><![CDATA[
                ( ( query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD_P]") < query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD]") ) ? ( query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD_P]") / query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD]")  ) : ( query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD]") / query("/PMUEventCount/PMUEventType[CPU_CLK_UNHALTED.THREAD_P]") ) )
              ]]></valueEval>
              <confidenceEval><![CDATA[
                    ( ($useCountingMode || $useAggregatedCounting) ? $TRUE : ( ( query("/PMUSampleCount/PMUEventType[CPU_CLK_UNHALTED.THREAD]") >= 10 ) && ( query("/PMUSampleCount/PMUEventType[CPU_CLK_UNHALTED.THREAD_P]") >= 10 ) ) )
                  ]]></confidenceEval>
            </xsl:otherwise>
          </xsl:choose>
          <issueEval><![CDATA[
              ( ( query("/ReliabilityForView") < 0.7 ) && ( query("/PMUHotspot") > 0.05 ) )
            ]]></issueEval>
        </xsl:when>
        <xsl:otherwise>
          <valueEval>1</valueEval>
        </xsl:otherwise>
      </xsl:choose>
    </derivedQuery>
    <derivedQuery id="MemoryObjectAllocSourceFileLine" displayName="%MemoryObjectAllocSourceFileLine">
      <valueEval><![CDATA[ query("/MemoryObjectAllocSourceFile") + ":" + query("/MemoryObjectAllocSourceLine") ]]></valueEval>
      <valueType>string</valueType>
      <description>%MemoryObjectAllocSourceFileLineDescription</description>
    </derivedQuery>
    <derivedQuery id="PMUSpinTimeParent">
      <queryInherit>/PMUSpinTime</queryInherit>
      <displayAttributes>
        <xsl:choose>
          <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
            <boolean:expand>false</boolean:expand>
          </xsl:when>
          <xsl:otherwise>
            <boolean:expand>true</boolean:expand>
          </xsl:otherwise>
        </xsl:choose>
      </displayAttributes>
      <xsl:if test="exsl:IsNonEmptyTableExist('dd_function_subtype')">
        <expand>
          <vectorQuery id="PMUSpinTimeExpanded">
            <queryRef>/PMUSpinBusyWaitOnBarrierTime</queryRef>
            <queryRef>/PMUSpinBusyWaitOnLockTime</queryRef>
            <queryRef>/PMUSpinBusyWaitOnMPISpinningTime</queryRef>
            <queryRef>/PMUSpinOtherTime</queryRef>
          </vectorQuery>
        </expand>
      </xsl:if>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
    </derivedQuery>
    <derivedQuery id="PMUOverheadTimeParent">
      <queryInherit>/PMUOverheadTime</queryInherit>
      <displayAttributes>
        <xsl:choose>
          <xsl:when test="exsl:IsNonEmptyTableExist('barrier_imbalance_data')">
            <boolean:expand>false</boolean:expand>
          </xsl:when>
          <xsl:otherwise>
            <boolean:expand>true</boolean:expand>
          </xsl:otherwise>
        </xsl:choose>
      </displayAttributes>
      <xsl:if test="exsl:IsNonEmptyTableExist('dd_function_subtype')">
        <expand>
          <vectorQuery id="PMUOverheadTimeExpanded">
            <queryRef>/PMUOverheadWorkForkingTime</queryRef>
            <queryRef>/PMUOverheadWorkSchedulingAndTaskingTime</queryRef>
            <queryRef>/PMUOverheadReductionTime</queryRef>
            <queryRef>/PMUOverheadAtomicsTime</queryRef>
            <queryRef>/PMUOverheadOtherTime</queryRef>
          </vectorQuery>
        </expand>
      </xsl:if>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
    </derivedQuery>
    <derivedQuery id="RefTimeParent" displayName="%CPUTime">
      <queryInherit>/RefTime</queryInherit>
      <displayAttributes>
        <boolean:expand>false</boolean:expand>
        <boolean:synchronizeChildrenFormats>false</boolean:synchronizeChildrenFormats>
      </displayAttributes>
      <expand>
        <vectorQuery id="RefTimeExpanded">
          <queryRef>/PMUUserTime/CPUUsageUtilization</queryRef>
          <queryRef>/PMUSpinTimeParent</queryRef>
          <queryRef>/PMUOverheadTimeParent</queryRef>
        </vectorQuery>
      </expand>
      <confidenceEval><![CDATA[ query("/ClocktickConfidence") ]]></confidenceEval>
      <confidenceText>%NotEnoughSamples</confidenceText>
    </derivedQuery>
    <derivedQuery id="RefTimeParentExpanded">
      <queryInherit>/RefTimeParent</queryInherit>
      <displayAttributes>
        <boolean:expand>true</boolean:expand>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="PMUOpenMPTime" displayName="%OpenMPTime">
      <valueEval><![CDATA[ query("/RefTime/PMUModuleFileCategory[openmp]") ]]></valueEval>
      <valueType>time</valueType>
      <description>%OpenMPTimeDescription</description>
    </derivedQuery>
    <derivedQuery id="PMUOpenMPTimePercents" displayName="%OpenMPTimePercents">
      <valueEval><![CDATA[ ( (query("/PMUOpenMPTime") / query("/OpenMPElapsedTime")) / query("/TargetConcurrency") ) ]]></valueEval>
      <valueType>ratio</valueType>
      <description>%OpenMPTimePercentsDescription</description>
    </derivedQuery>
    <derivedQuery id="PMUCilkTime" displayName="%CilkTime">
      <valueEval><![CDATA[ query("/RefTime/PMUModuleFileCategory[cilk]") ]]></valueEval>
      <valueType>time</valueType>
      <description>%CilkTimeDescription</description>
    </derivedQuery>
    <derivedQuery id="PMUCilkTimePercents" displayName="%CilkTimePercents">
      <valueEval><![CDATA[ ( (query("/PMUCilkTime") / query("/OpenMPElapsedTime")) / query("/TargetConcurrency") ) ]]></valueEval>
      <valueType>ratio</valueType>
      <description>%CilkTimePercentsDescription</description>
    </derivedQuery>
    <derivedQuery id="PMUMpiTime" displayName="%MpiTime">
      <valueEval><![CDATA[ query("/RefTime/PMUModuleFileCategory[mpi]") ]]></valueEval>
      <valueType>time</valueType>
      <description>%MpiTimeDescription</description>
    </derivedQuery>
    <derivedQuery id="PMUMpiTimePercents" displayName="%MpiTimePercents">
      <valueEval><![CDATA[ ( (query("/PMUMpiTime") / query("/OpenMPElapsedTime")) / query("/TargetConcurrency") ) ]]></valueEval>
      <valueType>ratio</valueType>
      <description>%MpiTimePercentsDescription</description>
    </derivedQuery>
    <derivedQuery id="PMUTbbTime" displayName="%TbbTime">
      <valueEval><![CDATA[ query("/RefTime/PMUModuleFileCategory[tbb]") ]]></valueEval>
      <valueType>time</valueType>
      <description>%TbbTimeDescription</description>
    </derivedQuery>
    <derivedQuery id="PMUTbbTimePercents" displayName="%TbbTimePercents">
      <valueEval><![CDATA[ ( (query("/PMUTbbTime") / query("/OpenMPElapsedTime")) / query("/TargetConcurrency") ) ]]></valueEval>
      <valueType>ratio</valueType>
      <description>%TbbTimePercentsDescription</description>
    </derivedQuery>
    <derivedQuery id="PMUPthreadsTime" displayName="%PthreadsTime">
      <valueEval><![CDATA[ query("/RefTime/PMUModuleFileCategory[pthreads]") ]]></valueEval>
      <valueType>time</valueType>
      <description>%PthreadsTimeDescription</description>
    </derivedQuery>
    <derivedQuery id="PMUPthreadsTimePercents" displayName="%PthreadsTimePercents">
      <valueEval><![CDATA[ ( (query("/PMUPthreadsTime") / query("/OpenMPElapsedTime")) / query("/TargetConcurrency") ) ]]></valueEval>
      <valueType>ratio</valueType>
      <description>%PthreadsTimePercentsDescription</description>
    </derivedQuery>
    <derivedQuery id="PMUUserModeTime" displayName="%CPUUserModeTime">
      <description>%CPUUserModeTimeDescription</description>
      <valueType>time</valueType>
      <valueEval><![CDATA[ query("/RefTime/PMUModuleFileIsKernel[%False]") ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="PMUKernelModeTime" displayName="%CPUKernelModeTime">
      <description>%CPUKernelModeTimeDescription</description>
      <valueType>time</valueType>
      <valueEval><![CDATA[ query("/RefTime/PMUModuleFileIsKernel[%True]") ]]></valueEval>
      <displayAttributes>
        <minimumResolutionms>0</minimumResolutionms>
        <timelineObjectType>interval</timelineObjectType>
        <timelineGraphColor>237,28,36</timelineGraphColor>
        <timeScalems>1000</timeScalems>
      </displayAttributes>
    </derivedQuery>
    <derivedQuery id="PMUUnknownTime" displayName="%CPUUnknownTime">
      <valueType>time</valueType>
      <valueEval><![CDATA[ query("/RefTime") - query("/PMUUserModeTime") - query("/PMUKernelModeTime") ]]></valueEval>
    </derivedQuery>
    <derivedQuery id="PMUUKModeTimeParent" displayName="%RefTime">
      <valueEval><![CDATA[ query("/RefTime") ]]></valueEval>
      <valueType>time</valueType>
      <description>%RefTimeDescription</description>
      <expand>
        <vectorQuery id="PMUUKModeTimeExpanded">
          <derivedQuery displayName ="%CPUUserModeTimeShort">
            <queryInherit>/PMUUserModeTime</queryInherit>
          </derivedQuery>
          <derivedQuery displayName ="%CPUKernelModeTimeShort">
            <queryInherit>/PMUKernelModeTime</queryInherit>
          </derivedQuery>
          <derivedQuery displayName ="%CPUUnknownTimeShort">
            <queryInherit>/PMUUnknownTime</queryInherit>
          </derivedQuery>
        </vectorQuery>
      </expand>
      <displayAttributes>
        <sortType>descending</sortType>
        <selfFormat>time</selfFormat>
        <boolean:expand>true</boolean:expand>
        <boolean:canBeDoi>true</boolean:canBeDoi>
      </displayAttributes>
    </derivedQuery>
  </queryLibrary>
</bag>
