<?xml version="1.0" encoding="UTF-8"?>
<!--

 Copyright Â© 2009-2020 Intel Corporation. All rights reserved.

 The information contained herein is the exclusive property of
 Intel Corporation and may not be disclosed, examined, or reproduced in
 whole or in part without explicit written authorization from the Company.

-->
<bag
  xmlns:boolean="http://www.w3.org/2001/XMLSchema#boolean"
  xmlns:int="http://www.w3.org/2001/XMLSchema#int"
  xmlns:double="http://www.w3.org/2001/XMLSchema#double">
  <prerequisites
    xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:exsl="http://exslt.org/common" exsl:keep_exsl_namespace=""
    syntax="norules">
    <xsl:if test="(
        exsl:ctx('connectionType', '') = 'sniper'
        )">
      <xsl:value-of select="exsl:error('%VTSAIsNotPossibleForSniper')"/>
    </xsl:if>
  </prerequisites>
  <knobs xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:exsl="http://exslt.org/common" exsl:keep_exsl_namespace=""
    xmlns:str="http://exslt.org/strings" str:keep_str_namespace="" syntax="norules">
    <xsl:variable name="commonKnobs" select="document('config://collector/include/knobs.xsl')"/>
    <xsl:variable name="pmuCommon" select="document('config://include/pmu_common.xsl')"/>
    <xsl:variable name="traceEvents" select="document('config://collector/include/trace_events.xsl?runtool=runsa')"/>
    <xsl:variable name="isPTAvailable" select="$pmuCommon//variables/isPTAvailable"/>
    <xsl:variable name="memBandwidthEvents" select="$pmuCommon//variables/memBandwidthEvents"/>
    <xsl:variable name="isPeciseClockticksAvailable" select="$pmuCommon//variables/isPeciseClockticksAvailable"/>
    <xsl:variable name="PCIeBandwidthEvents" select="$pmuCommon//variables/PCIeBandwidthEvents"/>
    <xsl:variable name="FpgaBlueStreamEvents" select="$pmuCommon//variables/FpgaBlueStreamEvents"/>
    <xsl:variable name="cacheUsageEvents" select="$pmuCommon//variables/cacheUsageEvents"/>
    <booleanKnob id="analyzeFPU" displayName="%analyzeFPU" boolean:visible="false" cliName="analyze-fpu">
      <description>%analyzeFPUDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="iptCollectEvents" displayName="%iptCollectEvents" boolean:visible="true" cliName="ipt-events">
      <description>%iptCollectEventsDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
      <experimental>full-intel-pt</experimental>
    </booleanKnob>
    <intKnob id="iptRegionsToLoad" displayName="%iptRegionsToLoad" boolean:visible="true" cliName="ipt-regions-to-load">
      <description>%iptRegionsToLoadDescription</description>
      <boolean:defaultValue>0</boolean:defaultValue>
      <int:min>0</int:min>
      <int:max>5000</int:max>
      <experimental>full-intel-pt</experimental>
    </intKnob>
    <doubleKnob id="maxRegionDuration" displayName="%maxRegionDuration" boolean:visible="true" cliName="max-region-duration">
      <description>%maxRegionDurationDescription</description>
      <double:min>0.001</double:min>
      <double:max>1000.0</double:max>
      <double:defaultValue>100.0</double:defaultValue>
      <experimental>full-intel-pt</experimental>
    </doubleKnob>
    <booleanKnob id="processKernelBinaries" boolean:visible="true" displayName="%processKernelBinaries" cliName="process-kernel-binaries">
      <description>%processKernelBinariesDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
      <experimental>full-intel-pt</experimental>
    </booleanKnob>
    <intKnob id="ringBuffer" displayName="%RingBuffer" cliName="ring-buffer">
      <description>%RingBufferDescription</description>
      <int:min>0</int:min>
      <int:defaultValue>0</int:defaultValue>
      <experimental>platform-profiling</experimental>
    </intKnob>
    <booleanKnob id="errorsAsWarnings" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="eventInfo" displayName="%EventInfo" cliName="event-info">
      <description>%EventInfoDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
      <experimental>platform-profiling</experimental>
    </booleanKnob>
    <booleanKnob id="enablePEBSCollection" displayName="%EnablePEBSCollection" cliName="enable-pebs-collection">
      <description>%EnablePEBSCollectionDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="enableStackCollection" displayName="%EnableStackCollection" cliName="enable-stack-collection">
      <description>%EnableStackCollectionDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="enableVTSSCollection" displayName="%EnableStackCollection" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <xsl:variable name="commonDoc" select="document('config://collector/include/common.xsl')"/>
    <xsl:variable name="usePerfForStacks" select="$commonDoc//common/variables/usePerfForStacks"/>
    <intKnob id="stackSize" displayName="%StackSize" cliName="stack-size">
      <knobProperty name="active_state">enableStackCollection=true</knobProperty>
      <description>%StackSizeDescription</description>
      <xsl:choose>
        <xsl:when test="(exsl:ctx('targetOS', '')='Linux' or exsl:ctx('targetOS', '')='Android')">
          <xsl:choose>
            <xsl:when test="$usePerfForStacks='false'">
              <int:defaultValue>0</int:defaultValue>
            </xsl:when>
            <xsl:otherwise>
              <int:defaultValue>1024</int:defaultValue>
            </xsl:otherwise>
          </xsl:choose>
          <int:min>0</int:min>
        </xsl:when>
        <xsl:otherwise>
          <int:min>0</int:min>
          <int:defaultValue>0</int:defaultValue>
        </xsl:otherwise>
      </xsl:choose>
    </intKnob>
    <xsl:variable name="isSWStackAvailable" select="string($commonDoc//common/variables/isSWStackAvailable)"/>
    <xsl:variable name="preferredNonSWStackType" select="string($commonDoc//common/variables/preferredNonSWStackType)"/>
    <enumKnob id="stackTypeCollect" displayName="%StackTypeCollect" cliName="stack-type">
      <knobProperty name="active_state">enableStackCollection=true</knobProperty>
      <description>%StackTypeCollectDescription</description>
      <values>
        <xsl:if test="$isSWStackAvailable">
          <value displayName="%StackTypeCollectSoftware">software</value>
          <value displayName="%StackTypeCollectSoftwareLbr">software_lbr</value>
        </xsl:if>
        <value displayName="%StackTypeCollectLbr">lbr</value>
        <xsl:if test="exsl:ctx('targetOS', '')='FreeBSD'">
          <value displayName="%StackTypeCollectFramePointer">framepointer</value>
        </xsl:if>
        <defaultValue>
          <xsl:choose>
            <xsl:when test="$isSWStackAvailable">
              <xsl:text>software</xsl:text>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="$preferredNonSWStackType"/>
            </xsl:otherwise>
          </xsl:choose>
        </defaultValue>
      </values>
    </enumKnob>
    <booleanKnob id="enableLBRCollection" displayName="%EnableLBRCollection" cliName="enable-lbr-collection">
      <description>%EnableLBRCollectionDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectCallCounts" displayName="%CollectCallCounts" cliName="enable-call-counts">
      <xsl:attribute name="boolean:visible">false</xsl:attribute>
      <description>%CollectCallCountsCollectionDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectTripCounts" displayName="%CollectTripCounts" cliName="enable-trip-counts">
      <xsl:if test="exsl:ctx('targetOS') = 'MacOSX'">
        <xsl:attribute name="boolean:visible">false</xsl:attribute>
      </xsl:if>
      <description>%CollectTripCountsCollectionDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectFullProcTrace" displayName="%CollectFullProcTrace" boolean:visible="false" cliName="enable-full-processor-trace">
      <xsl:if test="$isPTAvailable='true'">
        <xsl:attribute name="boolean:visible">true</xsl:attribute>
      </xsl:if>
      <knobProperty name="active_state">collectCallCounts=true</knobProperty>
      <description>%CollectFullProcTraceDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
      <experimental>full-intel-pt</experimental>
    </booleanKnob>
    <booleanKnob id="analyzeFullProcTrace" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectPTforTSX" displayName="%collectPTforTSX" boolean:visible="false" cliName="enable-processor-trace-for-tsx">
      <xsl:if test="$isPTAvailable='true'">
        <xsl:attribute name="boolean:visible">true</xsl:attribute>
      </xsl:if>
      <description>%CollectPTforTSXDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
      <experimental>full-intel-pt</experimental>
    </booleanKnob>
    <booleanKnob id="enableCycleAccurateMode" displayName="%EnableCycleAccurateMode" boolean:visible="false" cliName="enable-cycle-accurate-mode">
      <xsl:if test="$isPTAvailable='true'">
        <xsl:attribute name="boolean:visible">true</xsl:attribute>
      </xsl:if>
      <description>%EnableCycleAccurateModeDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
      <experimental>full-intel-pt</experimental>
    </booleanKnob>
    <booleanKnob id="enableRing0ProfilingMode" displayName="%EnableRing0ProfilingMode" boolean:visible="false" cliName="enable-ring0-mode">
      <xsl:if test="$isPTAvailable='true'">
        <xsl:attribute name="boolean:visible">true</xsl:attribute>
      </xsl:if>
      <description>%EnableRing0ProfilingModeDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
      <experimental>full-intel-pt</experimental>
    </booleanKnob>
    <intKnob id="eventMuxFactor" displayName="%EventMuxFactor" boolean:visible="true" cliName="event-mux-factor">
      <description>%EventMuxFactorDescription</description>
      <int:min>1</int:min>
      <int:defaultValue>5</int:defaultValue>
    </intKnob>
    <stringKnob id="chipsetEventConfig" displayName="%ChipsetEventConfig" cliName="chipset-event-config" boolean:visible="false">
      <description>%ChipsetEventConfigDescription</description>
      <value></value>
      <defaultValue></defaultValue>
    </stringKnob>
    <xsl:copy-of select="$traceEvents//common/knobs/*"/>
    <booleanKnob id="usePerf" displayName="%UsePerf" boolean:visible="false">
      <description>%UsePerfDescription</description>
      <xsl:choose>
        <xsl:when test="exsl:ctx('targetOS')='Linux' and (contains(exsl:ctx('Hypervisor', 'None'),'KVM') or contains(exsl:ctx('Hypervisor', 'None'),'xen') or contains(exsl:ctx('Hypervisor', 'None'),'VMware'))">
          <boolean:defaultValue>true</boolean:defaultValue>
        </xsl:when>
        <xsl:otherwise>
          <boolean:defaultValue>false</boolean:defaultValue>
        </xsl:otherwise>
      </xsl:choose>
    </booleanKnob>
    <booleanKnob id="collectMemBandwidth" displayName="%CollectMemBandwidth" boolean:visible="false">
      <xsl:if test="$memBandwidthEvents">
        <xsl:attribute name="boolean:visible">true</xsl:attribute>
      </xsl:if>
      <description>%CollectMemBandwidthDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectPCIeBandwidth" displayName="%CollectPCIeBandwidth" boolean:visible="false">
      <xsl:if test="$PCIeBandwidthEvents">
        <xsl:attribute name="boolean:visible">true</xsl:attribute>
      </xsl:if>
      <description>%CollectPCIeBandwidthDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <enumKnob id="restrictPCIeBandwidthByClass" displayName="%RestrictPCIeBandwidthByClass" boolean:visible="true">
      <knobProperty name="active_state">collectPCIeBandwidth=true</knobProperty>
      <description>%RestrictPCIeBandwidthByClassDescription</description>
        <values>
          <value displayName="All">None</value>
          <value displayName="Processing accelerators">0x12</value>
          <value displayName="Mass storage controller">0x1</value>
          <value displayName="Network controller">0x2</value>
          <value displayName="Display controller">0x3</value>
          <defaultValue>None</defaultValue>
        </values>
    </enumKnob>
    <booleanKnob id="collectFpgaBlueStreamEvents" displayName="%CollectFpgaBlueStreamEvents" boolean:visible="false">
      <xsl:if test="$FpgaBlueStreamEvents != ''">
        <xsl:attribute name="boolean:visible">true</xsl:attribute>
      </xsl:if>
      <description>%CollectFpgaBlueStreamDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectUserTasksEventsCountersMode" displayName="%CollectUserTasksEventsCountersMode" cliName="enable-user-tasks" boolean:visible="true">
      <description>%CollectUserTasksEventsCountersModeDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectFramesMode" displayName="%CollectFramesMode" cliName="enable-frames" boolean:visible="false">
      <description>%CollectFramesModeDescription</description>
      <boolean:defaultValue>true</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="systemWideContextSwitch" displayName="%SystemWideContextSwitch" cliName="enable-system-cswitch">
      <description>%SystemWideContextSwitchDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectTSXCycles" displayName="%CollectTSXCycles" boolean:visible="false" cliName="collect-tsx-cycles">
      <xsl:if test="exsl:ctx('isTSXAvailable', 1) and exsl:ctx('targetOS') != 'MacOSX'">
        <xsl:attribute name="boolean:visible">true</xsl:attribute>
      </xsl:if>
      <description>%CollectTSXCyclesDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectPreciseClockticks" displayName="%CollectPreciseClockticks" boolean:visible="false">
      <xsl:if test="$isPeciseClockticksAvailable='true'">
        <xsl:attribute name="boolean:visible">true</xsl:attribute>
      </xsl:if>
      <description>%CollectPreciseClockticksDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="apsMode" displayName="%apsMode" boolean:visible="false">
      <description>%apsMode</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="dramBandwidthLimits" displayName="%DramBandwidthLimits" cliName="dram-bandwidth-limits">
      <description>%DramBandwidthLimitsDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectIoWaits" displayName="%CollectIoWaits" cliName="collect-io-waits">
      <description>%CollectIoWaitsDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="cpuByIoWaits" cliName="cpu-by-io-waits" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectCAT" displayName="%CollectCAT" boolean:visible="false">
      <xsl:if test="exsl:is_experimental('cat') and $cacheUsageEvents">
        <xsl:attribute name="boolean:visible">true</xsl:attribute>
      </xsl:if>
      <description>%CollectCATDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <stringKnob id="supportedTargetTypes" boolean:visible="false">
      <defaultValue>all</defaultValue>
    </stringKnob>
    <enumKnob id="collectIoMode" displayName="%CollectIoMode" cliName="io-mode" boolean:visible="true">
      <xsl:if test="exsl:ctx('targetType', '') = 'system'">
        <xsl:attribute name="boolean:visible">false</xsl:attribute>
      </xsl:if>
      <description>%CollectIoModeDescription</description>
        <values>
          <xsl:if test="exsl:ctx('targetType', '') != 'system'">
            <value displayName="%Disabled">off</value>
            <value displayName="%WithStacks">stack</value>
            <value displayName="%WithoutStacks">nostack</value>
          </xsl:if>
            <defaultValue>off</defaultValue>
        </values>
    </enumKnob>
    <doubleKnob id="pmuSamplingInterval" cliName="sampling-interval" displayName="%SamplingInterval">
      <description>%SamplingIntervalDescription</description>
      <double:min>0.01</double:min>
      <double:max>1000.0</double:max>
      <double:defaultValue>1.0</double:defaultValue>
    </doubleKnob>
    <intKnob id="uncoreSamplingInterval" cliName="uncore-sampling-interval" displayName="%UncoreSamplingInterval">
      <description>%UncoreSamplingIntervalDescription</description>
      <int:min>1</int:min>
      <int:max>100</int:max>
      <int:defaultValue>10</int:defaultValue>
    </intKnob>
    <stringKnob id="emonPreset" boolean:visible="false" cliName="emon-preset">
      <description>%EmonPresetDescription</description>
    </stringKnob>
    <booleanKnob id="emonCSVTraceFormat" boolean:visible="false" cliName="emon-csv-trace-format">
      <description>%EmonCSVTraceFormatDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="emonMachineReadableVersionFile" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <xsl:copy-of select="$commonKnobs//knobs/*"/>
    <enumKnob id="eventMode" displayName="%EventMode" cliName="event-mode">
      <description>%EventModeDescription</description>
      <values>
        <value displayName="%EventModeAll">all</value>
        <value displayName="%EventModeUser">user</value>
        <value displayName="%EventModeOs">os</value>
        <defaultValue>all</defaultValue>
      </values>
    </enumKnob>
    <enumKnob id="cswitchMode" displayName="%CswitchMode" boolean:visible="false" cliName="cswitch-mode">
      <description>%CswitchModeDescription</description>
      <values>
        <value displayName="%CswitchModeNone">none</value>
        <value displayName="%CswitchModeInactive">inactive</value>
        <value displayName="%CswitchModeActive">active</value>
        <value displayName="%CswitchModeBoth">both</value>
        <defaultValue>inactive</defaultValue>
      </values>
    </enumKnob>
    <booleanKnob id="forceMuxOff" displayName="%ForceMuxOff" boolean:visible="false" cliName="force-mux-off">
      <description>%ForceMuxOffDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="loadPebsData" displayName="%LoadPebsData" boolean:visible="false" cliName="load-pebs-data">
      <description>%LoadPebsDataDescription</description>
      <boolean:defaultValue>true</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="createGPUQueueFrames" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="nameThreadsAsCreationModule" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="suppressCSVSyntaxWarnings" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="basicBlockAnalysis" displayName="%BasicBlockAnalysis" boolean:visible="false">
      <description>%BasicBlockAnalysisDescription</description>
      <boolean:defaultValue>true</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="resolveCallsites" boolean:visible="false">
      <boolean:defaultValue>true</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="disableGPUSysinfo" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <stringKnob id="isPowerVRDataAvailable" boolean:visible="false">
      <defaultValue>no</defaultValue>
    </stringKnob>
    <booleanKnob id="cpuGpuUsageData" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="systemWideDiskIO" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="forceSystemWide" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="loadLbrStackToDb" boolean:visible="false">
      <boolean:defaultValue>true</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="loadRawLbrData" boolean:visible="false">
      <boolean:defaultValue>true</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="adjustCollectionBoundsByOMPApps" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <xsl:variable name="isHWPowerEnabled" select="exsl:ctx('PMU') = 'snb' or exsl:ctx('PMU') = 'snbep' or exsl:ctx('PMU') = 'ivybridge' or exsl:ctx('PMU') = 'ivytown'"/>
    <booleanKnob id="analyzeActivePowerConsumption" displayName="%AnalyzeActivePowerConsumption" cliName="analyze-active-power-consumption">
      <xsl:attribute name="boolean:visible">
        <xsl:value-of select="$isHWPowerEnabled"/>
      </xsl:attribute>
      <description>%AnalyzeActivePowerConsumptionDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="analyzeIdlePowerConsumption" displayName="%AnalyzeIdlePowerConsumption" cliName="analyze-idle-power-consumption">
      <xsl:choose>
        <xsl:when test="$isHWPowerEnabled='true' and exsl:ctx('targetOS') = 'Windows'">
           <xsl:attribute name="boolean:visible">true</xsl:attribute>
        </xsl:when>
        <xsl:otherwise>
            <xsl:attribute name="boolean:visible">false</xsl:attribute>
        </xsl:otherwise>
      </xsl:choose>
      <description>%AnalyzeIdlePowerConsumptionDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="enableCSwitch" displayName="%EnableCSwitch" boolean:visible="true" cliName="enable-context-switches">
      <description>%EnableCSwitchDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="preciseMultiplexing" displayName="%PreciseMultiplexing" boolean:visible="true">
      <description>%PreciseMultiplexingDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="perfForceSystemWide" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="perfPreferPerCpuSamplingMode" boolean:visible="false">
      <boolean:defaultValue>true</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="memoryAccessBandwidthMeasuring" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectPStateData" displayName="%CollectPStateData" boolean:visible="true">
      <description>%CollectPStateDataDescription</description>
      <boolean:defaultValue>true</boolean:defaultValue>
    </booleanKnob>
    <xsl:variable name="isPerfAvailable" select="string($commonDoc//common/variables/isPerfAvailable)"/>
    <booleanKnob id="preferDriverlessCollection" displayName="%PreferDriverlessCollection" boolean:visible="false"  cliName="enable-driverless-collection">
      <xsl:if test="$isPerfAvailable">
        <xsl:attribute name="boolean:visible">true</xsl:attribute>
      </xsl:if>
      <description>%PreferDriverlessCollectionDescription</description>
      <xsl:choose>
        <xsl:when test="not(exsl:ctx('isSEPDriverAvailable', 0)) or
                        (exsl:ctx('targetOS')='Linux' and (contains(exsl:ctx('Hypervisor', 'None'),'KVM') or contains(exsl:ctx('Hypervisor', 'None'),'xen') or contains(exsl:ctx('Hypervisor', 'None'),'VMware')))">
          <boolean:defaultValue>true</boolean:defaultValue>
        </xsl:when>
        <xsl:otherwise>
          <boolean:defaultValue>false</boolean:defaultValue>
        </xsl:otherwise>
      </xsl:choose>
    </booleanKnob>
    <enumKnob id="energyProfilingMode" displayName="%EnergyProfilingMode" visible="false" cliName="energy-profiling-mode">
      <values>
        <value displayName="%EnergyProfilingModeNone" cliName="none">none</value>
        <value displayName="%ThermalAnalysis" cliName="thermal">thermal</value>
        <value displayName="%IdleAnalysis" cliName="idle">idle</value>
        <value displayName="%ActiveAnalysis" cliName="active">active</value>
      <defaultValue>none</defaultValue>
      </values>
    </enumKnob>
    <booleanKnob id="analyzeThrottlingReasons" displayName="%AnalyzeThrottlingReasons" visible="true" cliName="analyze-throttling-reasons">
      <description>%AnalyzeThrottlingReasonsDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <stringKnob id="preferredEbsCollectorOrder" boolean:visible="false">
      <defaultValue>perf,vtss,sep</defaultValue>
    </stringKnob>
    <booleanKnob id="collectHwTrace" displayName="%collectHwTrace" boolean:visible="false" cliName="collect-hardware-trace">
      <xsl:if test="$isPTAvailable='true'">
        <xsl:attribute name="boolean:visible">true</xsl:attribute>
      </xsl:if>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectOsCounters" displayName="%CollectOsCounters" visible="false" cliName="collect-os-counters">
      <description>%CollectOsCountersDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="collectTopology" displayName="%CollectTopology" visible="false" cliName="collect-topology">
      <description>%CollectTopologyDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="explicitUncoreEventsConfig" boolean:visible="false">
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
    <booleanKnob id="analyzePersistentMemory" displayName="%AnalyzeIntelPersistentMemory" boolean:visible="true" cliName="analyze-persistent-memory">
      <description>%AnalyzeIntelPersistentMemoryDescription</description>
      <boolean:defaultValue>false</boolean:defaultValue>
    </booleanKnob>
  </knobs>
  <analysis xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:str="http://exslt.org/strings"
    xmlns:exsl="http://exslt.org/common"
    str:keep_str_namespace=""
    exsl:keep_exsl_namespace=""
    syntax="norules">
    <xsl:variable name="commonDoc" select="document('config://collector/include/common.xsl')"/>
    <xsl:variable name="isPerfAvailable" select="string($commonDoc//common/variables/isPerfAvailable)"/>
    <xsl:variable name="isVTSSAvailable" select="string($commonDoc//common/variables/isVTSSAvailable)"/>
    <xsl:variable name="isSystemWide" select="string($commonDoc//common/variables/isSystemWide)"/>
    <xsl:variable name="isSWStackAvailable" select="string($commonDoc//common/variables/isSWStackAvailable)"/>
    <xsl:variable name="preferredNonSWStackType" select="string($commonDoc//common/variables/preferredNonSWStackType)"/>
    <xsl:variable name="userDefinedEbsCollectorOrder">
      <xsl:if test="exsl:ctx('preferDriverlessCollection', 0)">
        <xsl:text>perf,</xsl:text>
      </xsl:if>
      <xsl:value-of select="exsl:ctx('preferredEbsCollectorOrder', '')"/>
    </xsl:variable>
    <xsl:variable name="applicableEbsCollectors">
      <xsl:for-each select="str:tokenize($userDefinedEbsCollectorOrder, ',')">
        <xsl:if test=".='perf' and $isPerfAvailable">
          <xsl:if test="exsl:ctx('usePerf', 0) or
                        exsl:ctx('preferDriverlessCollection', 0) or
                        not(exsl:ctx('isSEPDriverAvailable', 0)) or
                        (
                         exsl:ctx('enableStackCollection', 0) and
                         (
                          exsl:ctx('stackSize', 0)!=0 or
                          not($isVTSSAvailable)
                         )
                        )">perf,</xsl:if>
        </xsl:if>
        <xsl:if test=".='vtss' and exsl:ctx('isVTSSPPDriverAvailable', 0)">
          <xsl:if test="exsl:ctx('analyzeActivePowerConsumption', 0) or
                        exsl:ctx('analyzeIdlePowerConsumption', 0) or
                        exsl:ctx('collectCallCounts', 0) or
                        exsl:ctx('collectTripCounts', 0) or
                        exsl:ctx('enableCSwitch', 0) or
                        (
                         (
                          (
                          exsl:ctx('enableStackCollection', 0) and
                          exsl:ctx('stackTypeCollect', '') != 'lbr'
                          ) or
                          exsl:ctx('preciseMultiplexing', 0)
                         ) and
                         not($isSystemWide) and
                         not(exsl:ctx('allowMultipleRuns', 0))
                        )">vtss,</xsl:if>
        </xsl:if>
        <xsl:if test=".='sep'">sep,</xsl:if>
      </xsl:for-each>
    </xsl:variable>
    <xsl:variable name="doUsePerf" select="starts-with($applicableEbsCollectors, 'perf')"/>
    <xsl:variable name="doUseVTSS" select="starts-with($applicableEbsCollectors, 'vtss')"/>
    <xsl:variable name="doUseSEP" select="starts-with($applicableEbsCollectors, 'sep')"/>
    <xsl:variable name="pmuCommon" select="document('config://include/pmu_common.xsl')"/>
    <xsl:variable name="isLBRCallStackAvailable" select="$pmuCommon//variables/isLbrStackAvailable"/>
    <xsl:variable name="memBandwidthEvents" select="$pmuCommon//variables/memBandwidthEvents"/>
    <xsl:variable name="qpiBandwidthEvents" select="$pmuCommon//variables/qpiBandwidthEvents"/>
    <xsl:variable name="callCountsEvents" select="$pmuCommon//variables/callCountsEvents"/>
    <xsl:variable name="isPTAvailable" select="$pmuCommon//variables/isPTAvailable"/>
    <xsl:variable name="isTripCountsAvailable" select="$pmuCommon//variables/isTripCountsAvailable"/>
    <xsl:variable name="peciseClockticksEvent" select="$pmuCommon//variables/peciseClockticksEvent"/>
    <xsl:variable name="PCIeBandwidthEvents" select="$pmuCommon//variables/PCIeBandwidthEvents"/>
    <xsl:variable name="FpgaBlueStreamEvents" select="$pmuCommon//variables/FpgaBlueStreamEvents"/>
    <xsl:variable name="refClkEvent" select="$pmuCommon//variables/refClockticksEvent"/>
    <xsl:variable name="forceIMCBandwidthOnAtom" select="$pmuCommon//variables/forceIMCBandwidthOnAtom"/>
    <xsl:variable name="cacheUsageEvents" select="$pmuCommon//variables/cacheUsageEvents"/>
    <xsl:variable name="MemoryBandwidthError">
      <xsl:if test="not(exsl:ctx('isSEPDriverAvailable', 0))">
        <xsl:choose>
          <xsl:when test="not(contains(exsl:ctx('LinuxPerfCapabilities', 'NotAvailable'), 'uncore_imc')) or
                                          ((exsl:ctx('PMU')='haswell' or exsl:ctx('PMU') = 'broadwell') and
                                           contains(exsl:ctx('LinuxRelease', ''), '3.10.0-327.el7.'))">
            <xsl:choose>
              <xsl:when test="exsl:ctx('memoryAccessBandwidthMeasuring', 0)">
                <perfError>%BandwidthIsNotWorkWithoutSamplingMA</perfError>
              </xsl:when>
              <xsl:otherwise>
                <perfError>%BandwidthIsNotWorkWithoutSampling</perfError>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:when>
          <xsl:otherwise>
            <xsl:if test="exsl:ctx('LinuxPerfCredentials', 'NotAvailable')='Kernel'">
              <perfError>%BandwidthPerfSystemWideNoPerm</perfError>
            </xsl:if>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <xsl:if test="$doUseVTSS">
        <stackError>%NoCallStacksForMemBandwidth</stackError>
      </xsl:if>
    </xsl:variable>
    <collector id="runsa" displayName="%RunsaDisplayName">
      <xsl:variable name="traceEvents" select="document(concat('config://collector/include/trace_events.xsl?runtool=runsa&amp;isVTSSFlow=', $doUseVTSS))"/>
      <binaryName>runss</binaryName>
      <pythonRemoteBinaryName>runss.py</pythonRemoteBinaryName>
      <xsl:if test="not(exsl:ctx('Hypervisor', 'None') = 'None' or (exsl:ctx('Hypervisor', 'None') = 'Microsoft Hv' and exsl:ctx('HypervisorType', 'None') = 'Hyper-V'))">
        <xsl:if test="exsl:ctx('collectMemBandwidth', 0)">
          <xsl:value-of select="exsl:warning('%MemoryBandwidthNotSupportedOnVM')"/>
        </xsl:if>
        <xsl:if test="exsl:ctx('collectPCIeBandwidth', 0)">
          <xsl:value-of select="exsl:error('%PCIeBandwidthNotSupportedOnVM')"/>
        </xsl:if>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="exsl:ctx('analyzeThrottlingReasons', 0) and exsl:ctx('analyzeEnergyConsumption', 0)">
          <collectorOption option="pwr-config">power,temp,throt,gfx-pstate,cpu-pstate,sa-pstate</collectorOption>
        </xsl:when>
        <xsl:when test="exsl:ctx('analyzeThrottlingReasons', 0)">
          <collectorOption option="pwr-config">temp,throt,gfx-pstate,cpu-pstate,sa-pstate</collectorOption>
        </xsl:when>
        <xsl:when test="exsl:ctx('analyzeEnergyConsumption', 0)">
          <collectorOption option="pwr-config">power</collectorOption>
        </xsl:when>
      </xsl:choose>
      <xsl:if test="exsl:ctx('collectOsCounters', 0)">
        <collectorOption option="os-counters"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('collectTopology', 0)">
        <collectorOption option="collect-topology"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('analyzePersistentMemory', 0)">
        <collectorOption option="persistent-mem-metrics"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('supportedTargetTypes', '')!='all'">
        <xsl:variable name="isTargetTypeSupported">
          <xsl:for-each select="str:split(exsl:ctx('supportedTargetTypes', ''), ',')">
            <xsl:if test="string(current())=exsl:ctx('targetType', 'unknown')">
              <xsl:text>yes</xsl:text>
            </xsl:if>
          </xsl:for-each>
        </xsl:variable>
        <xsl:if test="$isTargetTypeSupported!='yes'">
          <xsl:variable name="supportedTargetTypePageNames">
            <xsl:for-each select="str:split(exsl:ctx('supportedTargetTypes', ''), ',')">
              <xsl:if test="string(current())='system'">
                <xsl:copy-of select="exsl:message('target_type','%System')"/>
              </xsl:if>
              <xsl:if test="string(current())='launch'">
                <xsl:copy-of select="exsl:message('target_type','%Launch')"/>
              </xsl:if>
              <xsl:if test="string(current())='attach'">
                <xsl:copy-of select="exsl:message('target_type','%Attach')"/>
              </xsl:if>
              <xsl:if test="string(current())='android-run'">
                <xsl:copy-of select="exsl:message('target_type','%AndroidRun')"/>
              </xsl:if>
              <xsl:if test="position() != last()">
                <xsl:text>,&#160;</xsl:text>
              </xsl:if>
            </xsl:for-each>
          </xsl:variable>
          <xsl:variable name="supportedTargetTypeError">
            <xsl:copy-of select="exsl:message('analysis_type','%RunsaCommonUnsupportedTargetType', string($supportedTargetTypePageNames))"/>
          </xsl:variable>
          <xsl:value-of select="exsl:error($supportedTargetTypeError)"/>
        </xsl:if>
      </xsl:if>
      <xsl:if test="exsl:ctx('iptCollectEvents', 0)">
        <collectorOption option="itt-config">ipt-events</collectorOption>
      </xsl:if>
      <xsl:if test="exsl:ctx('targetOS') != 'FreeBSD' and exsl:ctx('collectFramesMode', 1)">
        <collectorOption option="itt-config">frame</collectorOption>
      </xsl:if>
      <xsl:if test="exsl:ctx('traceMpi', 0)">
        <collectorOption option="itt-config">preload</collectorOption>
      </xsl:if>
      <xsl:if test="exsl:ctx('dramBandwidthLimits', 0)">
        <xsl:choose>
          <xsl:when test="exsl:ctx('isMaxDRAMBandwidthMeasurementSupported', 0)">
            <collectorOption option="bandwidth-limits"></collectorOption>
          </xsl:when>
          <xsl:when test="not(exsl:ctx('isMaxDRAMBandwidthMeasurementSupported', 1))">
            <xsl:value-of select="exsl:warning('%DramBandwidthLimitsNotSupported')"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="exsl:warning('%DramBandwidthLimitsAgentNotAvailable')"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <xsl:if test="exsl:ctx('collectMemBandwidth', 0) and $forceIMCBandwidthOnAtom = 'true'">
        <xsl:value-of select="exsl:warning('%ForceIMCWarning')"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('systemWideDiskIO', 0)">
        <xsl:choose>
           <xsl:when test="exsl:ctx('targetOS', '') = 'Linux'">
             <xsl:variable name="minMajorVersion" select="number(3)"/>
             <xsl:variable name="minMinorVersion" select="number(19)"/>
             <xsl:variable name="minPatchVersion" select="number(0)"/>
             <xsl:variable name="kernelVersion" select="string(exsl:ctx('LinuxRelease', ''))"/>
             <xsl:if test="$kernelVersion">
              <xsl:variable name="currentKernelVersions" select="str:tokenize($kernelVersion, '.-')"/>
              <xsl:if test="number($currentKernelVersions[1]) &lt; $minMajorVersion">
                 <xsl:value-of select="exsl:warning(string('%NvmeTracingNotSupported'))"/>
               </xsl:if>
              <xsl:if test="number($currentKernelVersions[1]) = $minMajorVersion">
                <xsl:if test="number($currentKernelVersions[2]) &lt; $minMinorVersion">
                  <xsl:value-of select="exsl:warning(string('%NvmeTracingNotSupported'))"/>
                </xsl:if>
                <xsl:if test="number($currentKernelVersions[2]) = $minMinorVersion">
                  <xsl:if test="number($currentKernelVersions[3]) &lt; $minPatchVersion">
                    <xsl:value-of select="exsl:warning(string('%NvmeTracingNotSupported'))"/>
                  </xsl:if>
                </xsl:if>
              </xsl:if>
             </xsl:if>
          </xsl:when>
        </xsl:choose>
        <xsl:choose>
          <xsl:when test="exsl:ctx('targetOS') = 'Windows'">
            <collectorOption option="stdsrc-config">cswitch,disk</collectorOption>
          </xsl:when>
          <xsl:when test="(exsl:ctx('targetOS') = 'Android' or exsl:ctx('targetOS') = 'Linux')">
            <xsl:for-each select="str:tokenize(exsl:ctx('isFtraceAvailableKnob',''), ',')">
              <xsl:variable name="IoWaitFtraceStatus">
                <xsl:choose>
                  <xsl:when test=".='debugfsNotExists'">%IoWaitDebugFSExistenceError</xsl:when>
                  <xsl:when test=".='debugfsNotAccessible'">%IoWaitDebugFSAccessError</xsl:when>
                  <xsl:when test=".='debugfsOffInConfigs'">%IoWaitDebugFSConfigError</xsl:when>
                  <xsl:when test=".='debugfsIsNotValidFsType'">%IoWaitDebugFSInvalidTypeError</xsl:when>
                  <xsl:when test=".='ftraceAccessError'">
                    <xsl:choose>
                      <xsl:when test="not(contains(exsl:ctx('isFtraceAvailableKnob',''), 'debugfs'))">%IoWaitFtraceAccessError</xsl:when>
                      <xsl:otherwise>notErrorOrWarning</xsl:otherwise>
                    </xsl:choose>
                  </xsl:when>
                  <xsl:when test=".='ftraceConfigError'">%IoWaitFtraceConfigError</xsl:when>
                  <xsl:when test=".='ftraceUnknownError'">%IoWaitFtraceUnknownError</xsl:when>
                  <xsl:when test=".='yes'">yes</xsl:when>
                  <xsl:otherwise>yes</xsl:otherwise>
                </xsl:choose>
              </xsl:variable>
              <xsl:choose>
                <xsl:when test="$IoWaitFtraceStatus != 'yes'">
                  <xsl:choose>
                    <xsl:when test="$IoWaitFtraceStatus = 'notErrorOrWarning'"></xsl:when>
                    <xsl:when test="exsl:ctx('errorsAsWarnings',0)">
                      <xsl:value-of select="exsl:warning($IoWaitFtraceStatus)"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:value-of select="exsl:error($IoWaitFtraceStatus)"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                  <collectorOption option="stdsrc-config">cswitch,disk,pagefault</collectorOption>
                  <xsl:if test="exsl:ctx('isIowaitTracingAvailable','')='yes'">
                    <collectorOption option="ftrace-function-groups">iowait</collectorOption>
                  </xsl:if>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:for-each>
          </xsl:when>
          <xsl:when test="exsl:ctx('targetOS','') = 'FreeBSD'">
            <collectorOption option="stdsrc-config">disk</collectorOption>
          </xsl:when>
        </xsl:choose>
      </xsl:if>
      <xsl:if test="exsl:ctx('collectIoMode', 'off') != 'off' and exsl:ctx('targetType', '') != 'system'">
        <collectorOption option="type">
          <xsl:text>io:</xsl:text>
          <xsl:value-of select="exsl:ctx('collectIoMode', 'off')"/>
        </collectorOption>
        <collectorOption option="filter-include">
          <xsl:text>wait=0</xsl:text>
        </collectorOption>
      </xsl:if>
      <xsl:copy-of select="$traceEvents//common/collector/*"/>
      <xsl:if test="exsl:ctx('pmuEventConfig', '') or exsl:ctx('collectPreciseClockticks', 0) or exsl:ctx('collectFullProcTrace', 0) or exsl:ctx('collectHwTrace', 0)">
        <xsl:choose>
          <xsl:when test="exsl:ctx('ringBuffer', 0) > 0 or exsl:ctx('targetRingBuffer', 0) > 0">
            <xsl:if test="exsl:ctx('targetOS')='FreeBSD' or exsl:ctx('targetOS')='MacOSX'">
              <xsl:value-of select="exsl:error('%RingBufferUnsupportedForPmuAnalysis')"/>
            </xsl:if>
          </xsl:when>
        </xsl:choose>
        <xsl:if test="exsl:ctx('enableStackCollection', 0)">
          <xsl:if test="exsl:ctx('stackTypeCollect', '') = 'software_lbr' and
                        not($doUsePerf)">
            <xsl:value-of select="exsl:error('%SoftwareLBRCallstacksUnavailable')"/>
          </xsl:if>
          <xsl:variable name="isSWStackChosen" select="contains(exsl:ctx('stackTypeCollect', ''), 'software')"/>
          <xsl:if test="not($isSWStackChosen and $isSWStackAvailable)">
            <xsl:variable name="nonSWStackType">
              <xsl:choose>
                <xsl:when test="$isSWStackChosen">
                  <xsl:value-of select="$preferredNonSWStackType"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:value-of select="exsl:ctx('stackTypeCollect', '')"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:if test="$nonSWStackType='lbr'">
              <xsl:choose>
                <xsl:when test="$isLBRCallStackAvailable='false'">
                  <xsl:choose>
                    <xsl:when test="exsl:ctx('errorsAsWarnings', 0)">
                      <xsl:value-of select="exsl:warning('%LBRCallstacksUnavailable')"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:value-of select="exsl:error('%LBRCallstacksUnavailable')"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:value-of select="exsl:warning('%LBRCallstacksDepthLimitation')"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:if>
            <xsl:if test="not($nonSWStackType='lbr' and $isLBRCallStackAvailable='false')">
              <collectorOption option="stackwalk">
                <xsl:value-of select="$nonSWStackType"/>
              </collectorOption>
            </xsl:if>
          </xsl:if>
        </xsl:if>
        <xsl:choose>
          <xsl:when test="$doUsePerf">
            <xsl:if test="not(exsl:ctx('isSEPDriverAvailable', 0)) and exsl:ctx('isPAXDriverLoaded', 0)">
              <xsl:value-of select="exsl:warning('%OldSepDriverLoaded')"/>
            </xsl:if>
            <xsl:choose>
              <xsl:when test="exsl:ctx('LinuxPerfCredentials', 'NotAvailable')!='NotAvailable' and
                (exsl:ctx('LinuxPerfCredentials', 'NotAvailable')!='User' or
                  (exsl:ctx('LinuxPerfCredentials', 'NotAvailable')='User' and exsl:ctx('eventMode', '')!='os'))
                and contains(exsl:ctx('LinuxPerfCapabilities', ''), 'format')">
                <xsl:choose>
                  <xsl:when test="exsl:ctx('ringBuffer', 0) > 0 or exsl:ctx('targetRingBuffer', 0) > 0">
                      <xsl:value-of select="exsl:error('%RingBufferUnsupportedForPmuAnalysis')"/>
                  </xsl:when>
                </xsl:choose>
                <xsl:if test="exsl:ctx('collectMemBandwidth', 0)">
                  <xsl:if test="$MemoryBandwidthError != '' ">
                    <xsl:for-each select="exsl:node-set($MemoryBandwidthError)/perfError">
                      <xsl:variable name="MemoryBandwidthErrorItem">
                        <xsl:value-of select="current()"/>
                      </xsl:variable>
                      <xsl:choose>
                        <xsl:when test="exsl:ctx('errorsAsWarnings', 0)">
                          <xsl:value-of select="exsl:warning($MemoryBandwidthErrorItem)"/>
                        </xsl:when>
                        <xsl:otherwise>
                          <xsl:value-of select="exsl:error($MemoryBandwidthErrorItem)"/>
                        </xsl:otherwise>
                      </xsl:choose>
                    </xsl:for-each>
                  </xsl:if>
                </xsl:if>
                <xsl:if test="exsl:ctx('analyzeActivePowerConsumption', 0)">
                  <xsl:value-of select="exsl:warning('%PerfNoActivePowerConsumption')"/>
                </xsl:if>
                <xsl:if test="exsl:ctx('analyzeIdlePowerConsumption', 0)">
                  <xsl:value-of select="exsl:warning('%PerfNoIdlePowerConsumption')"/>
                </xsl:if>
                <xsl:if test="exsl:ctx('enableCSwitch', 0)">
                  <xsl:choose>
                    <xsl:when test="$isSystemWide">
                      <xsl:value-of select="exsl:warning('%PerfNoCSwitchSW')"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <collectorOption option="sys-config">cswitch</collectorOption>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:if>
                <xsl:if test="exsl:ctx('PMU')='haswell_server' and
                        contains(exsl:ctx('LinuxRelease', ''), '3.10.0-123.el7.') and
                        contains(exsl:ctx('pmuEventConfig', ''), 'OFFCORE_RESPONSE:request=DEMAND_RFO:response=LLC_MISS.REMOTE_HITM')">
                  <xsl:value-of select="exsl:error('%PerfEventFailOldKernel')"/>
                </xsl:if>
                <xsl:if test="exsl:ctx('PMU')='skylake' and
                        contains(exsl:ctx('LinuxRelease', ''), '3.10.0-327.el7.')">
                  <xsl:variable name="checkIfPerfEventsForSKLAvailableOnKernel">
                    <xsl:for-each select="str:split(exsl:ctx('pmuEventConfig', ''), ',')">
                      <xsl:if test="(contains(string(current()), 'FRONTEND_RETIRED.'))">
                        <xsl:text>error</xsl:text>
                      </xsl:if>
                    </xsl:for-each>
                  </xsl:variable>
                  <xsl:if test="$checkIfPerfEventsForSKLAvailableOnKernel != ''">
                      <xsl:value-of select="exsl:error('%PerfEventFailOldKernel')"/>
                  </xsl:if>
                </xsl:if>
                <xsl:if test="exsl:ctx('PMU')='ivybridge' or exsl:ctx('PMU')='ivytown'">
                  <xsl:if test="(contains(exsl:ctx('LinuxRelease', ''), '3.19.0-15-generic') or
                          contains(exsl:ctx('LinuxRelease', ''), '2.6.32-573.el6') or
                          contains(exsl:ctx('LinuxRelease', ''), '3.16.0-4-amd64'))">
                    <xsl:variable name="checkIfPerfEventsForIVBAvailableOnKernel">
                      <xsl:for-each select="str:split(exsl:ctx('pmuEventConfig', ''), ',')">
                        <xsl:if test="(contains(string(current()), 'MEM_UOPS_RETIRED.') or
                                contains(string(current()), 'MEM_LOAD_UOPS_RETIRED.') or
                                contains(string(current()), 'MEM_LOAD_UOPS_LLC_HIT_RETIRED.')) and
                                not(contains(string(current()), '_PS'))">
                          <xsl:text>error</xsl:text>
                        </xsl:if>
                      </xsl:for-each>
                    </xsl:variable>
                    <xsl:if test="$checkIfPerfEventsForIVBAvailableOnKernel != ''">
                        <xsl:value-of select="exsl:error('%PerfEventFailMEMLoadsIVB')"/>
                    </xsl:if>
                  </xsl:if>
                </xsl:if>
                <xsl:if test="exsl:ctx('collectCallCounts', 0) or exsl:ctx('collectTripCounts', 0)">
                  <xsl:choose>
                    <xsl:when test="exsl:ctx('targetOS', '')='Linux' and exsl:ctx('OSBitness', '')='32'">
                      <xsl:value-of select="exsl:error('%CallCountsAndTripcountsUnavailableOn32Bit')"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:choose>
                        <xsl:when test="exsl:ctx('targetOS', '')='Linux' and exsl:ctx('targetType', '') = 'system'">
                          <xsl:value-of select="exsl:error('%RunssUnsupportedTargetType')"/>
                        </xsl:when>
                        <xsl:otherwise>
                          <xsl:value-of select="exsl:error('%VTSSPPDriverUnavailable')"/>
                        </xsl:otherwise>
                      </xsl:choose>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:if>
                <collectorOption option="collector">perf</collectorOption>
                <xsl:choose>
                  <xsl:when test="exsl:ctx('enableStackCollection', 0)">
                    <collectorOption option="stack"/>
                      <xsl:if test="exsl:ctx('stackTypeCollect', '') != 'lbr'">
                        <xsl:choose>
                          <xsl:when test="contains(exsl:ctx('LinuxPerfStackCapabilities', ''), 'dwarf')">
                            <collectorOption option="stackwalk">offline</collectorOption>
                            <xsl:if test="exsl:ctx('stackTypeCollect', '') = 'software_lbr'">
                              <xsl:if test="contains(exsl:ctx('LinuxPerfStackCapabilities', ''), 'lbr')">
                                <collectorOption option="stackwalk">lbr</collectorOption>
                              </xsl:if>
                            </xsl:if>
                          </xsl:when>
                          <xsl:otherwise>
                            <collectorOption option="stackwalk">online</collectorOption>
                          </xsl:otherwise>
                        </xsl:choose>
                      </xsl:if>
                  </xsl:when>
                  <xsl:otherwise>
                    <collectorOption option="no-stack"></collectorOption>
                  </xsl:otherwise>
                </xsl:choose>
                <xsl:if test="$isSystemWide and
                              not
                              (
                                (exsl:ctx('collectCallCounts', 0) or
                                exsl:ctx('collectTripCounts', 0)
                                ) and
                                exsl:ctx('targetOS', '')='Linux' and
                                exsl:ctx('OSBitness', '')='32'
                              )">
                  <xsl:choose>
                    <xsl:when test="exsl:ctx('LinuxPerfCredentials', 'NotAvailable')='Kernel' or
                                    exsl:ctx('LinuxPerfCredentials', 'NotAvailable')='User'">
                      <xsl:choose>
                        <xsl:when test="not(exsl:ctx('isSEPDriverAvailable', 0)) and not(exsl:ctx('enableStackCollection', 0))">
                          <xsl:choose>
                            <xsl:when test="not(exsl:ctx('collectCallCounts', 0) or exsl:ctx('collectTripCounts', 0))">
                              <xsl:value-of select="exsl:error('%PerfSystemWideNoPermAT')"/>
                            </xsl:when>
                            <xsl:otherwise>
                              <xsl:value-of select="exsl:error('%SepDriverUnavailable')"/>
                            </xsl:otherwise>
                          </xsl:choose>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:if test="not(exsl:ctx('collectCallCounts', 0) or exsl:ctx('collectTripCounts', 0))">
                              <xsl:value-of select="exsl:error('%PerfSystemWideNoPerm')"/>
                            </xsl:if>
                        </xsl:otherwise>
                      </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                      <collectorOption option="system-wide"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:if>
                <xsl:if test="exsl:ctx('perfPreferPerCpuSamplingMode', 0) and
                              not(exsl:ctx('useCountingMode', 0) or exsl:ctx('useAggregatedCounting', 0)) and
                             (exsl:ctx('LinuxPerfCredentials', 'NotAvailable')='Cpu' or
                              exsl:ctx('LinuxPerfCredentials', 'NotAvailable')='Unlimited')">
                  <collectorOption option="perf-per-cpu"/>
                </xsl:if>
                <xsl:choose>
                  <xsl:when test="exsl:ctx('collectHwTrace', '')">
                    <xsl:if test="not(contains(exsl:ctx('LinuxPerfCapabilities', 'NotAvailable'), 'intel_pt'))
                      or exsl:ctx('PMU') = 'broadwell'
                      or exsl:ctx('PMU') = 'broadwell_de'
                      or exsl:ctx('PMU') = 'broadwell_server'">
                        <xsl:value-of select="exsl:error('%IPTUnavailable')"/>
                    </xsl:if>
                    <collectorOption option="perf-event-config">intel_pt//uk</collectorOption>
                    <collectorOption option="sys-config">cswitch</collectorOption>
                  </xsl:when>
                  <xsl:when test="exsl:ctx('targetOS') != 'Android'">
                    <collectorOption option="perf-threads">cpu</collectorOption>
                    <collectorOption option="perf-compression">1</collectorOption>
                  </xsl:when>
                </xsl:choose>
              </xsl:when>
              <xsl:otherwise>
                <xsl:choose>
                  <xsl:when test="not(contains(exsl:ctx('LinuxPerfCapabilities', ''), 'format')) or
                    (exsl:ctx('LinuxPerfCredentials', 'NotAvailable')='User' and exsl:ctx('eventMode', '')='os')">
                    <xsl:choose>
                      <xsl:when test="$isSystemWide">
                        <xsl:choose>
                          <xsl:when test="not(exsl:ctx('isSEPDriverAvailable', 0)) and not(exsl:ctx('enableStackCollection', 0))">
                            <xsl:choose>
                              <xsl:when test="not(exsl:ctx('collectCallCounts', 0) or exsl:ctx('collectTripCounts', 0))">
                                <xsl:value-of select="exsl:error('%PerfSystemWideNoPermAT')"/>
                              </xsl:when>
                              <xsl:otherwise>
                                <xsl:value-of select="exsl:error('%SepDriverUnavailable')"/>
                              </xsl:otherwise>
                            </xsl:choose>
                          </xsl:when>
                          <xsl:otherwise>
                            <xsl:choose>
                              <xsl:when test="not(exsl:ctx('collectCallCounts', 0) or exsl:ctx('collectTripCounts', 0))">
                                <xsl:value-of select="exsl:error('%PerfSystemWideNoPerm')"/>
                              </xsl:when>
                              <xsl:otherwise>
                                <xsl:value-of select="exsl:error('%RunssUnsupportedTargetType')"/>
                              </xsl:otherwise>
                            </xsl:choose>
                          </xsl:otherwise>
                        </xsl:choose>
                      </xsl:when>
                      <xsl:otherwise>
                        <xsl:choose>
                          <xsl:when test="not(exsl:ctx('collectCallCounts', 0) or exsl:ctx('collectTripCounts', 0))">
                            <xsl:choose>
                              <xsl:when test="exsl:ctx('isVTSSPPDriverAvailable', 0) and exsl:ctx('enableStackCollection', 0)">
                                <xsl:value-of select="exsl:error('%PerfWithStacksNoPermAT')"/>
                              </xsl:when>
                              <xsl:otherwise>
                                <xsl:value-of select="exsl:error('%PerfNoPermAT')"/>
                              </xsl:otherwise>
                              </xsl:choose>
                          </xsl:when>
                          <xsl:otherwise>
                            <xsl:value-of select="exsl:error('%VTSSPPDriverUnavailable')"/>
                          </xsl:otherwise>
                        </xsl:choose>
                      </xsl:otherwise>
                    </xsl:choose>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:if test="exsl:ctx('targetType', '')='system' and
                                  exsl:ctx('enableStackCollection', 0)">
                      <xsl:value-of select="exsl:error('%RunssUnsupportedTargetType')"/>
                    </xsl:if>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:otherwise>
            </xsl:choose>
            <xsl:if test="exsl:ctx('areKernelPtrsRestricted', 'no')='yes'">
              <xsl:value-of select="exsl:warning('%KptrRestrictLimit')"/>
            </xsl:if>
            <xsl:if test="exsl:ctx('collectHwTrace', 0)">
              <xsl:value-of select="exsl:warning('%CollectingHugeData')"/>
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:if test="$doUseSEP">
              <xsl:if test="contains(exsl:ctx('Hypervisor', 'None'),'VMware') and (exsl:ctx('targetOS') = 'Windows')">
                <xsl:value-of select="exsl:error('%UnsupportedOnVMWare')"/>
              </xsl:if>
            </xsl:if>
            <xsl:choose>
              <xsl:when test="not(exsl:ctx('isSEPDriverAvailable', 0))">
                <xsl:choose>
                  <xsl:when test="exsl:ctx('connectionType', '') != 'tcp'">
                    <xsl:value-of select="exsl:error('%SepDriverUnavailable')"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="exsl:error('%CannotDetectTargetConfiguration')"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
              <xsl:otherwise>
                <xsl:if test="exsl:ctx('targetOS', '')='MacOSX' and not(exsl:ctx('RootPrivileges', 0))">
                  <xsl:value-of select="exsl:error('%SepRequiresRootPrivilegesOnMacOS')"/>
                </xsl:if>
              </xsl:otherwise>
            </xsl:choose>
            <xsl:if test="exsl:ctx('pmuSamplingInterval', 1.0) = 0.0">
              <xsl:value-of select="exsl:error('%IncorrectSamplingInterval')"/>
            </xsl:if>
            <xsl:if test="$doUseSEP">
              <xsl:variable name="minMajorVersion" select="number(5)"/>
              <xsl:variable name="minMinorVersion" select="number(10)"/>
              <xsl:variable name="sepVersion" select="string(exsl:ctx('SEPDriverVersion', ''))"/>
              <xsl:variable name="currentSepVersions" select="str:tokenize($sepVersion, '.')"/>
              <xsl:if test="exsl:ctx('eventMuxFactor', 0) and ((number($currentSepVersions[1]) &gt; $minMajorVersion) or
                (number($currentSepVersions[1]) = $minMajorVersion and number($currentSepVersions[2]) &gt; $minMinorVersion))">
                <collectorOption option="event-mux-factor"><xsl:value-of select="exsl:ctx('eventMuxFactor', 0)"/></collectorOption>
              </xsl:if>
            </xsl:if>
            <xsl:if test="$doUseVTSS">
              <xsl:if test="not(exsl:ctx('isVTSSPPDriverAvailable', 0))">
                <xsl:value-of select="exsl:error('%VTSSPPDriverUnavailable')"/>
              </xsl:if>
              <xsl:if test="$isSystemWide">
                <xsl:value-of select="exsl:error('%RunssUnsupportedTargetType')"/>
              </xsl:if>
              <collectorOption option="collector">vtsspp</collectorOption>
              <xsl:if test="exsl:ctx('analyzeActivePowerConsumption', 0)">
                <collectorOption option="pwr-config">active</collectorOption>
              </xsl:if>
              <xsl:if test="exsl:ctx('analyzeIdlePowerConsumption', 0)">
                <collectorOption option="pwr-config">idle</collectorOption>
              </xsl:if>
              <xsl:if test="exsl:ctx('enableCSwitch', 0)">
                <collectorOption option="sys-config">cswitch</collectorOption>
              </xsl:if>
              <xsl:if test="exsl:is_experimental('vtss-online-stackwalk')">
                <collectorOption option="stackwalk">online</collectorOption>
              </xsl:if>
              <xsl:if test="exsl:ctx('collectFullProcTrace', 0)">
                <collectorOption option="pt-mode">full-trace</collectorOption>
                <xsl:choose>
                  <xsl:when test="exsl:ctx('PMU') = 'goldmont' or exsl:ctx('PMU') = 'goldmont_plus'">
                    <collectorOption option="event-config">CPU_CLK_UNHALTED.CORE</collectorOption>
                  </xsl:when>
                  <xsl:otherwise>
                    <collectorOption option="event-config">CPU_CLK_UNHALTED.THREAD</collectorOption>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:if>
              <xsl:if test="exsl:ctx('enableCycleAccurateMode', 0)">
                <collectorOption option="pt-mode">cycle-accurate</collectorOption>
              </xsl:if>
              <xsl:if test="exsl:ctx('enableRing0ProfilingMode', 0)">
                <collectorOption option="pt-mode">kernel</collectorOption>
              </xsl:if>
              <xsl:choose>
                <xsl:when test="exsl:ctx('allowMultipleRuns', 0)">
                  <xsl:value-of select="exsl:error('%RunssUnsupportedMultipleRunsMode')"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:if test="not(exsl:ctx('enableStackCollection', 0))">
                    <collectorOption option="no-stack"></collectorOption>
                  </xsl:if>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:if>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <boolean:requestContextValues>true</boolean:requestContextValues>
      <property name="helpId">intel.phe.configs.new_cpu_event_collector_analysis_f1105</property>
      <xsl:if test="exsl:ctx('gpuUsage', 0) and exsl:ctx('targetOS')='Windows'">
        <xsl:variable name="gpu_usage" select="document('config://analysis_type/include/gpu_usage.xsl?errorLevel=error')"/>
        <xsl:variable name="gpuUsageErrorMessage" select="$gpu_usage//root/variables/gpuUsageErrorMessage"/>
        <xsl:variable name="gpuUsageAvailable" select="$gpu_usage//root/variables/gpuUsageAvailable"/>
        <xsl:if test="not($gpuUsageAvailable = 'true')">
          <xsl:choose>
            <xsl:when test="not(exsl:ctx('errorsAsWarnings', 0))">
              <xsl:value-of select="exsl:error(string($gpuUsageErrorMessage))"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="exsl:warning(string($gpuUsageErrorMessage))"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:if>
        <xsl:if test="$gpuUsageAvailable">
          <collectorOption option="etw-config">dma,frames</collectorOption>
        </xsl:if>
      </xsl:if>
      <xsl:variable name="collectorCommon">
        <xsl:value-of select="concat('config://collector/include/common.xsl?runtool=runsa&amp;isVTSSFlow=', $doUseVTSS)"/>
      </xsl:variable>
      <xsl:copy-of select="document($collectorCommon)//common/collector/*"/>
      <xsl:if test="exsl:ctx('collectTripCounts', 0) and $isTripCountsAvailable='false'">
        <xsl:value-of select="exsl:error('%TripCountsCanNotBeEstimated')"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('connectionType', '') = 'mic' and exsl:ctx('collectCallCounts', 0)">
        <xsl:value-of select="exsl:error('%CallCountsIsNotPossibleForNativeMIC')"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('connectionType', '') = 'mic-offload'">
        <xsl:if test="$doUseVTSS">
          <xsl:value-of select="exsl:error('%VTSSIsNotPossibleForOffloadMIC')"/>
        </xsl:if>
      </xsl:if>
      <xsl:if test="exsl:ctx('pmuEventConfig', '')">
        <collectorOption option="event-config"><xsl:copy-of select="exsl:ctx('pmuEventConfig', '')"/></collectorOption>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="exsl:ctx('collectMemBandwidth', 0) and $memBandwidthEvents != ''">
          <xsl:choose>
            <xsl:when test="$MemoryBandwidthError != '' ">
              <xsl:for-each select="exsl:node-set($MemoryBandwidthError)/stackError">
                <xsl:variable name="MemoryBandwidthErrorItem">
                  <xsl:value-of select="current()"/>
                </xsl:variable>
                <xsl:choose>
                  <xsl:when test="exsl:ctx('errorsAsWarnings', 0)">
                    <xsl:value-of select="exsl:warning($MemoryBandwidthErrorItem)"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="exsl:error($MemoryBandwidthErrorItem)"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:for-each>
            </xsl:when>
            <xsl:otherwise>
              <xsl:if test="not(exsl:ctx('explicitUncoreEventsConfig', 0))">
                <collectorOption option="event-config"><xsl:value-of select="$memBandwidthEvents"/></collectorOption>
                <xsl:if test="$qpiBandwidthEvents != '' and (exsl:ctx('isSEPDriverAvailable', 0) or contains(exsl:ctx('LinuxPerfCapabilities', 'NotAvailable'), 'uncore_qpi') or contains(exsl:ctx('LinuxPerfCapabilities', 'NotAvailable'), 'uncore_upi'))">
                  <collectorOption option="event-config"><xsl:value-of select="$qpiBandwidthEvents"/></collectorOption>
                </xsl:if>
              </xsl:if>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:when test="exsl:ctx('collectCallCounts', 0) or exsl:ctx('collectTripCounts', 0)">
          <collectorOption option="event-config"><xsl:value-of select="$callCountsEvents"/></collectorOption>
          <xsl:if test="not(exsl:ctx('PMU') = 'silvermont' or exsl:ctx('PMU') = 'airmont' or exsl:ctx('PMU') = 'nhm' or exsl:ctx('PMU') = 'corei7' or exsl:ctx('PMU') = 'corei7wsp' or exsl:ctx('PMU') = 'corei7wdp' or exsl:ctx('PMU') = 'corei7b')">
            <collectorOption option="bts-count">200</collectorOption>
          </xsl:if>
        </xsl:when>
      </xsl:choose>
      <xsl:if test="exsl:ctx('collectPCIeBandwidth', 0)">
        <xsl:if test="not(exsl:ctx('explicitUncoreEventsConfig', 0)) and $PCIeBandwidthEvents != ''">
          <collectorOption option="event-config"><xsl:value-of select="$PCIeBandwidthEvents"/></collectorOption>
        </xsl:if>
      </xsl:if>
      <xsl:if test="exsl:ctx('collectCAT', 0) and $cacheUsageEvents != ''">
        <xsl:choose>
          <xsl:when test="$doUseSEP">
            <xsl:choose>
              <xsl:when test="exsl:ctx('useEventBasedCounts', 0)">
                <xsl:value-of select="exsl:warning('%CATUnavailableInEBC')"/>
              </xsl:when>
              <xsl:otherwise>
                <collectorOption option="event-mux-trigger"><xsl:value-of select="$refClkEvent"/></collectorOption>
                <collectorOption option="event-config"><xsl:value-of select="$cacheUsageEvents"/></collectorOption>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="exsl:warning('%CATUnavailable')"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <xsl:if test="exsl:ctx('platformType', 0) != '0' and exsl:ctx('powerProfilingMode', 'none') = 'none'">
          <collectorOption option="platform-type"><xsl:copy-of select="exsl:ctx('platformType', '')"/></collectorOption>
      </xsl:if>
      <xsl:if test="exsl:ctx('collectTSXCycles', 0)">
        <xsl:if test="$doUseVTSS">
          <xsl:value-of select="exsl:error('%NoCallStacksForTSXCycles')"/>
        </xsl:if>
        <collectorOption option="event-config">CPU_CLK_UNHALTED.THREAD_P:cp,CPU_CLK_UNHALTED.THREAD_P:tx</collectorOption>
      </xsl:if>
      <xsl:if test="exsl:ctx('collectPreciseClockticks', 0)">
        <collectorOption option="event-config"><xsl:value-of select="$peciseClockticksEvent"/></collectorOption>
      </xsl:if>
      <xsl:if test="exsl:ctx('cpuMask', '')">
        <collectorOption option="cpu-mask"><xsl:copy-of select="exsl:ctx('cpuMask', '')"/></collectorOption>
      </xsl:if>
      <xsl:if test="exsl:ctx('useEventBasedCounts', 0)">
        <collectorOption option="event-based-counts"/>
        <collectorOption option="event-mux-trigger"><xsl:value-of select="$refClkEvent"/></collectorOption>
      </xsl:if>
      <xsl:if test="exsl:ctx('enableHWBasedCSCollection', 0)">
        <xsl:choose>
          <xsl:when test="$doUseSEP">
            <xsl:variable name="ring123Event" select="$pmuCommon//variables/ring123Event"/>
            <collectorOption option="event-config"><xsl:value-of select="$ring123Event"/></collectorOption>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="exsl:error('%EnableHWBasedCSCollectionError')"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <xsl:if test="exsl:ctx('isVTSSPPDriverAvailable', 0) or
                exsl:ctx('isSEPDriverAvailable', 0) or
                exsl:ctx('LinuxPerfCredentials', 'NotAvailable')!='NotAvailable' and contains(exsl:ctx('LinuxPerfCapabilities', ''), 'format')">
        <xsl:if test="not(exsl:ctx('targetDurationType', '') = 'short')">
          <xsl:choose>
            <xsl:when test="exsl:ctx('pmuSamplingInterval', 1.0) = 1.0">
              <xsl:value-of select="exsl:warning('%DurationTypeDeprecated')"/>
              <xsl:choose>
                <xsl:when test="exsl:ctx('targetDurationType', '') = 'veryshort'">
                  <collectorOption option="sample-after-multiplier">0.1</collectorOption>
                </xsl:when>
                <xsl:when test="exsl:ctx('targetDurationType', '') = 'medium'">
                  <collectorOption option="sample-after-multiplier">10.0</collectorOption>
                </xsl:when>
                <xsl:when test="exsl:ctx('targetDurationType', '') = 'long'">
                  <collectorOption option="sample-after-multiplier">100.0</collectorOption>
                </xsl:when>
              </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="exsl:warning('%DurationTypeIgnored')"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:if>
      </xsl:if>
      <xsl:if test="not(exsl:ctx('useCountingMode', 0))">
        <xsl:choose>
          <xsl:when test="exsl:ctx('useAggregatedCounting', 0)">
            <xsl:if test="exsl:ctx('isSEPDriverAvailable', 0) and (not(exsl:ctx('usePerf', 0)) or exsl:ctx('targetOS', '') = 'Windows' or exsl:ctx('targetOS', '') = 'MacOSX' or exsl:ctx('targetOS', '') = 'FreeBSD')">
              <collectorOption option="collector">emon</collectorOption>
            </xsl:if>
            <collectorOption option="aggregated-counting"/>
          </xsl:when>
          <xsl:when test="exsl:ctx('targetOS')='Linux' and contains(exsl:ctx('Hypervisor', 'None'),'xen')">
            <xsl:if test="not(exsl:ctx('pmuSamplingInterval', 1.0) = 0.0)">
               <xsl:value-of select="exsl:warning('%XenForceZeroSamplingInterval')"/>
            </xsl:if>
            <collectorOption option="sample-after-multiplier">0.0</collectorOption>
          </xsl:when>
          <xsl:otherwise>
            <xsl:if test="not(exsl:ctx('pmuSamplingInterval', 1.0) = 1.0)">
              <collectorOption option="sample-after-multiplier"><xsl:value-of select="format-number(exsl:ctx('pmuSamplingInterval', 1), '#.####')"/></collectorOption>
            </xsl:if>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <collectorOption option="uncore-sampling-interval"><xsl:copy-of select="exsl:ctx('uncoreSamplingInterval', 10)"/></collectorOption>
      <xsl:if test="exsl:ctx('emonPreset', '')">
        <collectorOption option="collector">emon</collectorOption>
        <collectorOption option="emon-preset"><xsl:copy-of select="exsl:ctx('emonPreset', '')"/></collectorOption>
      </xsl:if>
      <xsl:if test="exsl:ctx('emonCSVTraceFormat', 0)">
        <collectorOption option="emon-csv-trace-format"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('emonMachineReadableVersionFile', 0)">
        <collectorOption option="emon-machine-readable-ver"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('useCountingMode', 0)">
        <collectorOption option="count"/>
        <xsl:if test="exsl:ctx('isSEPDriverAvailable', 0) and (not(exsl:ctx('usePerf', 0)) or exsl:ctx('targetOS', '') = 'Windows' or exsl:ctx('targetOS', '') = 'MacOSX' or exsl:ctx('targetOS', '') = 'FreeBSD')">
          <collectorOption option="collector">emon</collectorOption>
        </xsl:if>
      </xsl:if>
      <xsl:if test="exsl:ctx('enablePEBSCollection', 0)">
        <collectorOption option="full-pebs-capture"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('targetOS')='Windows' and not(exsl:ctx('AdministratorPrivileges', 'false'))">
        <xsl:value-of select="exsl:error('%DriverPermissionErrorWindows')"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('pmuEventConfig', '') or exsl:ctx('collectPreciseClockticks', 0)">
        <xsl:if test="exsl:ctx('allowMultipleRuns', 0)">
          <xsl:if test="exsl:ctx('targetType', '') != 'launch'">
            <xsl:value-of select="exsl:error('%RunsaUnsupportedTargetTypeForMultiRunMode')"/>
          </xsl:if>
          <xsl:if test="exsl:ctx('targetOS', '') = 'Linux' and not(exsl:ctx('isSEPDriverAvailable', 0))">
            <xsl:value-of select="exsl:error('%NoSEPUnsupportedMultipleRunsMode')"/>
          </xsl:if>
        </xsl:if>
        <xsl:if test="exsl:ctx('forceMuxOff', 0)">
          <collectorOption option="allow-multiple-runs"/>
        </xsl:if>
      </xsl:if>
      <xsl:if test="not(exsl:ctx('followChild', 0))">
        <collectorOption option="no-follow-child"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('targetOS', '') = 'Linux' and exsl:ctx('analyzeKvmGuest', 0)">
        <xsl:choose>
          <xsl:when test="exsl:ctx('kvmGuestKallsyms', '') or exsl:ctx('kvmGuestModules', '')">
            <xsl:if test="exsl:ctx('collectMemBandwidth', 0)">
              <xsl:value-of select="exsl:error('%KvmGuestAndMemBwNotSupported')"/>
            </xsl:if>
            <xsl:if test="exsl:ctx('analyzeActivePowerConsumption', 0) or exsl:ctx('analyzeIdlePowerConsumption', 0)">
              <xsl:value-of select="exsl:error('%KvmGuestAndPowerNotSupported')"/>
            </xsl:if>
            <xsl:if test="exsl:ctx('collectCallCounts', 0) or exsl:ctx('collectTripCounts', 0)">
              <xsl:value-of select="exsl:error('%KvmGuestAndCountNotSupported')"/>
            </xsl:if>
            <collectorOption option="collector">perf</collectorOption>
            <collectorOption option="kvm-guest"/>
            <xsl:choose>
              <xsl:when test="exsl:ctx('kvmGuestKallsyms', '')">
                <collectorOption option="kvm-guest-kallsyms"><xsl:copy-of select="exsl:ctx('kvmGuestKallsyms', '')"/></collectorOption>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="exsl:warning('%KvmGuestWithoutKallsyms')"/>
              </xsl:otherwise>
            </xsl:choose>
            <xsl:choose>
              <xsl:when test="exsl:ctx('kvmGuestModules', '')">
                <collectorOption option="kvm-guest-modules"><xsl:copy-of select="exsl:ctx('kvmGuestModules', '')"/></collectorOption>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="exsl:warning('%KvmGuestWithoutModules')"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="exsl:error('%KvmGuestWithoutSymbols')"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <xsl:if test="exsl:ctx('enableLBRCollection', 0)">
        <collectorOption option="last-branch-records"/>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="exsl:ctx('targetOS') = 'Windows'">
          <xsl:choose>
            <xsl:when test="exsl:ctx('targetType', '') = 'system'">
              <xsl:choose>
                <xsl:when test="exsl:ctx('mrteMode', '') = 'mixed'">
                  <xsl:value-of select="exsl:warning('%SepSupportsMrteMixedUnderLaunchAndAttachModeOnly')"/>
                  <collectorOption option="mrte-mode">native</collectorOption>
                </xsl:when>
                <xsl:when test="exsl:ctx('mrteMode', '') = 'managed'">
                  <xsl:value-of select="exsl:error('%SepSupportsNativeOrMixedMrteModeOnly')"/>
                </xsl:when>
                <xsl:otherwise>
                  <collectorOption option="mrte-mode"><xsl:copy-of select="exsl:ctx('mrteMode', '')"/></collectorOption>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
              <xsl:choose>
                <xsl:when test="exsl:ctx('mrteMode', '') = 'managed'">
                  <xsl:value-of select="exsl:warning('%SepSupportsNativeOrMixedMrteModeOnly')"/>
                  <collectorOption option="mrte-mode">mixed</collectorOption>
                </xsl:when>
                <xsl:otherwise>
                  <collectorOption option="mrte-mode"><xsl:copy-of select="exsl:ctx('mrteMode', '')"/></collectorOption>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:when test="exsl:ctx('targetOS') = 'Android'">
          <collectorOption option="mrte-mode"><xsl:copy-of select="exsl:ctx('mrteMode', '')"/></collectorOption>
        </xsl:when>
        <xsl:when test="exsl:ctx('mrteMode', '') = 'managed' or exsl:ctx('mrteMode', '') = 'mixed'">
          <xsl:value-of select="exsl:warning('%SepSupportsMrteNativeOnlyOnLinux')"/>
        </xsl:when>
        <xsl:otherwise>
          <collectorOption option="mrte-mode"><xsl:copy-of select="exsl:ctx('mrteMode', '')"/></collectorOption>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:if test="exsl:ctx('isSEPDriverAvailable', 0) and not(exsl:ctx('followChild', 0))">
        <xsl:value-of select="exsl:warning('%EbsNotFollowingChildUnsupported')"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('collectUserTasksEventsCountersMode', 0)">
        <xsl:if test="exsl:ctx('targetOS') != 'FreeBSD'">
          <collectorOption option="itt-config">task,event,counter</collectorOption>
        </xsl:if>
      </xsl:if>
      <xsl:if test="exsl:ctx('targetOS') = 'Windows'">
        <xsl:choose>
          <xsl:when test="exsl:ctx('isEtwCLRSupported', '') = 'yes' and exsl:ctx('powerProfilingMode', 'none') = 'none'">
            <collectorOption option="etw-config">clr,js</collectorOption>
          </xsl:when>
        </xsl:choose>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="exsl:ctx('targetOS') = 'Windows' and exsl:ctx('HypervisorType', 'None') = 'Hyper-V'">
          <xsl:choose>
            <xsl:when test="(exsl:ctx('PMU') = 'core2'
              or exsl:ctx('PMU') = 'core2p'
              or exsl:ctx('PMU') = 'corei7'
              or exsl:ctx('PMU') = 'corei7wsp'
              or exsl:ctx('PMU') = 'corei7wdp'
              or exsl:ctx('PMU') = 'corei7b'
              or exsl:ctx('PMU') = 'snb'
              or exsl:ctx('PMU') = 'snbep'
              or exsl:ctx('PMU') = 'ivytown'
              or exsl:ctx('PMU') = 'ivybridge'
              or exsl:ctx('PMU') = 'haswell'
              or exsl:ctx('PMU') = 'haswell_server'
              or exsl:ctx('PMU') = 'silvermont'
              or exsl:ctx('PMU') = 'airmont'
              or exsl:ctx('PMU') = 'crystalwell'
              or exsl:ctx('PMU') = 'atom'
              or exsl:ctx('PMU') = 'airmont'
              or exsl:ctx('PMU') = 'broadwell'
              or exsl:ctx('PMU') = 'broadwell_de'
              or exsl:ctx('PMU') = 'broadwell_server'
              or exsl:ctx('PMU') = 'knl'
              or 16299 > exsl:ctx('OSBuildNumber', '16299'))">
              <xsl:value-of select="exsl:error('%HyperVOldSystemWarning')"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:choose>
                <xsl:when test="exsl:ctx('isDeviceOrCredentialGuardEnabled', 0)">
                  <xsl:value-of select="exsl:warning('%HyperVGuardsWarning')"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:if  test="exsl:ctx('PerfmonVersion', '4') = '0'">
                    <xsl:value-of select="exsl:error('%PerfMonVersionWarning')"/>
                  </xsl:if>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:if  test="exsl:ctx('PerfmonVersion', '4') = '0' and exsl:ctx('HypervisorType', 'None') != 'ACRN'">
            <xsl:value-of select="exsl:error('%PerfMonVersionWarning')"/>
          </xsl:if>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:choose>
        <xsl:when test="exsl:ctx('HypervisorType', 'None') = 'ACRN'">
          <collectorOption option="acrn-map-info"></collectorOption>
          <collectorOption option="stdsrc-config">cswitch</collectorOption>
        </xsl:when>
        <xsl:otherwise>
          <xsl:if test="exsl:ctx('systemWideContextSwitch', 0)">
            <xsl:choose>
              <xsl:when test="not($doUseVTSS)">
                <xsl:choose>
                  <xsl:when test="exsl:ctx('targetOS')!='Windows'">
                    <xsl:choose>
                      <xsl:when test="exsl:ctx('isCSwitchAvailable', '')='yes'">
                        <collectorOption option="stdsrc-config">cswitch</collectorOption>
                      </xsl:when>
                      <xsl:otherwise>
                        <xsl:for-each select="str:tokenize(exsl:ctx('isFtraceAvailableKnob',''), ',')">
                          <xsl:variable name="cswitchFtraceStatus">
                            <xsl:choose>
                              <xsl:when test=".='debugfsNotExists'">%CswitchDebugFSExistenceError</xsl:when>
                              <xsl:when test=".='debugfsNotAccessible'">%CswitchDebugFSAccessError</xsl:when>
                              <xsl:when test=".='debugfsOffInConfigs'">%CswitchDebugFSConfigError</xsl:when>
                              <xsl:when test=".='debugfsIsNotValidFsType'">%CswitchDebugFSInvalidTypeError</xsl:when>
                              <xsl:when test=".='ftraceAccessError'">
                                <xsl:choose>
                                  <xsl:when test="not(contains(exsl:ctx('isFtraceAvailableKnob',''), 'debugfs'))">%CswitchFtraceAccessError</xsl:when>
                                  <xsl:otherwise>notErrorOrWarning</xsl:otherwise>
                                </xsl:choose>
                              </xsl:when>
                              <xsl:when test=".='ftraceConfigError'">%CswitchFtraceConfigError</xsl:when>
                              <xsl:when test=".='ftraceUnknownError'">%CswitchFtraceUnknownError</xsl:when>
                              <xsl:when test=".='yes'">yes</xsl:when>
                            </xsl:choose>
                          </xsl:variable>
                          <xsl:if test="( $cswitchFtraceStatus != 'yes' )">
                            <xsl:choose>
                              <xsl:when test="$cswitchFtraceStatus = 'notErrorOrWarning'"></xsl:when>
                              <xsl:when test="exsl:ctx('errorsAsWarnings',0)">
                                <xsl:value-of select="exsl:warning($cswitchFtraceStatus)"/>
                              </xsl:when>
                              <xsl:otherwise>
                                <xsl:value-of select="exsl:error($cswitchFtraceStatus)"/>
                              </xsl:otherwise>
                            </xsl:choose>
                          </xsl:if>
                        </xsl:for-each>
                      </xsl:otherwise>
                    </xsl:choose>
                  </xsl:when>
                  <xsl:otherwise>
                    <collectorOption option="stdsrc-config">cswitch</collectorOption>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
              <xsl:otherwise>
                <xsl:if test="not(exsl:ctx('errorsAsWarnings', 0))">
                  <xsl:value-of select="exsl:error('%RunssUnsupportedSystemWideContextSwitchesMode')"/>
                </xsl:if>
                <xsl:value-of select="exsl:warning('%RunssUnsupportedSystemWideContextSwitchesMode')"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:if>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:if test="exsl:ctx('customCollector', '')">
        <collectorOption option="custom-collector"><xsl:copy-of select="exsl:ctx('customCollector', '')"/></collectorOption>
      </xsl:if>
      <xsl:if test="exsl:is_experimental('platform-profiling')">
        <xsl:if test="not(exsl:ctx('eventInfo', 0))">
          <collectorOption option="event-info">false</collectorOption>
        </xsl:if>
      </xsl:if>
      <xsl:choose>
        <xsl:when test="$doUsePerf and
                        exsl:ctx('LinuxPerfCredentials', 'NotAvailable')='User' and
                        not($isSystemWide)">
          <xsl:if test="exsl:ctx('eventMode', '')='all'">
            <collectorOption option="user-mode-only"/>
            <xsl:value-of select="exsl:warning('%PerfSettingEventModeToUser')"/>
          </xsl:if>
        </xsl:when>
        <xsl:otherwise>
          <xsl:if test="exsl:ctx('eventMode', '') != 'all'">
            <xsl:choose>
              <xsl:when test="exsl:ctx('eventMode', '') = 'user'">
                <collectorOption option="user-mode-only"/>
              </xsl:when>
              <xsl:otherwise>
                <collectorOption option="os-mode-only"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:if>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:if test="exsl:ctx('chipsetEventConfig', '')">
        <collectorOption option="chipset-event-config"><xsl:copy-of select="exsl:ctx('chipsetEventConfig', '')"/></collectorOption>
      </xsl:if>
      <xsl:if test="exsl:ctx('enableStackCollection', 0)">
        <xsl:choose>
          <xsl:when test="exsl:ctx('stackSize', 0) != 0">
            <collectorOption option="stack-size"><xsl:copy-of select="exsl:ctx('stackSize', 0)"/></collectorOption>
          </xsl:when>
          <xsl:when test="exsl:ctx('targetOS', '')='FreeBSD'">
          </xsl:when>
          <xsl:otherwise>
            <xsl:choose>
              <xsl:when test="$isSystemWide and exsl:ctx('stackTypeCollect', '') != 'lbr'">
                <xsl:choose>
                  <xsl:when test="exsl:ctx('targetOS') = 'Windows'">
                    <xsl:value-of select="exsl:error('%SystemWideCannoCollectStackWindows')"/>
                  </xsl:when>
                  <xsl:otherwise>
                    <xsl:value-of select="exsl:error('%SystemWideCannotSetUnlimitedStackSize')"/>
                  </xsl:otherwise>
                </xsl:choose>
              </xsl:when>
              <xsl:when test="$doUsePerf">
                <xsl:value-of select="exsl:error('%PerfCannotSetUnlimitedStackSize')"/>
              </xsl:when>
            </xsl:choose>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <xsl:variable name="perfContextSwitchesState" select="$commonDoc//common/variables/perfContextSwitchesState"/>
      <xsl:variable name="perfContextSwitchesDisabledByCredentials" select="$commonDoc//common/variables/perfContextSwitchesDisabledByCredentials"/>
      <xsl:variable name="canUsePerfForContextSwitchesWithTypes" select="$commonDoc//common/variables/canUsePerfForContextSwitchesWithTypes"/>
      <xsl:if test="$doUsePerf and $perfContextSwitchesState!='available' and exsl:ctx('enableCSwitch', 0)">
        <xsl:choose>
          <xsl:when test="exsl:ctx('isVTSSPPDriverAvailable', 0)">
            <xsl:value-of select="exsl:warning('%PerfUseVTSSForContextSwitches')"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:if test="$perfContextSwitchesState='oldKernel'">
              <xsl:value-of select="exsl:warning('%PerfNoCSwitchOnThisKernel')"/>
            </xsl:if>
            <xsl:if test="$perfContextSwitchesState='restrictedCredentials'">
              <xsl:value-of select="exsl:warning('%PerfNoCSwitchBecausePerfParanoid')"/>
            </xsl:if>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <xsl:if test="$doUsePerf and $perfContextSwitchesState='available' and exsl:ctx('enableCSwitch', 0) and
                   $canUsePerfForContextSwitchesWithTypes='false'">
          <xsl:value-of select="exsl:warning('%PerfContextSwitcheTypesMightBeUnavailable')"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('targetOS') != 'Windows' and exsl:ctx('systemWideDiskIO', '')">
        <xsl:for-each select="str:tokenize(exsl:ctx('isFtraceAvailableKnob',''), ',')">
          <xsl:variable name="fraceStatus">
            <xsl:choose>
              <xsl:when test=".='debugfsNotExists'">%DebugFSExistenceError</xsl:when>
              <xsl:when test=".='debugfsNotAccessible'">%DebugFSAccessError</xsl:when>
              <xsl:when test=".='debugfsOffInConfigs'">%DebugFSConfigError</xsl:when>
              <xsl:when test=".='debugfsIsNotValidFsType'">%DebugFSInvalidTypeError</xsl:when>
              <xsl:when test=".='ftraceAccessError'">
                <xsl:choose>
                  <xsl:when test="not(contains(exsl:ctx('isFtraceAvailableKnob',''), 'debugfs'))">%FtraceAccessError</xsl:when>
                  <xsl:otherwise>notErrorOrWarning</xsl:otherwise>
                </xsl:choose>
              </xsl:when>
              <xsl:when test=".='ftraceConfigError'">%FtraceConfigError</xsl:when>
              <xsl:when test=".='ftraceUnknownError'">%FtraceUnknownError</xsl:when>
              <xsl:when test=".='yes'">yes</xsl:when>
            </xsl:choose>
          </xsl:variable>
          <xsl:if test="( $fraceStatus != 'yes' )">
            <xsl:choose>
              <xsl:when test="$fraceStatus = 'notErrorOrWarning'"></xsl:when>
              <xsl:when test="exsl:ctx('errorsAsWarnings',0)">
                <xsl:value-of select="exsl:warning($fraceStatus)"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:value-of select="exsl:error($fraceStatus)"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:if>
        </xsl:for-each>
      </xsl:if>
      <xsl:if test="exsl:ctx('targetType', '') = 'launch' or exsl:ctx('targetType', '') = 'attach'">
        <xsl:choose>
          <xsl:when test="exsl:ctx('targetOS')!='Android'">
            <xsl:if test="not(exsl:ctx('followChild', 0))">
              <collectorOption option="no-follow-child"/>
            </xsl:if>
            <xsl:if test="exsl:ctx('followChildStrategy', '')">
              <collectorOption option="strategy"><xsl:copy-of select="exsl:ctx('followChildStrategy', '')"/></collectorOption>
            </xsl:if>
          </xsl:when>
        </xsl:choose>
      </xsl:if>
      <xsl:if test="exsl:ctx('targetOS')='Linux' and exsl:ctx('enableOpenglesInstrumentation', 0)">
         <collectorOption option="type">opengles</collectorOption>
      </xsl:if>
      <xsl:if test="exsl:ctx('targetType', '') = 'attach' and exsl:ctx('dramBandwidthLimits', 0)">
        <xsl:value-of select="exsl:warning('%DramBandwidthLimitsAttachWarning')"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('collectMemBandwidth', 0) and exsl:ctx('enableDramBandwidthLimitsWarning', 0)
        and not(exsl:ctx('dramBandwidthLimits', 0))
        and ((exsl:ctx('targetOS')='Windows' or exsl:ctx('targetOS')='Linux') and exsl:ctx('PMU') != 'knl')">
        <xsl:value-of select="exsl:warning('%DramBandwidthLimitsNotEnabledWarning')"/>
      </xsl:if>
      <xsl:if test="exsl:ctx('systemCollectorConfig', '') != ''">
        <collectorOption option="system-collector-config">
           <xsl:value-of select="exsl:ctx('systemCollectorConfig', '')"/>
        </collectorOption>
      </xsl:if>
      <xsl:if test="exsl:ctx('collectPStateData', 0) and not(exsl:ctx('useEventBasedCounts', 0))">
        <xsl:choose>
          <xsl:when test="exsl:ctx('isPStateAvailable', 0)">
            <collectorOption option="p-state-trigger"><xsl:value-of select="$refClkEvent"/></collectorOption>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="exsl:warning('%PStateNotAvailableWarning')"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
      <xsl:variable name="isSystemWideForced" select="string($commonDoc//common/variables/isSystemWideForced)"/>
      <xsl:if test="$isSystemWideForced">
        <xsl:value-of select="exsl:warning('%ForceSystemWideWarning')"/>
      </xsl:if>
    </collector>
    <xsl:if test="exsl:ctx('PMU') = 'corei7' or exsl:ctx('PMU') = 'corei7wsp' or exsl:ctx('PMU') = 'corei7wdp' or exsl:ctx('PMU') = 'corei7b'">
      <xsl:value-of select="exsl:warning('%Corei7SEPWarning')"/>
    </xsl:if>
    <xsl:if test="exsl:ctx('gpuProfilingMode', 'none') != 'none'">
      <xsl:if test="exsl:ctx('targetType', '') != 'launch'">
        <xsl:choose>
          <xsl:when test="exsl:ctx('targetType', '')='attach'">
            <xsl:value-of select="exsl:error('%RunssGpuProfilingAttachNotSupported')"/>
          </xsl:when>
          <xsl:when test="exsl:ctx('targetType', '')='system'">
            <xsl:value-of select="exsl:error('%RunssGpuProfilingSystemWideNotSupported')"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:value-of select="exsl:error('%RunssGpuProfilingNotSupported')"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:if>
    </xsl:if>
  </analysis>
  <finalization xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:exsl="http://exslt.org/common" exsl:keep_exsl_namespace="" syntax="norules">
    <xsl:variable name="finalizationCommon">
      <xsl:text>config://collector/include/common.xsl?runtool=runsa</xsl:text>
    </xsl:variable>
    <xsl:copy-of select="document($finalizationCommon)//common/finalization/*"/>
  </finalization>
</bag>
