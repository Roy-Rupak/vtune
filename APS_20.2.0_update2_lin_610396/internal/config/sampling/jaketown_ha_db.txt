# Performance Monitoring Events for Intel(R) Xeon(R) processor E5 family Based on the Sandy Bridge-EP Microarchitecture - V20
# 9/16/2016 11:34:57 AM
# Copyright (c) 2007 - 2016 Intel Corporation. All rights reserved.
UNIT	CODE	UMASK	NAME	DESCRIPTION	COUNTER	OTHER	FILTER	INTERNAL
HA	0x20	0x3	UNC_H_ADDR_OPC_MATCH.FILT	tbd	0,1,2,3	0x0	HA_AddrMatch0[31:6], HA_AddrMatch1[13:0], HA_OpcodeMatch[5:0]	0
HA	0x14	0x2	UNC_H_BYPASS_IMC.NOT_TAKEN	Counts the number of times when the HA was able to bypass was attempted.  This is a latency optimization for situations when there is light loadings on the memory subsystem.  This can be filted by when the bypass was taken and when it was not.	0,1,2,3	0x0	null	0
HA	0x14	0x1	UNC_H_BYPASS_IMC.TAKEN	Counts the number of times when the HA was able to bypass was attempted.  This is a latency optimization for situations when there is light loadings on the memory subsystem.  This can be filted by when the bypass was taken and when it was not.	0,1,2,3	0x0	null	0
HA	0x0	0x0	UNC_H_CLOCKTICKS	Counts the number of uclks in the HA.  This will be slightly different than the count in the Ubox because of enable/freeze delays.  The HA is on the other side of the die from the fixed Ubox uclk counter, so the drift could be somewhat larger than in units that are closer like the QPI Agent.	0,1,2,3	0x0	null	0
HA	0xb	0x2	UNC_H_CONFLICT_CYCLES.CONFLICT	tbd	0,1,2,3	0x0	null	0
HA	0xb	0x1	UNC_H_CONFLICT_CYCLES.NO_CONFLICT	tbd	0,1,2,3	0x0	null	0
HA	0x11	0x0	UNC_H_DIRECT2CORE_COUNT	Number of Direct2Core messages sent	0,1,2,3	0x0	null	0
HA	0x12	0x0	UNC_H_DIRECT2CORE_CYCLES_DISABLED	Number of cycles in which Direct2Core was disabled	0,1,2,3	0x0	null	0
HA	0x13	0x0	UNC_H_DIRECT2CORE_TXN_OVERRIDE	Number of Reads where Direct2Core overridden	0,1,2,3	0x0	null	0
HA	0xc	0x2	UNC_H_DIRECTORY_LOOKUP.NO_SNP	Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.	0,1,2,3	0x0	null	0
HA	0xc	0x1	UNC_H_DIRECTORY_LOOKUP.SNP	Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.	0,1,2,3	0x0	null	0
HA	0xd	0x3	UNC_H_DIRECTORY_UPDATE.ANY	Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.	0,1,2,3	0x0	null	0
HA	0xd	0x2	UNC_H_DIRECTORY_UPDATE.CLEAR	Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.	0,1,2,3	0x0	null	0
HA	0xd	0x1	UNC_H_DIRECTORY_UPDATE.SET	Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.	0,1,2,3	0x0	null	0
HA	0x22	0x1	UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI0	Counts the number of cycles when the HA does not have credits to send messages to the QPI Agent.  This can be filtered by the different credit pools and the different links.	0,1,2,3	0x0	null	0
HA	0x22	0x2	UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI1	Counts the number of cycles when the HA does not have credits to send messages to the QPI Agent.  This can be filtered by the different credit pools and the different links.	0,1,2,3	0x0	null	0
HA	0x22	0x4	UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI0	Counts the number of cycles when the HA does not have credits to send messages to the QPI Agent.  This can be filtered by the different credit pools and the different links.	0,1,2,3	0x0	null	0
HA	0x22	0x8	UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI1	Counts the number of cycles when the HA does not have credits to send messages to the QPI Agent.  This can be filtered by the different credit pools and the different links.	0,1,2,3	0x0	null	0
HA	0x1e	0x0	UNC_H_IMC_RETRY	tbd	0,1,2,3	0x0	null	0
HA	0x1a	0xf	UNC_H_IMC_WRITES.ALL	Counts the total number of full line writes issued from the HA into the memory controller.  This counts for all four channels.  It can be filtered by full/partial and ISOCH/non-ISOCH.	0,1,2,3	0x0	null	0
HA	0x1a	0x1	UNC_H_IMC_WRITES.FULL	Counts the total number of full line writes issued from the HA into the memory controller.  This counts for all four channels.  It can be filtered by full/partial and ISOCH/non-ISOCH.	0,1,2,3	0x0	null	0
HA	0x1a	0x4	UNC_H_IMC_WRITES.FULL_ISOCH	Counts the total number of full line writes issued from the HA into the memory controller.  This counts for all four channels.  It can be filtered by full/partial and ISOCH/non-ISOCH.	0,1,2,3	0x0	null	0
HA	0x1a	0x2	UNC_H_IMC_WRITES.PARTIAL	Counts the total number of full line writes issued from the HA into the memory controller.  This counts for all four channels.  It can be filtered by full/partial and ISOCH/non-ISOCH.	0,1,2,3	0x0	null	0
HA	0x1a	0x8	UNC_H_IMC_WRITES.PARTIAL_ISOCH	Counts the total number of full line writes issued from the HA into the memory controller.  This counts for all four channels.  It can be filtered by full/partial and ISOCH/non-ISOCH.	0,1,2,3	0x0	null	0
HA	0x1	0x3	UNC_H_REQUESTS.READS	Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).	0,1,2,3	0x0	null	0
HA	0x1	0xc	UNC_H_REQUESTS.WRITES	Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).	0,1,2,3	0x0	null	0
HA	0x3e	0x4	UNC_H_RING_AD_USED.CCW_EVEN	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x0	null	0
HA	0x3e	0x8	UNC_H_RING_AD_USED.CCW_ODD	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x0	null	0
HA	0x3e	0x1	UNC_H_RING_AD_USED.CW_EVEN	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x0	null	0
HA	0x3e	0x2	UNC_H_RING_AD_USED.CW_ODD	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x0	null	0
HA	0x3f	0x4	UNC_H_RING_AK_USED.CCW_EVEN	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x0	null	0
HA	0x3f	0x8	UNC_H_RING_AK_USED.CCW_ODD	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x0	null	0
HA	0x3f	0x1	UNC_H_RING_AK_USED.CW_EVEN	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x0	null	0
HA	0x3f	0x2	UNC_H_RING_AK_USED.CW_ODD	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x0	null	0
HA	0x40	0x4	UNC_H_RING_BL_USED.CCW_EVEN	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x0	null	0
HA	0x40	0x8	UNC_H_RING_BL_USED.CCW_ODD	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x0	null	0
HA	0x40	0x1	UNC_H_RING_BL_USED.CW_EVEN	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x0	null	0
HA	0x40	0x2	UNC_H_RING_BL_USED.CW_ODD	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x0	null	0
HA	0x15	0x1	UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN0	Counts the number of cycles when there are no 'regular' credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and 'special' requests such as ISOCH reads.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x15	0x2	UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN1	Counts the number of cycles when there are no 'regular' credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and 'special' requests such as ISOCH reads.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x15	0x4	UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN2	Counts the number of cycles when there are no 'regular' credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and 'special' requests such as ISOCH reads.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x15	0x8	UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN3	Counts the number of cycles when there are no 'regular' credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and 'special' requests such as ISOCH reads.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x16	0x1	UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN0	Counts the number of cycles when there are no 'special' credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and 'special' requests such as ISOCH reads.  This count only tracks the 'special' credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x16	0x2	UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN1	Counts the number of cycles when there are no 'special' credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and 'special' requests such as ISOCH reads.  This count only tracks the 'special' credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x16	0x4	UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN2	Counts the number of cycles when there are no 'special' credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and 'special' requests such as ISOCH reads.  This count only tracks the 'special' credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x16	0x8	UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN3	Counts the number of cycles when there are no 'special' credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and 'special' requests such as ISOCH reads.  This count only tracks the 'special' credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x1b	0x1	UNC_H_TAD_REQUESTS_G0.REGION0	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for 'Monroe' systems that use the TAD to enable individual channels to enter self-refresh to save power.	0,1,2,3	0x0	null	0
HA	0x1b	0x2	UNC_H_TAD_REQUESTS_G0.REGION1	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for 'Monroe' systems that use the TAD to enable individual channels to enter self-refresh to save power.	0,1,2,3	0x0	null	0
HA	0x1b	0x4	UNC_H_TAD_REQUESTS_G0.REGION2	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for 'Monroe' systems that use the TAD to enable individual channels to enter self-refresh to save power.	0,1,2,3	0x0	null	0
HA	0x1b	0x8	UNC_H_TAD_REQUESTS_G0.REGION3	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for 'Monroe' systems that use the TAD to enable individual channels to enter self-refresh to save power.	0,1,2,3	0x0	null	0
HA	0x1b	0x10	UNC_H_TAD_REQUESTS_G0.REGION4	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for 'Monroe' systems that use the TAD to enable individual channels to enter self-refresh to save power.	0,1,2,3	0x0	null	0
HA	0x1b	0x20	UNC_H_TAD_REQUESTS_G0.REGION5	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for 'Monroe' systems that use the TAD to enable individual channels to enter self-refresh to save power.	0,1,2,3	0x0	null	0
HA	0x1b	0x40	UNC_H_TAD_REQUESTS_G0.REGION6	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for 'Monroe' systems that use the TAD to enable individual channels to enter self-refresh to save power.	0,1,2,3	0x0	null	0
HA	0x1b	0x80	UNC_H_TAD_REQUESTS_G0.REGION7	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for 'Monroe' systems that use the TAD to enable individual channels to enter self-refresh to save power.	0,1,2,3	0x0	null	0
HA	0x1c	0x4	UNC_H_TAD_REQUESTS_G1.REGION10	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 8 to 10.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for 'Monroe' systems that use the TAD to enable individual channels to enter self-refresh to save power.	0,1,2,3	0x0	null	0
HA	0x1c	0x8	UNC_H_TAD_REQUESTS_G1.REGION11	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 8 to 10.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for 'Monroe' systems that use the TAD to enable individual channels to enter self-refresh to save power.	0,1,2,3	0x0	null	0
HA	0x1c	0x1	UNC_H_TAD_REQUESTS_G1.REGION8	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 8 to 10.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for 'Monroe' systems that use the TAD to enable individual channels to enter self-refresh to save power.	0,1,2,3	0x0	null	0
HA	0x1c	0x2	UNC_H_TAD_REQUESTS_G1.REGION9	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 8 to 10.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for 'Monroe' systems that use the TAD to enable individual channels to enter self-refresh to save power.	0,1,2,3	0x0	null	0
HA	0x6	0x3	UNC_H_TRACKER_INSERTS.ALL	Counts the number of allocations into the local HA tracker pool.  This can be used in conjunction with the occupancy accumulation event in order to calculate average latency.  One cannot filter between reads and writes.  HA trackers are allocated as soon as a request enters the HA and is released after the snoop response and data return (or post in the case of a write) and the response is returned on the ring.	0,1,2,3	0x0	null	0
HA	0xf	0x1	UNC_H_TxR_AD.NDR	Counts the number of outbound transactions on the AD ring.  This can be filtered by the NDR and SNP message classes.  See the filter descriptions for more details.	0,1,2,3	0x0	null	0
HA	0xf	0x2	UNC_H_TxR_AD.SNP	Counts the number of outbound transactions on the AD ring.  This can be filtered by the NDR and SNP message classes.  See the filter descriptions for more details.	0,1,2,3	0x0	null	0
HA	0x2a	0x3	UNC_H_TxR_AD_CYCLES_FULL.ALL	AD Egress Full	0,1,2,3	0x0	null	0
HA	0x2a	0x1	UNC_H_TxR_AD_CYCLES_FULL.SCHED0	AD Egress Full	0,1,2,3	0x0	null	0
HA	0x2a	0x2	UNC_H_TxR_AD_CYCLES_FULL.SCHED1	AD Egress Full	0,1,2,3	0x0	null	0
HA	0x29	0x3	UNC_H_TxR_AD_CYCLES_NE.ALL	AD Egress Not Empty	0,1,2,3	0x0	null	0
HA	0x29	0x1	UNC_H_TxR_AD_CYCLES_NE.SCHED0	AD Egress Not Empty	0,1,2,3	0x0	null	0
HA	0x29	0x2	UNC_H_TxR_AD_CYCLES_NE.SCHED1	AD Egress Not Empty	0,1,2,3	0x0	null	0
HA	0x27	0x3	UNC_H_TxR_AD_INSERTS.ALL	AD Egress Allocations	0,1,2,3	0x0	null	0
HA	0x27	0x1	UNC_H_TxR_AD_INSERTS.SCHED0	AD Egress Allocations	0,1,2,3	0x0	null	0
HA	0x27	0x2	UNC_H_TxR_AD_INSERTS.SCHED1	AD Egress Allocations	0,1,2,3	0x0	null	0
HA	0x28	0x3	UNC_H_TxR_AD_OCCUPANCY.ALL	AD Egress Occupancy	0,1,2,3	0x0	null	0
HA	0x28	0x1	UNC_H_TxR_AD_OCCUPANCY.SCHED0	AD Egress Occupancy	0,1,2,3	0x0	null	0
HA	0x28	0x2	UNC_H_TxR_AD_OCCUPANCY.SCHED1	AD Egress Occupancy	0,1,2,3	0x0	null	0
HA	0x32	0x3	UNC_H_TxR_AK_CYCLES_FULL.ALL	AK Egress Full	0,1,2,3	0x0	null	0
HA	0x32	0x1	UNC_H_TxR_AK_CYCLES_FULL.SCHED0	AK Egress Full	0,1,2,3	0x0	null	0
HA	0x32	0x2	UNC_H_TxR_AK_CYCLES_FULL.SCHED1	AK Egress Full	0,1,2,3	0x0	null	0
HA	0x31	0x3	UNC_H_TxR_AK_CYCLES_NE.ALL	AK Egress Not Empty	0,1,2,3	0x0	null	0
HA	0x31	0x1	UNC_H_TxR_AK_CYCLES_NE.SCHED0	AK Egress Not Empty	0,1,2,3	0x0	null	0
HA	0x31	0x2	UNC_H_TxR_AK_CYCLES_NE.SCHED1	AK Egress Not Empty	0,1,2,3	0x0	null	0
HA	0x2f	0x3	UNC_H_TxR_AK_INSERTS.ALL	AK Egress Allocations	0,1,2,3	0x0	null	0
HA	0x2f	0x1	UNC_H_TxR_AK_INSERTS.SCHED0	AK Egress Allocations	0,1,2,3	0x0	null	0
HA	0x2f	0x2	UNC_H_TxR_AK_INSERTS.SCHED1	AK Egress Allocations	0,1,2,3	0x0	null	0
HA	0xe	0x0	UNC_H_TxR_AK_NDR	Counts the number of outbound NDR transactions sent on the AK ring.  NDR stands for 'non-data response' and is generally used for completions that do not include data.  AK NDR is used for messages to the local socket.	0,1,2,3	0x0	null	0
HA	0x30	0x3	UNC_H_TxR_AK_OCCUPANCY.ALL	AK Egress Occupancy	0,1,2,3	0x0	null	0
HA	0x30	0x1	UNC_H_TxR_AK_OCCUPANCY.SCHED0	AK Egress Occupancy	0,1,2,3	0x0	null	0
HA	0x30	0x2	UNC_H_TxR_AK_OCCUPANCY.SCHED1	AK Egress Occupancy	0,1,2,3	0x0	null	0
HA	0x10	0x1	UNC_H_TxR_BL.DRS_CACHE	Counts the number of DRS messages sent out on the BL ring.   This can be filtered by the destination.	0,1,2,3	0x0	null	0
HA	0x10	0x2	UNC_H_TxR_BL.DRS_CORE	Counts the number of DRS messages sent out on the BL ring.   This can be filtered by the destination.	0,1,2,3	0x0	null	0
HA	0x10	0x4	UNC_H_TxR_BL.DRS_QPI	Counts the number of DRS messages sent out on the BL ring.   This can be filtered by the destination.	0,1,2,3	0x0	null	0
HA	0x36	0x3	UNC_H_TxR_BL_CYCLES_FULL.ALL	BL Egress Full	0,1,2,3	0x0	null	0
HA	0x36	0x1	UNC_H_TxR_BL_CYCLES_FULL.SCHED0	BL Egress Full	0,1,2,3	0x0	null	0
HA	0x36	0x2	UNC_H_TxR_BL_CYCLES_FULL.SCHED1	BL Egress Full	0,1,2,3	0x0	null	0
HA	0x35	0x3	UNC_H_TxR_BL_CYCLES_NE.ALL	BL Egress Not Empty	0,1,2,3	0x0	null	0
HA	0x35	0x1	UNC_H_TxR_BL_CYCLES_NE.SCHED0	BL Egress Not Empty	0,1,2,3	0x0	null	0
HA	0x35	0x2	UNC_H_TxR_BL_CYCLES_NE.SCHED1	BL Egress Not Empty	0,1,2,3	0x0	null	0
HA	0x33	0x3	UNC_H_TxR_BL_INSERTS.ALL	BL Egress Allocations	0,1,2,3	0x0	null	0
HA	0x33	0x1	UNC_H_TxR_BL_INSERTS.SCHED0	BL Egress Allocations	0,1,2,3	0x0	null	0
HA	0x33	0x2	UNC_H_TxR_BL_INSERTS.SCHED1	BL Egress Allocations	0,1,2,3	0x0	null	0
HA	0x34	0x3	UNC_H_TxR_BL_OCCUPANCY.ALL	BL Egress Occupancy	0,1,2,3	0x0	null	0
HA	0x34	0x1	UNC_H_TxR_BL_OCCUPANCY.SCHED0	BL Egress Occupancy	0,1,2,3	0x0	null	0
HA	0x34	0x2	UNC_H_TxR_BL_OCCUPANCY.SCHED1	BL Egress Occupancy	0,1,2,3	0x0	null	0
HA	0x18	0x1	UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN0	Counts the number of cycles when there are no 'regular' credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and 'special' requests such as ISOCH writes.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x18	0x2	UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN1	Counts the number of cycles when there are no 'regular' credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and 'special' requests such as ISOCH writes.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x18	0x4	UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN2	Counts the number of cycles when there are no 'regular' credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and 'special' requests such as ISOCH writes.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x18	0x8	UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN3	Counts the number of cycles when there are no 'regular' credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and 'special' requests such as ISOCH writes.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x19	0x1	UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN0	Counts the number of cycles when there are no 'special' credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and 'special' requests such as ISOCH writes.  This count only tracks the 'special' credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x19	0x2	UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN1	Counts the number of cycles when there are no 'special' credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and 'special' requests such as ISOCH writes.  This count only tracks the 'special' credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x19	0x4	UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN2	Counts the number of cycles when there are no 'special' credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and 'special' requests such as ISOCH writes.  This count only tracks the 'special' credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
HA	0x19	0x8	UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN3	Counts the number of cycles when there are no 'special' credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and 'special' requests such as ISOCH writes.  This count only tracks the 'special' credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.	0,1,2,3	0x0	null	0
