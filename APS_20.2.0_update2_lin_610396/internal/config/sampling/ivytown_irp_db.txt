# Performance Monitoring Events for Intel(R) Xeon(R) processor E5 family and Intel(R) Xeon(R) processor E7 family Based on the Ivy Bridge-EP Microarchitecture - V21
# 10/3/2018 10:48:35 PM
# Copyright (c) 2007 - 2017 Intel Corporation. All rights reserved.
UNIT	CODE	UMASK	NAME	DESCRIPTION	COUNTER	OTHER	FILTER	INTERNAL
IRP	0x0	0x0	UNC_I_CLOCKTICKS	Number of clocks in the IRP.	0,1	0x53	na	0
IRP	0x1	0x0	UNC_I_RxR_BL_DRS_INSERTS	Counts the number of allocations into the BL Ingress.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.	0,1	0x53	na	0
IRP	0x10	0x1	UNC_I_CACHE_READ_OCCUPANCY.ANY	Accumulates the number of reads that are outstanding in the uncore in each cycle.  This can be used with the read transaction count to calculate the average read latency in the uncore.  The occupancy increments when a read request is issued, and decrements when the data is returned.; Tracks all requests from any source port.	0,1	0x53	na	0
IRP	0x10	0x2	UNC_I_CACHE_READ_OCCUPANCY.SOURCE	Accumulates the number of reads that are outstanding in the uncore in each cycle.  This can be used with the read transaction count to calculate the average read latency in the uncore.  The occupancy increments when a read request is issued, and decrements when the data is returned.; Tracks only those requests that come from the port specified in the IRP_PmonFilter.OrderingQ register.  This register allows one to select one specific queue.  It is not possible to monitor multiple queues at a time.	0,1	0x53	na	0
IRP	0x11	0x1	UNC_I_CACHE_WRITE_OCCUPANCY.ANY	Accumulates the number of writes (and write prefetches)  that are outstanding in the uncore in each cycle.  This can be used with the transaction count event to calculate the average latency in the uncore.  The occupancy increments when the ownership fetch/prefetch is issued, and decrements the data is returned to the uncore.; Tracks all requests from any source port.	0,1	0x53	na	0
IRP	0x11	0x2	UNC_I_CACHE_WRITE_OCCUPANCY.SOURCE	Accumulates the number of writes (and write prefetches)  that are outstanding in the uncore in each cycle.  This can be used with the transaction count event to calculate the average latency in the uncore.  The occupancy increments when the ownership fetch/prefetch is issued, and decrements the data is returned to the uncore.; Tracks only those requests that come from the port specified in the IRP_PmonFilter.OrderingQ register.  This register allows one to select one specific queue.  It is not possible to monitor multiple queues at a time.	0,1	0x53	na	0
IRP	0x12	0x1	UNC_I_CACHE_TOTAL_OCCUPANCY.ANY	Accumulates the number of reads and writes that are outstanding in the uncore in each cycle.  This is effectively the sum of the READ_OCCUPANCY and WRITE_OCCUPANCY events.; Tracks all requests from any source port.	0,1	0x53	na	0
IRP	0x12	0x2	UNC_I_CACHE_TOTAL_OCCUPANCY.SOURCE	Accumulates the number of reads and writes that are outstanding in the uncore in each cycle.  This is effectively the sum of the READ_OCCUPANCY and WRITE_OCCUPANCY events.; Tracks only those requests that come from the port specified in the IRP_PmonFilter.OrderingQ register.  This register allows one to select one specific queue.  It is not possible to monitor multiple queues at a time.	0,1	0x53	na	0
IRP	0x13	0x1	UNC_I_CACHE_OWN_OCCUPANCY.ANY	Accumulates the number of writes (and write prefetches) that are outstanding in the uncore trying to acquire ownership in each cycle.  This can be used with the write transaction count to calculate the average write latency in the uncore.  The occupancy increments when a write request is issued, and decrements when the data is returned.; Tracks all requests from any source port.	0,1	0x53	na	0
IRP	0x13	0x2	UNC_I_CACHE_OWN_OCCUPANCY.SOURCE	Accumulates the number of writes (and write prefetches) that are outstanding in the uncore trying to acquire ownership in each cycle.  This can be used with the write transaction count to calculate the average write latency in the uncore.  The occupancy increments when a write request is issued, and decrements when the data is returned.; Tracks only those requests that come from the port specified in the IRP_PmonFilter.OrderingQ register.  This register allows one to select one specific queue.  It is not possible to monitor multiple queues at a time.	0,1	0x53	na	0
IRP	0x14	0x1	UNC_I_CACHE_ACK_PENDING_OCCUPANCY.ANY	Accumulates the number of writes that have acquired ownership but have not yet returned their data to the uncore.  These writes are generally queued up in the switch trying to get to the head of their queues so that they can post their data.  The queue occuapancy increments when the ACK is received, and decrements when either the data is returned OR a tickle is received and ownership is released.  Note that a single tickle can result in multiple decrements.; Tracks only those requests that come from the port specified in the IRP_PmonFilter.OrderingQ register.  This register allows one to select one specific queue.  It is not possible to monitor multiple queues at a time.	0,1	0x53	na	0
IRP	0x14	0x2	UNC_I_CACHE_ACK_PENDING_OCCUPANCY.SOURCE	Accumulates the number of writes that have acquired ownership but have not yet returned their data to the uncore.  These writes are generally queued up in the switch trying to get to the head of their queues so that they can post their data.  The queue occuapancy increments when the ACK is received, and decrements when either the data is returned OR a tickle is received and ownership is released.  Note that a single tickle can result in multiple decrements.; Tracks all requests from any source port.	0,1	0x53	na	0
IRP	0x15	0x1	UNC_I_TRANSACTIONS.READS	Counts the number of Inbound transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.; Tracks only read requests (not including read prefetches).	0,1	0x53	na	0
IRP	0x15	0x2	UNC_I_TRANSACTIONS.WRITES	Counts the number of Inbound transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.; Trackes only write requests.  Each write request should have a prefetch, so there is no need to explicitly track these requests.  For writes that are tickled and have to retry, the counter will be incremented for each retry.	0,1	0x53	na	0
IRP	0x15	0x4	UNC_I_TRANSACTIONS.PD_PREFETCHES	Counts the number of \Inbound\ transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.	0,1	0x53	na	0
IRP	0x15	0x4	UNC_I_TRANSACTIONS.RD_PREFETCHES	Counts the number of Inbound transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.; Tracks the number of read prefetches.	0,1	0x53	na	0
IRP	0x15	0x8	UNC_I_TRANSACTIONS.ORDERINGQ	Counts the number of Inbound transactions from the IRP to the Uncore.  This can be filtered based on request type in addition to the source queue.  Note the special filtering equation.  We do OR-reduction on the request type.  If the SOURCE bit is set, then we also do AND qualification based on the source portID.; Tracks only those requests that come from the port specified in the IRP_PmonFilter.OrderingQ register.  This register allows one to select one specific queue.  It is not possible to monitor multiple queues at a time.  If this bit is not set, then requests from all sources will be counted.	0,1	0x53	IRPFilter[4:0]	0
IRP	0x16	0x1	UNC_I_TICKLES.LOST_OWNERSHIP	Counts the number of tickles that are received.  This is for both explicit (from Cbo) and implicit (internal conflict) tickles.; Tracks the number of requests that lost ownership as a result of a tickle.  When a tickle comes in, if the request is not at the head of the queue in the switch, then that request as well as any requests behind it in the switch queue will lose ownership and have to re-acquire it later when they get to the head of the queue.  This will therefore track the number of requests that lost ownership and not just the number of tickles.	0,1	0x53	na	0
IRP	0x16	0x2	UNC_I_TICKLES.TOP_OF_QUEUE	Counts the number of tickles that are received.  This is for both explicit (from Cbo) and implicit (internal conflict) tickles.; Tracks the number of cases when a tickle was received but the requests was at the head of the queue in the switch.  In this case, data is returned rather than releasing ownership.	0,1	0x53	na	0
IRP	0x17	0x1	UNC_I_ADDRESS_MATCH.STALL_COUNT	Counts the number of times when an inbound write (from a device to memory or another device) had an address match with another request in the write cache.; When it is not possible to merge two conflicting requests, a stall event occurs.  This is bad for performance.	0,1	0x53	na	0
IRP	0x17	0x2	UNC_I_ADDRESS_MATCH.MERGE_COUNT	Counts the number of times when an inbound write (from a device to memory or another device) had an address match with another request in the write cache.; When two requests to the same address from the same source are received back to back, it is possible to merge the two of them together.	0,1	0x53	na	0
IRP	0x18	0x0	UNC_I_TxR_AD_STALL_CREDIT_CYCLES	Counts the number times when it is not possible to issue a request to the R2PCIe because there are no AD Egress Credits available.	0,1	0x53	na	0
IRP	0x19	0x0	UNC_I_TxR_BL_STALL_CREDIT_CYCLES	Counts the number times when it is not possible to issue data to the R2PCIe because there are no BL Egress Credits available.	0,1	0x53	na	0
IRP	0x1a	0x0	UNC_I_WRITE_ORDERING_STALL_CYCLES	Counts the number of cycles when there are pending write ACK's in the switch but the switch->IRP pipeline is not utilized.	0,1	0x53	na	0
IRP	0x2	0x0	UNC_I_RxR_BL_NCB_INSERTS	Counts the number of allocations into the BL Ingress.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.	0,1	0x53	na	0
IRP	0x3	0x0	UNC_I_RxR_BL_NCS_INSERTS	Counts the number of allocations into the BL Ingress.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.	0,1	0x53	na	0
IRP	0x4	0x0	UNC_I_RxR_BL_DRS_CYCLES_FULL	Counts the number of cycles when the BL Ingress is full.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.	0,1	0x53	na	0
IRP	0x5	0x0	UNC_I_RxR_BL_NCB_CYCLES_FULL	Counts the number of cycles when the BL Ingress is full.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.	0,1	0x53	na	0
IRP	0x6	0x0	UNC_I_RxR_BL_NCS_CYCLES_FULL	Counts the number of cycles when the BL Ingress is full.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.	0,1	0x53	na	0
IRP	0x7	0x0	UNC_I_RxR_BL_DRS_OCCUPANCY	Accumulates the occupancy of the BL Ingress in each cycles.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.	0,1	0x53	na	0
IRP	0x8	0x0	UNC_I_RxR_BL_NCB_OCCUPANCY	Accumulates the occupancy of the BL Ingress in each cycles.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.	0,1	0x53	na	0
IRP	0x9	0x0	UNC_I_RxR_BL_NCS_OCCUPANCY	Accumulates the occupancy of the BL Ingress in each cycles.  This queue is where the IRP receives data from R2PCIe (the ring).  It is used for data returns from read requets as well as outbound MMIO writes.	0,1	0x53	na	0
IRP	0xa	0x0	UNC_I_RxR_AK_INSERTS	Counts the number of allocations into the AK Ingress.  This queue is where the IRP receives responses from R2PCIe (the ring).	0,1	0x53	na	0
IRP	0xb	0x0	UNC_I_RxR_AK_CYCLES_FULL	Counts the number of cycles when the AK Ingress is full.  This queue is where the IRP receives responses from R2PCIe (the ring).	0,1	0x53	na	0
IRP	0xc	0x0	UNC_I_RxR_AK_OCCUPANCY	Accumulates the occupancy of the AK Ingress in each cycles.  This queue is where the IRP receives responses from R2PCIe (the ring).	0,1	0x53	na	0
IRP	0xd	0x0	UNC_I_TxR_REQUEST_OCCUPANCY	Accumultes the number of outstanding outbound requests from the IRP to the switch (towards the devices).  This can be used in conjuection with the allocations event in order to calculate average latency of outbound requests.	0,1	0x53	na	0
IRP	0xe	0x0	UNC_I_TxR_DATA_INSERTS_NCB	Counts the number of requests issued to the switch (towards the devices).	0,1	0x53	na	0
IRP	0xf	0x0	UNC_I_TxR_DATA_INSERTS_NCS	Counts the number of requests issued to the switch (towards the devices).	0,1	0x53	na	0
