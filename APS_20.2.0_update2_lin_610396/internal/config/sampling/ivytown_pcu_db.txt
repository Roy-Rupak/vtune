# Performance Monitoring Events for Intel(R) Xeon(R) processor E5 family and Intel(R) Xeon(R) processor E7 family Based on the Ivy Bridge-EP Microarchitecture - V21
# 10/3/2018 10:48:35 PM
# Copyright (c) 2007 - 2017 Intel Corporation. All rights reserved.
UNIT	CODE	UMASK	NAME	DESCRIPTION	COUNTER	OTHER	FILTER	INTERNAL
PCU	0x0	0x0	UNC_P_CLOCKTICKS	The PCU runs off a fixed 800 MHz clock.  This event counts the number of pclk cycles measured while the counter was enabled.  The pclk, like the Memory Controller's dclk, counts at a constant rate making it a good measure of actual wall time.	0,1,2,3	0x53	na	0
PCU	0x1	0x0	UNC_P_VOLT_TRANS_CYCLES_INCREASE	Counts the number of cycles when the system is increasing voltage.  There is no filtering supported with this event.  One can use it as a simple event, or use it conjunction with the occupancy events to monitor the number of cores or threads that were impacted by the transition.	0,1,2,3	0x53	na	0
PCU	0x17	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE0	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x18	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE1	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x19	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE2	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x1a	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE3	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x1b	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE4	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x1c	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE5	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x1d	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE6	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x1e	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE7	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x1e	0x0	UNC_P_DEMOTIONS_CORE0	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x1f	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE8	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x1f	0x0	UNC_P_DEMOTIONS_CORE1	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x2	0x0	UNC_P_VOLT_TRANS_CYCLES_DECREASE	Counts the number of cycles when the system is decreasing voltage.  There is no filtering supported with this event.  One can use it as a simple event, or use it conjunction with the occupancy events to monitor the number of cores or threads that were impacted by the transition.	0,1,2,3	0x53	na	0
PCU	0x2	0x0	UNC_P_FREQ_MIN_PERF_P_CYCLES	Counts the number of cycles when Perf P Limit is preventing us from dropping the frequency lower.  Perf P Limit is an algorithm that takes input from remote sockets when determining if a socket should drop it's frequency down.  This is largely to minimize increases in snoop and remote read latencies.	0,1,2,3	0x53	na	1
PCU	0x20	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE9	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x20	0x0	UNC_P_DEMOTIONS_CORE2	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x21	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE10	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x21	0x0	UNC_P_DEMOTIONS_CORE3	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x22	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE11	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x22	0x0	UNC_P_DEMOTIONS_CORE4	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x23	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE12	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x23	0x0	UNC_P_DEMOTIONS_CORE5	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x24	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE13	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x24	0x0	UNC_P_DEMOTIONS_CORE6	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x25	0x0	UNC_P_DELAYED_C_STATE_ABORT_CORE14	Number of times that a deep C state was requested, but the delayed C state algorithm rejected the deep sleep state.  In other words, a wake event occurred before the timer expired that causes a transition into the deeper C state.	0,1,2,3	0x53	na	1
PCU	0x25	0x0	UNC_P_DEMOTIONS_CORE7	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x26	0x0	UNC_P_PKG_C_EXIT_LATENCY_SEL	Counts the number of cycles that the package is transitioning from package C2 to C3.	0,1,2,3	0x53	na	1
PCU	0x26	0x0	UNC_P_PKG_C_EXIT_LATENCY	Counts the number of cycles that the package is transitioning from package C2 to C3.	0,1,2,3	0x53	na	1
PCU	0x2a	0x0	UNC_P_PKG_C_STATE_RESIDENCY_C0_CYCLES	Counts the number of cycles that the package is in C0	0,1,2,3	0x53	na	1
PCU	0x2b	0x0	UNC_P_PKG_C_STATE_RESIDENCY_C2_CYCLES	Counts the number of cycles that the package is in C2	0,1,2,3	0x53	na	1
PCU	0x2c	0x0	UNC_P_PKG_C_STATE_RESIDENCY_C3_CYCLES	Counts the number of cycles that the package is in C3	0,1,2,3	0x53	na	1
PCU	0x2d	0x0	UNC_P_PKG_C_STATE_RESIDENCY_C6_CYCLES	Counts the number of cycles that the package is in C6	0,1,2,3	0x53	na	1
PCU	0x2f	0x0	UNC_P_MEMORY_PHASE_SHEDDING_CYCLES	Counts the number of cycles that the PCU has triggered memory phase shedding.  This is a mode that can be run in the iMC physicals that saves power at the expense of additional latency.	0,1,2,3	0x53	na	0
PCU	0x3	0x0	UNC_P_VOLT_TRANS_CYCLES_CHANGE	Counts the number of cycles when the system is changing voltage.  There is no filtering supported with this event.  One can use it as a simple event, or use it conjunction with the occupancy events to monitor the number of cores or threads that were impacted by the transition.  This event is calculated by or'ing together the increasing and decreasing events.	0,1,2,3	0x53	na	0
PCU	0x32	0x0	UNC_P_VR_HOT_CYCLES	tbd	0,1,2,3	0x53	na	0
PCU	0x4	0x0	UNC_P_FREQ_MAX_LIMIT_THERMAL_CYCLES	Counts the number of cycles when thermal conditions are the upper limit on frequency.  This is related to the THERMAL_THROTTLE CYCLES_ABOVE_TEMP event, which always counts cycles when we are above the thermal temperature.  This event (STRONGEST_UPPER_LIMIT) is sampled at the output of the algorithm that determines the actual frequency, while THERMAL_THROTTLE looks at the input.	0,1,2,3	0x53	na	0
PCU	0x40	0x0	UNC_P_DEMOTIONS_CORE8	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x41	0x0	UNC_P_DEMOTIONS_CORE9	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x42	0x0	UNC_P_DEMOTIONS_CORE10	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x43	0x0	UNC_P_DEMOTIONS_CORE11	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x44	0x0	UNC_P_DEMOTIONS_CORE12	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x45	0x0	UNC_P_DEMOTIONS_CORE13	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x46	0x0	UNC_P_DEMOTIONS_CORE14	Counts the number of times when a configurable cores had a C-state demotion	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0x5	0x0	UNC_P_FREQ_MAX_POWER_CYCLES	Counts the number of cycles when power is the upper limit on frequency.	0,1,2,3	0x53	na	0
PCU	0x6	0x0	UNC_P_FREQ_MAX_OS_CYCLES	Counts the number of cycles when the OS is the upper limit on frequency.	0,1,2,3	0x53	na	0
PCU	0x60	0x0	UNC_P_FREQ_TRANS_CYCLES	Counts the number of cycles when the system is changing frequency.  This can not be filtered by thread ID.  One can also use it with the occupancy counter that monitors number of threads in C0 to estimate the performance impact that frequency transitions had on the system.	0,1,2,3	0x53	na	0
PCU	0x61	0x0	UNC_P_FREQ_MIN_IO_P_CYCLES	Counts the number of cycles when IO P Limit is preventing us from dropping the frequency lower.  This algorithm monitors the needs to the IO subsystem on both local and remote sockets and will maintain a frequency high enough to maintain good IO BW.  This is necessary for when all the IA cores on a socket are idle but a user still would like to maintain high IO Bandwidth.	0,1,2,3	0x53	na	0
PCU	0x62	0x0	UNC_P_FREQ_MIN_PERF_P_CYCLES	Counts the number of cycles when Perf P Limit is preventing us from dropping the frequency lower.  Perf P Limit is an algorithm that takes input from remote sockets when determining if a socket should drop it's frequency down.  This is largely to minimize increases in snoop and remote read latencies.	0,1,2,3	0x53	na	0
PCU	0x63	0x0	UNC_P_TOTAL_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions across all cores.	0,1,2,3	0x53	na	0
PCU	0x7	0x0	UNC_P_FREQ_MAX_CURRENT_CYCLES	Counts the number of cycles when current is the upper limit on frequency.	0,1,2,3	0x53	na	0
PCU	0x70	0x0	UNC_P_CORE0_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x71	0x0	UNC_P_CORE1_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x72	0x0	UNC_P_CORE2_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x73	0x0	UNC_P_CORE3_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x74	0x0	UNC_P_CORE4_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x75	0x0	UNC_P_CORE5_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x76	0x0	UNC_P_CORE6_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x77	0x0	UNC_P_CORE7_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x78	0x0	UNC_P_CORE8_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x79	0x0	UNC_P_CORE9_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x7a	0x0	UNC_P_CORE10_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x7b	0x0	UNC_P_CORE11_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x7c	0x0	UNC_P_CORE12_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x7d	0x0	UNC_P_CORE13_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x7e	0x0	UNC_P_CORE14_TRANSITION_CYCLES	Number of cycles spent performing core C state transitions.  There is one event per core.	0,1,2,3	0x53	na	0
PCU	0x80	0x40	UNC_P_POWER_STATE_OCCUPANCY.CORES_C0	This is an occupancy event that tracks the number of cores that are in the chosen C-State.  It can be used by itself to get the average number of cores in that C-state with threshholding to generate histograms, or with other PCU events and occupancy triggering to capture other details.	0,1,2,3	0x53	na	0
PCU	0x80	0x80	UNC_P_POWER_STATE_OCCUPANCY.CORES_C3	This is an occupancy event that tracks the number of cores that are in the chosen C-State.  It can be used by itself to get the average number of cores in that C-state with threshholding to generate histograms, or with other PCU events and occupancy triggering to capture other details.	0,1,2,3	0x53	na	0
PCU	0x80	0xC0	UNC_P_POWER_STATE_OCCUPANCY.CORES_C6	This is an occupancy event that tracks the number of cores that are in the chosen C-State.  It can be used by itself to get the average number of cores in that C-state with threshholding to generate histograms, or with other PCU events and occupancy triggering to capture other details.	0,1,2,3	0x53	na	0
PCU	0x9	0x0	UNC_P_PROCHOT_INTERNAL_CYCLES	Counts the number of cycles that we are in Interal PROCHOT mode.  This mode is triggered when a sensor on the die determines that we are too hot and must throttle to avoid damaging the chip.	0,1,2,3	0x53	na	0
PCU	0xa	0x0	UNC_P_PROCHOT_EXTERNAL_CYCLES	Counts the number of cycles that we are in external PROCHOT mode.  This mode is triggered when a sensor off the die determines that something off-die (like DRAM) is too hot and must throttle to avoid damaging the chip.	0,1,2,3	0x53	na	0
PCU	0xb	0x0	UNC_P_FREQ_BAND0_CYCLES	Counts the number of cycles that the uncore was running at a frequency greater than or equal to the frequency that is configured in the filter.  One can use all four counters with this event, so it is possible to track up to 4 configurable bands.  One can use edge detect in conjunction with this event to track the number of times that we transitioned into a frequency greater than or equal to the configurable frequency. One can also use inversion to track cycles when we were less than the configured frequency.	0,1,2,3	0x53	PCUFilter[7:0]	0
PCU	0xc	0x0	UNC_P_FREQ_BAND1_CYCLES	Counts the number of cycles that the uncore was running at a frequency greater than or equal to the frequency that is configured in the filter.  One can use all four counters with this event, so it is possible to track up to 4 configurable bands.  One can use edge detect in conjunction with this event to track the number of times that we transitioned into a frequency greater than or equal to the configurable frequency. One can also use inversion to track cycles when we were less than the configured frequency.	0,1,2,3	0x53	PCUFilter[15:8]	0
PCU	0xd	0x0	UNC_P_FREQ_BAND2_CYCLES	Counts the number of cycles that the uncore was running at a frequency greater than or equal to the frequency that is configured in the filter.  One can use all four counters with this event, so it is possible to track up to 4 configurable bands.  One can use edge detect in conjunction with this event to track the number of times that we transitioned into a frequency greater than or equal to the configurable frequency. One can also use inversion to track cycles when we were less than the configured frequency.	0,1,2,3	0x53	PCUFilter[23:16]	0
PCU	0xe	0x0	UNC_P_FREQ_BAND3_CYCLES	Counts the number of cycles that the uncore was running at a frequency greater than or equal to the frequency that is configured in the filter.  One can use all four counters with this event, so it is possible to track up to 4 configurable bands.  One can use edge detect in conjunction with this event to track the number of times that we transitioned into a frequency greater than or equal to the configurable frequency. One can also use inversion to track cycles when we were less than the configured frequency.	0,1,2,3	0x53	PCUFilter[31:24]	0
