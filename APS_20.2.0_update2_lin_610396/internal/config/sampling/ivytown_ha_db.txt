# Performance Monitoring Events for Intel(R) Xeon(R) processor E5 family and Intel(R) Xeon(R) processor E7 family Based on the Ivy Bridge-EP Microarchitecture - V21
# 10/3/2018 10:48:35 PM
# Copyright (c) 2007 - 2017 Intel Corporation. All rights reserved.
UNIT	CODE	UMASK	NAME	DESCRIPTION	COUNTER	OTHER	FILTER	INTERNAL
HA	0x0	0x0	UNC_H_CLOCKTICKS	Counts the number of uclks in the HA.  This will be slightly different than the count in the Ubox because of enable/freeze delays.  The HA is on the other side of the die from the fixed Ubox uclk counter, so the drift could be somewhat larger than in units that are closer like the QPI Agent.	0,1,2,3	0x53	na	0
HA	0x1	0x1	UNC_H_REQUESTS.READS_LOCAL	Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).; This filter includes only read requests coming from the local socket.  This is a good proxy for LLC Read Misses (including RFOs) from the local socket.	0,1,2,3	0x53	na	0
HA	0x1	0x10	UNC_H_REQUESTS.INVITOE_LOCAL	Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).; This filter includes only InvItoEs coming from the local socket.	0,1,2,3	0x53	na	0
HA	0x1	0x2	UNC_H_REQUESTS.READS_REMOTE	Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).; This filter includes only read requests coming from the remote socket.  This is a good proxy for LLC Read Misses (including RFOs) from the remote socket.	0,1,2,3	0x53	na	0
HA	0x1	0x20	UNC_H_REQUESTS.INVITOE_REMOTE	Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).; This filter includes only InvItoEs coming from remote sockets.	0,1,2,3	0x53	na	0
HA	0x1	0x3	UNC_H_REQUESTS.READS	Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).; Incoming ead requests.  This is a good proxy for LLC Read Misses (including RFOs).	0,1,2,3	0x53	na	0
HA	0x1	0x4	UNC_H_REQUESTS.WRITES_LOCAL	Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).; This filter includes only writes coming from the local socket.	0,1,2,3	0x53	na	0
HA	0x1	0x8	UNC_H_REQUESTS.WRITES_REMOTE	Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).; This filter includes only writes coming from remote sockets.	0,1,2,3	0x53	na	0
HA	0x1	0xC	UNC_H_REQUESTS.WRITES	Counts the total number of read requests made into the Home Agent. Reads include all read opcodes (including RFO).  Writes include all writes (streaming, evictions, HitM, etc).; Incoming write requests.	0,1,2,3	0x53	na	0
HA	0x10	0x1	UNC_H_TxR_BL.DRS_CACHE	Counts the number of DRS messages sent out on the BL ring.   This can be filtered by the destination.; Filter for data being sent to the cache.	0,1,2,3	0x53	na	0
HA	0x10	0x2	UNC_H_TxR_BL.DRS_CORE	Counts the number of DRS messages sent out on the BL ring.   This can be filtered by the destination.; Filter for data being sent directly to the requesting core.	0,1,2,3	0x53	na	0
HA	0x10	0x4	UNC_H_TxR_BL.DRS_QPI	Counts the number of DRS messages sent out on the BL ring.   This can be filtered by the destination.; Filter for data being sent to a remote socket over QPI.	0,1,2,3	0x53	na	0
HA	0x11	0x0	UNC_H_DIRECT2CORE_COUNT	Number of Direct2Core messages sent	0,1,2,3	0x53	na	0
HA	0x12	0x0	UNC_H_DIRECT2CORE_CYCLES_DISABLED	Number of cycles in which Direct2Core was disabled	0,1,2,3	0x53	na	0
HA	0x13	0x0	UNC_H_DIRECT2CORE_TXN_OVERRIDE	Number of Reads where Direct2Core overridden	0,1,2,3	0x53	na	0
HA	0x14	0x1	UNC_H_BYPASS_IMC.TAKEN	Counts the number of times when the HA was able to bypass was attempted.  This is a latency optimization for situations when there is light loadings on the memory subsystem.  This can be filted by when the bypass was taken and when it was not.; Filter for transactions that succeeded in taking the bypass.	0,1,2,3	0x53	na	0
HA	0x14	0x2	UNC_H_BYPASS_IMC.NOT_TAKEN	Counts the number of times when the HA was able to bypass was attempted.  This is a latency optimization for situations when there is light loadings on the memory subsystem.  This can be filted by when the bypass was taken and when it was not.; Filter for transactions that could not take the bypass.	0,1,2,3	0x53	na	0
HA	0x15	0x1	UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN0	Counts the number of cycles when there are no regular credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and special requests such as ISOCH reads.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 0 only.	0,1,2,3	0x53	na	0
HA	0x15	0x2	UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN1	Counts the number of cycles when there are no regular credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and special requests such as ISOCH reads.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 1 only.	0,1,2,3	0x53	na	0
HA	0x15	0x4	UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN2	Counts the number of cycles when there are no regular credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and special requests such as ISOCH reads.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 2 only.	0,1,2,3	0x53	na	0
HA	0x15	0x8	UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN3	Counts the number of cycles when there are no regular credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and special requests such as ISOCH reads.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 3 only.	0,1,2,3	0x53	na	0
HA	0x16	0x1	UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN0	Counts the number of cycles when there are no special credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and special requests such as ISOCH reads.  This count only tracks the special credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 0 only.	0,1,2,3	0x53	na	0
HA	0x16	0x2	UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN1	Counts the number of cycles when there are no special credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and special requests such as ISOCH reads.  This count only tracks the special credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 1 only.	0,1,2,3	0x53	na	0
HA	0x16	0x4	UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN2	Counts the number of cycles when there are no special credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and special requests such as ISOCH reads.  This count only tracks the special credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 2 only.	0,1,2,3	0x53	na	0
HA	0x16	0x8	UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN3	Counts the number of cycles when there are no special credits available for posting reads from the HA into the iMC.  In order to send reads into the memory controller, the HA must first acquire a credit for the iMC's RPQ (read pending queue).  This queue is broken into regular credits/buffers that are used by general reads, and special requests such as ISOCH reads.  This count only tracks the special credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 3 only.	0,1,2,3	0x53	na	0
HA	0x17	0x1	UNC_H_IMC_READS.NORMAL	Count of the number of reads issued to any of the memory controller channels.  This can be filtered by the priority of the reads.	0,1,2,3	0x53	na	0
HA	0x18	0x1	UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN0	Counts the number of cycles when there are no regular credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and special requests such as ISOCH writes.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 0 only.	0,1,2,3	0x53	na	0
HA	0x18	0x2	UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN1	Counts the number of cycles when there are no regular credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and special requests such as ISOCH writes.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 1 only.	0,1,2,3	0x53	na	0
HA	0x18	0x4	UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN2	Counts the number of cycles when there are no regular credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and special requests such as ISOCH writes.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 2 only.	0,1,2,3	0x53	na	0
HA	0x18	0x8	UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN3	Counts the number of cycles when there are no regular credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and special requests such as ISOCH writes.  This count only tracks the regular credits  Common high banwidth workloads should be able to make use of all of the regular buffers, but it will be difficult (and uncommon) to make use of both the regular and special buffers at the same time.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 3 only.	0,1,2,3	0x53	na	0
HA	0x19	0x1	UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN0	Counts the number of cycles when there are no special credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and special requests such as ISOCH writes.  This count only tracks the special credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 0 only.	0,1,2,3	0x53	na	0
HA	0x19	0x2	UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN1	Counts the number of cycles when there are no special credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and special requests such as ISOCH writes.  This count only tracks the special credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 1 only.	0,1,2,3	0x53	na	0
HA	0x19	0x4	UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN2	Counts the number of cycles when there are no special credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and special requests such as ISOCH writes.  This count only tracks the special credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 2 only.	0,1,2,3	0x53	na	0
HA	0x19	0x8	UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN3	Counts the number of cycles when there are no special credits available for posting writes from the HA into the iMC.  In order to send writes into the memory controller, the HA must first acquire a credit for the iMC's WPQ (write pending queue).  This queue is broken into regular credits/buffers that are used by general writes, and special requests such as ISOCH writes.  This count only tracks the special credits.  This statistic is generally not interesting for general IA workloads, but may be of interest for understanding the characteristics of systems using ISOCH.  One can filter based on the memory controller channel.  One or more channels can be tracked at a given time.; Filter for memory controller channel 3 only.	0,1,2,3	0x53	na	0
HA	0x1a	0x1	UNC_H_IMC_WRITES.FULL	Counts the total number of full line writes issued from the HA into the memory controller.  This counts for all four channels.  It can be filtered by full/partial and ISOCH/non-ISOCH.	0,1,2,3	0x53	na	0
HA	0x1a	0x2	UNC_H_IMC_WRITES.PARTIAL	Counts the total number of full line writes issued from the HA into the memory controller.  This counts for all four channels.  It can be filtered by full/partial and ISOCH/non-ISOCH.	0,1,2,3	0x53	na	0
HA	0x1a	0x4	UNC_H_IMC_WRITES.FULL_ISOCH	Counts the total number of full line writes issued from the HA into the memory controller.  This counts for all four channels.  It can be filtered by full/partial and ISOCH/non-ISOCH.	0,1,2,3	0x53	na	0
HA	0x1a	0x8	UNC_H_IMC_WRITES.PARTIAL_ISOCH	Counts the total number of full line writes issued from the HA into the memory controller.  This counts for all four channels.  It can be filtered by full/partial and ISOCH/non-ISOCH.	0,1,2,3	0x53	na	0
HA	0x1a	0xF	UNC_H_IMC_WRITES.ALL	Counts the total number of full line writes issued from the HA into the memory controller.  This counts for all four channels.  It can be filtered by full/partial and ISOCH/non-ISOCH.	0,1,2,3	0x53	na	0
HA	0x1b	0x1	UNC_H_TAD_REQUESTS_G0.REGION0	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for Monroe systems that use the TAD to enable individual channels to enter self-refresh to save power.; Filters request made to TAD Region 0	0,1,2,3	0x53	na	0
HA	0x1b	0x10	UNC_H_TAD_REQUESTS_G0.REGION4	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for Monroe systems that use the TAD to enable individual channels to enter self-refresh to save power.; Filters request made to TAD Region 4	0,1,2,3	0x53	na	0
HA	0x1b	0x2	UNC_H_TAD_REQUESTS_G0.REGION1	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for Monroe systems that use the TAD to enable individual channels to enter self-refresh to save power.; Filters request made to TAD Region 1	0,1,2,3	0x53	na	0
HA	0x1b	0x20	UNC_H_TAD_REQUESTS_G0.REGION5	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for Monroe systems that use the TAD to enable individual channels to enter self-refresh to save power.; Filters request made to TAD Region 5	0,1,2,3	0x53	na	0
HA	0x1b	0x4	UNC_H_TAD_REQUESTS_G0.REGION2	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for Monroe systems that use the TAD to enable individual channels to enter self-refresh to save power.; Filters request made to TAD Region 2	0,1,2,3	0x53	na	0
HA	0x1b	0x40	UNC_H_TAD_REQUESTS_G0.REGION6	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for Monroe systems that use the TAD to enable individual channels to enter self-refresh to save power.; Filters request made to TAD Region 6	0,1,2,3	0x53	na	0
HA	0x1b	0x8	UNC_H_TAD_REQUESTS_G0.REGION3	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for Monroe systems that use the TAD to enable individual channels to enter self-refresh to save power.; Filters request made to TAD Region 3	0,1,2,3	0x53	na	0
HA	0x1b	0x80	UNC_H_TAD_REQUESTS_G0.REGION7	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 0 to 7.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for Monroe systems that use the TAD to enable individual channels to enter self-refresh to save power.; Filters request made to TAD Region 7	0,1,2,3	0x53	na	0
HA	0x1c	0x1	UNC_H_TAD_REQUESTS_G1.REGION8	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 8 to 10.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for Monroe systems that use the TAD to enable individual channels to enter self-refresh to save power.; Filters request made to TAD Region 8	0,1,2,3	0x53	na	0
HA	0x1c	0x2	UNC_H_TAD_REQUESTS_G1.REGION9	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 8 to 10.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for Monroe systems that use the TAD to enable individual channels to enter self-refresh to save power.; Filters request made to TAD Region 9	0,1,2,3	0x53	na	0
HA	0x1c	0x4	UNC_H_TAD_REQUESTS_G1.REGION10	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 8 to 10.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for Monroe systems that use the TAD to enable individual channels to enter self-refresh to save power.; Filters request made to TAD Region 10	0,1,2,3	0x53	na	0
HA	0x1c	0x8	UNC_H_TAD_REQUESTS_G1.REGION11	Counts the number of HA requests to a given TAD region.  There are up to 11 TAD (target address decode) regions in each home agent.  All requests destined for the memory controller must first be decoded to determine which TAD region they are in.  This event is filtered based on the TAD region ID, and covers regions 8 to 10.  This event is useful for understanding how applications are using the memory that is spread across the different memory regions.  It is particularly useful for Monroe systems that use the TAD to enable individual channels to enter self-refresh to save power.; Filters request made to TAD Region 11	0,1,2,3	0x53	na	0
HA	0x1e	0x0	UNC_H_IMC_RETRY	tbd	0,1,2,3	0x53	na	0
HA	0x20	0x1	UNC_H_ADDR_OPC_MATCH.ADDR	tbd	0,1,2,3	0x53	HA_AddrMatch0[31:6], HA_AddrMatch1[13:0]	0
HA	0x20	0x10	UNC_H_ADDR_OPC_MATCH.AK	tbd	0,1,2,3	0x53	HA_OpcodeMatch[5:0]	0
HA	0x20	0x2	UNC_H_ADDR_OPC_MATCH.OPC	tbd	0,1,2,3	0x53	HA_OpcodeMatch[5:0]	0
HA	0x20	0x3	UNC_H_ADDR_OPC_MATCH.FILT	tbd	0,1,2,3	0x53	HA_AddrMatch0[31:6], HA_AddrMatch1[13:0], HA_OpcodeMatch[5:0]	0
HA	0x20	0x4	UNC_H_ADDR_OPC_MATCH.AD	tbd	0,1,2,3	0x53	HA_OpcodeMatch[5:0]	0
HA	0x20	0x8	UNC_H_ADDR_OPC_MATCH.BL	tbd	0,1,2,3	0x53	HA_OpcodeMatch[5:0]	0
HA	0x21	0x1	UNC_H_SNOOP_RESP.RSPI	Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.; Filters for snoops responses of RspI.  RspI is returned when the remote cache does not have the data, or when the remote cache silently evicts data (such as when an RFO hits non-modified data).	0,1,2,3	0x53	na	0
HA	0x21	0x10	UNC_H_SNOOP_RESP.RSP_WB	Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.; Filters for a snoop response of RspIWB or RspSWB.  This is returned when a non-RFO request hits in M state.  Data and Code Reads can return either RspIWB or RspSWB depending on how the system has been configured.  InvItoE transactions will also return RspIWB because they must acquire ownership.	0,1,2,3	0x53	na	0
HA	0x21	0x2	UNC_H_SNOOP_RESP.RSPS	Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.; Filters for snoop responses of RspS.  RspS is returned when a remote cache has data but is not forwarding it.  It is a way to let the requesting socket know that it cannot allocate the data in E state.  No data is sent with S RspS.	0,1,2,3	0x53	na	0
HA	0x21	0x20	UNC_H_SNOOP_RESP.RSP_FWD_WB	Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.; Filters for a snoop response of Rsp*Fwd*WB.  This snoop response is only used in 4s systems.  It is used when a snoop HITM's in a remote caching agent and it directly forwards data to a requestor, and simultaneously returns data to the home to be written back to memory.	0,1,2,3	0x53	na	0
HA	0x21	0x4	UNC_H_SNOOP_RESP.RSPIFWD	Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.; Filters for snoop responses of RspIFwd.  This is returned when a remote caching agent forwards data and the requesting agent is able to acquire the data in E or M states.  This is commonly returned with RFO transactions.  It can be either a HitM or a HitFE.	0,1,2,3	0x53	na	0
HA	0x21	0x40	UNC_H_SNOOP_RESP.RSPCNFLCT	Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.; Filters for snoops responses of RspConflict.  This is returned when a snoop finds an existing outstanding transaction in a remote caching agent when it CAMs that caching agent.  This triggers conflict resolution hardware.  This covers both RspCnflct and RspCnflctWbI.	0,1,2,3	0x53	na	0
HA	0x21	0x8	UNC_H_SNOOP_RESP.RSPSFWD	Counts the total number of RspI snoop responses received.  Whenever a snoops are issued, one or more snoop responses will be returned depending on the topology of the system.   In systems larger than 2s, when multiple snoops are returned this will count all the snoops that are received.  For example, if 3 snoops were issued and returned RspI, RspS, and RspSFwd; then each of these sub-events would increment by 1.; Filters for a snoop response of RspSFwd.  This is returned when a remote caching agent forwards data but holds on to its currentl copy.  This is common for data and code reads that hit in a remote socket in E or F state.	0,1,2,3	0x53	na	0
HA	0x22	0x1	UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI0	Counts the number of cycles when the HA does not have credits to send messages to the QPI Agent.  This can be filtered by the different credit pools and the different links.	0,1,2,3	0x53	na	0
HA	0x22	0x2	UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI1	Counts the number of cycles when the HA does not have credits to send messages to the QPI Agent.  This can be filtered by the different credit pools and the different links.	0,1,2,3	0x53	na	0
HA	0x22	0x4	UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI0	Counts the number of cycles when the HA does not have credits to send messages to the QPI Agent.  This can be filtered by the different credit pools and the different links.	0,1,2,3	0x53	na	0
HA	0x22	0x8	UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI1	Counts the number of cycles when the HA does not have credits to send messages to the QPI Agent.  This can be filtered by the different credit pools and the different links.	0,1,2,3	0x53	na	0
HA	0x27	0x1	UNC_H_TxR_AD_INSERTS.SCHED0	AD Egress Allocations; Filter for allocations from scheduler bank 0	0,1,2,3	0x53	na	0
HA	0x27	0x2	UNC_H_TxR_AD_INSERTS.SCHED1	AD Egress Allocations; Filter for allocations from scheduler bank 1	0,1,2,3	0x53	na	0
HA	0x27	0x3	UNC_H_TxR_AD_INSERTS.ALL	AD Egress Allocations; Allocations from both schedulers	0,1,2,3	0x53	na	0
HA	0x28	0x1	UNC_H_TxR_AD_OCCUPANCY.SCHED0	AD Egress Occupancy; Filter for occupancy from scheduler bank 0	0,1,2,3	0x53	na	0
HA	0x28	0x2	UNC_H_TxR_AD_OCCUPANCY.SCHED1	AD Egress Occupancy; Filter for occupancy from scheduler bank 1	0,1,2,3	0x53	na	0
HA	0x29	0x1	UNC_H_TxR_AD_CYCLES_NE.SCHED0	AD Egress Not Empty; Filter for cycles not empty  from scheduler bank 0	0,1,2,3	0x53	na	0
HA	0x29	0x2	UNC_H_TxR_AD_CYCLES_NE.SCHED1	AD Egress Not Empty; Filter for cycles not empty from scheduler bank 1	0,1,2,3	0x53	na	0
HA	0x29	0x3	UNC_H_TxR_AD_CYCLES_NE.ALL	AD Egress Not Empty; Cycles full from both schedulers	0,1,2,3	0x53	na	0
HA	0x2a	0x1	UNC_H_TxR_AD_CYCLES_FULL.SCHED0	AD Egress Full; Filter for cycles full  from scheduler bank 0	0,1,2,3	0x53	na	0
HA	0x2a	0x2	UNC_H_TxR_AD_CYCLES_FULL.SCHED1	AD Egress Full; Filter for cycles full  from scheduler bank 1	0,1,2,3	0x53	na	0
HA	0x2a	0x3	UNC_H_TxR_AD_CYCLES_FULL.ALL	AD Egress Full; Cycles full from both schedulers	0,1,2,3	0x53	na	0
HA	0x2f	0x1	UNC_H_TxR_AK_INSERTS.SCHED0	AK Egress Allocations; Filter for allocations from scheduler bank 0	0,1,2,3	0x53	na	0
HA	0x2f	0x2	UNC_H_TxR_AK_INSERTS.SCHED1	AK Egress Allocations; Filter for allocations from scheduler bank 1	0,1,2,3	0x53	na	0
HA	0x2f	0x3	UNC_H_TxR_AK_INSERTS.ALL	AK Egress Allocations; Allocations from both schedulers	0,1,2,3	0x53	na	0
HA	0x3	0x0	UNC_H_TRACKER_CYCLES_NE	Counts the number of cycles when the local HA tracker pool is not empty.  This can be used with edge detect to identify the number of situations when the pool became empty.  This should not be confused with RTID credit usage -- which must be tracked inside each cbo individually -- but represents the actual tracker buffer structure.  In other words, this buffer could be completely empty, but there may still be credits in use by the CBos.  This stat can be used in conjunction with the occupancy accumulation stat in order to calculate average queue occpancy.  HA trackers are allocated as soon as a request enters the HA if an HT (Home Tracker) entry is available and is released after the snoop response and data return (or post in the case of a write) and the response is returned on the ring.	0,1,2,3	0x53	na	0
HA	0x30	0x1	UNC_H_TxR_AK_OCCUPANCY.SCHED0	AK Egress Occupancy; Filter for occupancy from scheduler bank 0	0,1,2,3	0x53	na	0
HA	0x30	0x2	UNC_H_TxR_AK_OCCUPANCY.SCHED1	AK Egress Occupancy; Filter for occupancy from scheduler bank 1	0,1,2,3	0x53	na	0
HA	0x31	0x1	UNC_H_TxR_AK_CYCLES_NE.SCHED0	AK Egress Not Empty; Filter for cycles not empty  from scheduler bank 0	0,1,2,3	0x53	na	0
HA	0x31	0x2	UNC_H_TxR_AK_CYCLES_NE.SCHED1	AK Egress Not Empty; Filter for cycles not empty from scheduler bank 1	0,1,2,3	0x53	na	0
HA	0x31	0x3	UNC_H_TxR_AK_CYCLES_NE.ALL	AK Egress Not Empty; Cycles full from both schedulers	0,1,2,3	0x53	na	0
HA	0x32	0x1	UNC_H_TxR_AK_CYCLES_FULL.SCHED0	AK Egress Full; Filter for cycles full  from scheduler bank 0	0,1,2,3	0x53	na	0
HA	0x32	0x2	UNC_H_TxR_AK_CYCLES_FULL.SCHED1	AK Egress Full; Filter for cycles full  from scheduler bank 1	0,1,2,3	0x53	na	0
HA	0x32	0x3	UNC_H_TxR_AK_CYCLES_FULL.ALL	AK Egress Full; Cycles full from both schedulers	0,1,2,3	0x53	na	0
HA	0x33	0x1	UNC_H_TxR_BL_INSERTS.SCHED0	BL Egress Allocations; Filter for allocations from scheduler bank 0	0,1,2,3	0x53	na	0
HA	0x33	0x2	UNC_H_TxR_BL_INSERTS.SCHED1	BL Egress Allocations; Filter for allocations from scheduler bank 1	0,1,2,3	0x53	na	0
HA	0x33	0x3	UNC_H_TxR_BL_INSERTS.ALL	BL Egress Allocations; Allocations from both schedulers	0,1,2,3	0x53	na	0
HA	0x34	0x1	UNC_H_TxR_BL_OCCUPANCY.SCHED0	BL Egress Occupancy; Filter for occupancy from scheduler bank 0	0,1,2,3	0x53	na	0
HA	0x34	0x2	UNC_H_TxR_BL_OCCUPANCY.SCHED1	BL Egress Occupancy; Filter for occupancy from scheduler bank 1	0,1,2,3	0x53	na	0
HA	0x34	0x3	UNC_H_TxR_BL_OCCUPANCY.ALL	BL Egress Occupancy	0,1,2,3	0x53	na	0
HA	0x35	0x1	UNC_H_TxR_BL_CYCLES_NE.SCHED0	BL Egress Not Empty; Filter for cycles not empty  from scheduler bank 0	0,1,2,3	0x53	na	0
HA	0x35	0x2	UNC_H_TxR_BL_CYCLES_NE.SCHED1	BL Egress Not Empty; Filter for cycles not empty from scheduler bank 1	0,1,2,3	0x53	na	0
HA	0x35	0x3	UNC_H_TxR_BL_CYCLES_NE.ALL	BL Egress Not Empty; Cycles full from both schedulers	0,1,2,3	0x53	na	0
HA	0x36	0x1	UNC_H_TxR_BL_CYCLES_FULL.SCHED0	BL Egress Full; Filter for cycles full  from scheduler bank 0	0,1,2,3	0x53	na	0
HA	0x36	0x2	UNC_H_TxR_BL_CYCLES_FULL.SCHED1	BL Egress Full; Filter for cycles full  from scheduler bank 1	0,1,2,3	0x53	na	0
HA	0x36	0x3	UNC_H_TxR_BL_CYCLES_FULL.ALL	BL Egress Full; Cycles full from both schedulers	0,1,2,3	0x53	na	0
HA	0x3e	0x1	UNC_H_RING_AD_USED.CW_VR0_EVEN	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Clockwise and Even ring polarity on Virtual Ring 0.	0,1,2,3	0x53	na	0
HA	0x3e	0x10	UNC_H_RING_AD_USED.CW_VR1_EVEN	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Clockwise and Even ring polarity on Virtual Ring 1.	0,1,2,3	0x53	na	0
HA	0x3e	0x2	UNC_H_RING_AD_USED.CW_VR0_ODD	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Clockwise and Odd ring polarity on Virtual Ring 0.	0,1,2,3	0x53	na	0
HA	0x3e	0x20	UNC_H_RING_AD_USED.CW_VR1_ODD	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Clockwise and Odd ring polarity on Virtual Ring 1.	0,1,2,3	0x53	na	0
HA	0x3E	0x33	UNC_H_RING_AD_USED.CW	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x53	na	0
HA	0x3e	0x4	UNC_H_RING_AD_USED.CCW_VR0_EVEN	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Counterclockwise and Even ring polarity on Virtual Ring 0.	0,1,2,3	0x53	na	0
HA	0x3e	0x40	UNC_H_RING_AD_USED.CCW_VR1_EVEN	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Counterclockwise and Even ring polarity on Virtual Ring 1.	0,1,2,3	0x53	na	0
HA	0x3e	0x8	UNC_H_RING_AD_USED.CCW_VR0_ODD	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Counterclockwise and Odd ring polarity on Virtual Ring 0.	0,1,2,3	0x53	na	0
HA	0x3e	0x80	UNC_H_RING_AD_USED.CCW_VR1_ODD	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Counterclockwise and Odd ring polarity on Virtual Ring 1.	0,1,2,3	0x53	na	0
HA	0x3E	0xCC	UNC_H_RING_AD_USED.CCW	Counts the number of cycles that the AD ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x53	na	0
HA	0x3f	0x1	UNC_H_RING_AK_USED.CW_VR0_EVEN	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Clockwise and Even ring polarity on Virtual Ring 0.	0,1,2,3	0x53	na	0
HA	0x3f	0x10	UNC_H_RING_AK_USED.CW_VR1_EVEN	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Clockwise and Even ring polarity on Virtual Ring 1.	0,1,2,3	0x53	na	0
HA	0x3f	0x2	UNC_H_RING_AK_USED.CW_VR0_ODD	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Clockwise and Odd ring polarity on Virtual Ring 0.	0,1,2,3	0x53	na	0
HA	0x3f	0x20	UNC_H_RING_AK_USED.CW_VR1_ODD	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Clockwise and Odd ring polarity on Virtual Ring 1.	0,1,2,3	0x53	na	0
HA	0x3F	0x33	UNC_H_RING_AK_USED.CW	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x53	na	0
HA	0x3f	0x4	UNC_H_RING_AK_USED.CCW_VR0_EVEN	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Counterclockwise and Even ring polarity on Virtual Ring 0.	0,1,2,3	0x53	na	0
HA	0x3f	0x40	UNC_H_RING_AK_USED.CCW_VR1_EVEN	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Counterclockwise and Even ring polarity on Virtual Ring 1.	0,1,2,3	0x53	na	0
HA	0x3f	0x8	UNC_H_RING_AK_USED.CCW_VR0_ODD	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Counterclockwise and Odd ring polarity on Virtual Ring 0.	0,1,2,3	0x53	na	0
HA	0x3f	0x80	UNC_H_RING_AK_USED.CCW_VR1_ODD	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Counterclockwise and Odd ring polarity on Virtual Ring 1.	0,1,2,3	0x53	na	0
HA	0x3F	0xCC	UNC_H_RING_AK_USED.CCW	Counts the number of cycles that the AK ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x53	na	0
HA	0x40	0x1	UNC_H_RING_BL_USED.CW_VR0_EVEN	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Clockwise and Even ring polarity on Virtual Ring 0.	0,1,2,3	0x53	na	0
HA	0x40	0x10	UNC_H_RING_BL_USED.CW_VR1_EVEN	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Clockwise and Even ring polarity on Virtual Ring 1.	0,1,2,3	0x53	na	0
HA	0x40	0x2	UNC_H_RING_BL_USED.CW_VR0_ODD	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Clockwise and Odd ring polarity on Virtual Ring 0.	0,1,2,3	0x53	na	0
HA	0x40	0x20	UNC_H_RING_BL_USED.CW_VR1_ODD	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Clockwise and Odd ring polarity on Virtual Ring 1.	0,1,2,3	0x53	na	0
HA	0x40	0x33	UNC_H_RING_BL_USED.CW	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x53	na	0
HA	0x40	0x4	UNC_H_RING_BL_USED.CCW_VR0_EVEN	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Counterclockwise and Even ring polarity on Virtual Ring 0.	0,1,2,3	0x53	na	0
HA	0x40	0x40	UNC_H_RING_BL_USED.CCW_VR1_EVEN	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Counterclockwise and Even ring polarity on Virtual Ring 1.	0,1,2,3	0x53	na	0
HA	0x40	0x8	UNC_H_RING_BL_USED.CCW_VR0_ODD	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Counterclockwise and Odd ring polarity on Virtual Ring 0.	0,1,2,3	0x53	na	0
HA	0x40	0x80	UNC_H_RING_BL_USED.CCW_VR1_ODD	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.; Filters for the Counterclockwise and Odd ring polarity on Virtual Ring 1.	0,1,2,3	0x53	na	0
HA	0x40	0xCC	UNC_H_RING_BL_USED.CCW	Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from the ring stop.	0,1,2,3	0x53	na	0
HA	0x41	0x0	UNC_H_DIRECTORY_LAT_OPT	Directory Latency Optimization Data Return Path Taken. When directory mode is enabled and the directory retuned for a read is Dir=I, then data can be returned using a faster path if certain conditions are met (credits, free pipeline, etc).	0,1,2,3	0x53	na	0
HA	0x42	0x0	UNC_H_BT_CYCLES_NE	Cycles the Backup Tracker (BT) is not empty. The BT is the actual HOM tracker in IVT.	0,1,2,3	0x53	na	0
HA	0x42	0x1	UNC_H_BT_CYCLES_NE.LOCAL	Cycles the Backup Tracker (BT) is not empty. The BT is the actual HOM tracker in IVT.	0,1,2,3	0x53	na	0
HA	0x42	0x2	UNC_H_BT_CYCLES_NE.REMOTE	Cycles the Backup Tracker (BT) is not empty. The BT is the actual HOM tracker in IVT.	0,1,2,3	0x53	na	0
HA	0x43	0x1	UNC_H_BT_OCCUPANCY.LOCAL	Accumulates the occupancy of the HA BT pool in every cycle.  This can be used with the not empty stat to calculate average queue occupancy or the allocations stat in order to calculate average queue latency.  HA BTs are allocated as soon as a request enters the HA and is released after the snoop response and data return (or post in the case of a write) and the response is returned on the ring.	0,1,2,3	0x53	na	0
HA	0x43	0x10	UNC_H_BT_OCCUPANCY.WRITES_LOCAL	Accumulates the occupancy of the HA BT pool in every cycle.  This can be used with the not empty stat to calculate average queue occupancy or the allocations stat in order to calculate average queue latency.  HA BTs are allocated as soon as a request enters the HA and is released after the snoop response and data return (or post in the case of a write) and the response is returned on the ring.	0,1,2,3	0x53	na	0
HA	0x43	0x2	UNC_H_BT_OCCUPANCY.REMOTE	Accumulates the occupancy of the HA BT pool in every cycle.  This can be used with the not empty stat to calculate average queue occupancy or the allocations stat in order to calculate average queue latency.  HA BTs are allocated as soon as a request enters the HA and is released after the snoop response and data return (or post in the case of a write) and the response is returned on the ring.	0,1,2,3	0x53	na	0
HA	0x43	0x20	UNC_H_BT_OCCUPANCY.WRITES_REMOTE	Accumulates the occupancy of the HA BT pool in every cycle.  This can be used with the not empty stat to calculate average queue occupancy or the allocations stat in order to calculate average queue latency.  HA BTs are allocated as soon as a request enters the HA and is released after the snoop response and data return (or post in the case of a write) and the response is returned on the ring.	0,1,2,3	0x53	na	0
HA	0x43	0x4	UNC_H_BT_OCCUPANCY.READS_LOCAL	Accumulates the occupancy of the HA BT pool in every cycle.  This can be used with the not empty stat to calculate average queue occupancy or the allocations stat in order to calculate average queue latency.  HA BTs are allocated as soon as a request enters the HA and is released after the snoop response and data return (or post in the case of a write) and the response is returned on the ring.	0,1,2,3	0x53	na	0
HA	0x43	0x8	UNC_H_BT_OCCUPANCY.READS_REMOTE	Accumulates the occupancy of the HA BT pool in every cycle.  This can be used with the not empty stat to calculate average queue occupancy or the allocations stat in order to calculate average queue latency.  HA BTs are allocated as soon as a request enters the HA and is released after the snoop response and data return (or post in the case of a write) and the response is returned on the ring.	0,1,2,3	0x53	na	0
HA	0x51	0x10	UNC_H_BT_TO_HT_NOT_ISSUED.WBMDATA_HAZARD	Counts the number of cycles when the HA does not issue transaction from BT to HT.; Cycles unable to issue from BT due to incoming BL data hazard	0,1,2,3	0x53	na	0
HA	0x51	0x2	UNC_H_BT_TO_HT_NOT_ISSUED.INCOMING_SNP_HAZARD	Counts the number of cycles when the HA does not issue transaction from BT to HT.; Cycles unable to issue from BT due to incoming snoop hazard	0,1,2,3	0x53	na	0
HA	0x51	0x4	UNC_H_BT_TO_HT_NOT_ISSUED.INCOMING_BL_HAZARD	Counts the number of cycles when the HA does not issue transaction from BT to HT.; Cycles unable to issue from BT due to incoming BL data hazard	0,1,2,3	0x53	na	0
HA	0x51	0x8	UNC_H_BT_TO_HT_NOT_ISSUED.RSPACKCFLT_HAZARD	Counts the number of cycles when the HA does not issue transaction from BT to HT.; Cycles unable to issue from BT due to incoming BL data hazard	0,1,2,3	0x53	na	0
HA	0x52	0x0	UNC_H_BT_BYPASS	Number of transactions that bypass the BT (fifo) to HT	0,1,2,3	0x53	na	0
HA	0x53	0x2	UNC_H_OSB.READS_LOCAL	Count of OSB snoop broadcasts. Counts by 1 per request causing OSB snoops to be broadcast. Does not count all the snoops generated by OSB.	0,1,2,3	0x53	na	0
HA	0x53	0x4	UNC_H_OSB.INVITOE_LOCAL	Count of OSB snoop broadcasts. Counts by 1 per request causing OSB snoops to be broadcast. Does not count all the snoops generated by OSB.	0,1,2,3	0x53	na	0
HA	0x53	0x8	UNC_H_OSB.REMOTE	Count of OSB snoop broadcasts. Counts by 1 per request causing OSB snoops to be broadcast. Does not count all the snoops generated by OSB.	0,1,2,3	0x53	na	0
HA	0x54	0x1	UNC_H_OSB_EDR.ALL	Counts the number of transactions that broadcast snoop due to OSB, but found clean data in memory and was able to do early data return	0,1,2,3	0x53	na	0
HA	0x54	0x10	UNC_H_OSB_EDR.READS_REMOTE_S	Counts the number of transactions that broadcast snoop due to OSB, but found clean data in memory and was able to do early data return	0,1,2,3	0x53	na	0
HA	0x54	0x2	UNC_H_OSB_EDR.READS_LOCAL_I	Counts the number of transactions that broadcast snoop due to OSB, but found clean data in memory and was able to do early data return	0,1,2,3	0x53	na	0
HA	0x54	0x4	UNC_H_OSB_EDR.READS_REMOTE_I	Counts the number of transactions that broadcast snoop due to OSB, but found clean data in memory and was able to do early data return	0,1,2,3	0x53	na	0
HA	0x54	0x8	UNC_H_OSB_EDR.READS_LOCAL_S	Counts the number of transactions that broadcast snoop due to OSB, but found clean data in memory and was able to do early data return	0,1,2,3	0x53	na	0
HA	0x56	0x0	UNC_H_IODC_INSERTS	IODC Allocations	0,1,2,3	0x53	na	0
HA	0x57	0x1	UNC_H_IODC_CONFLICTS.REMOTE_INVI2E_SAME_RTID	tbd	0,1,2,3	0x53	na	0
HA	0x57	0x1	UNC_H_IODC_CONFLICTS.ANY	tbd	0,1,2,3	0x53	na	0
HA	0x57	0x4	UNC_H_IODC_CONFLICTS.REMOTE_OTHER_SAME_ADDR	tbd	0,1,2,3	0x53	na	0
HA	0x57	0x4	UNC_H_IODC_CONFLICTS.LAST	tbd	0,1,2,3	0x53	na	0
HA	0x58	0x0	UNC_H_IODC_OLEN_WBMTOI	Num IODC 0 Length Writebacks M to I - All of which are dropped.	0,1,2,3	0x53	na	0
HA	0x59	0x0	UNC_H_IGR_AD_QPI2_ACCUMULATOR	Accumulates the number of credits available to the QPI Link 2 AD Ingress buffer.	0,1,2,3	0x53	na	0
HA	0x59	0x0	UNC_H_IGR_CREDITS_AD_QPI2	Accumulates the number of credits available to the QPI Link 2 AD Ingress buffer.	0,1,2,3	0x53	na	0
HA	0x5a	0x0	UNC_H_IGR_BL_QPI2_ACCUMULATOR	Accumulates the number of credits available to the QPI Link 2 BL Ingress buffer.	0,1,2,3	0x53	na	0
HA	0x5A	0x0	UNC_H_IGR_CREDITS_BL_QPI2	Accumulates the number of credits available to the QPI Link 2 BL Ingress buffer.	0,1,2,3	0x53	na	0
HA	0x60	0x1	UNC_H_SNP_RESP_RECV_LOCAL.RSPI	Number of snoop responses received for a Local  request; Filters for snoops responses of RspI.  RspI is returned when the remote cache does not have the data, or when the remote cache silently evicts data (such as when an RFO hits non-modified data).	0,1,2,3	0x53	na	0
HA	0x60	0x10	UNC_H_SNP_RESP_RECV_LOCAL.RSPxWB	Number of snoop responses received for a Local  request; Filters for a snoop response of RspIWB or RspSWB.  This is returned when a non-RFO request hits in M state.  Data and Code Reads can return either RspIWB or RspSWB depending on how the system has been configured.  InvItoE transactions will also return RspIWB because they must acquire ownership.	0,1,2,3	0x53	na	0
HA	0x60	0x2	UNC_H_SNP_RESP_RECV_LOCAL.RSPS	Number of snoop responses received for a Local  request; Filters for snoop responses of RspS.  RspS is returned when a remote cache has data but is not forwarding it.  It is a way to let the requesting socket know that it cannot allocate the data in E state.  No data is sent with S RspS.	0,1,2,3	0x53	na	0
HA	0x60	0x20	UNC_H_SNP_RESP_RECV_LOCAL.RSPxFWDxWB	Number of snoop responses received for a Local  request; Filters for a snoop response of Rsp*Fwd*WB.  This snoop response is only used in 4s systems.  It is used when a snoop HITM's in a remote caching agent and it directly forwards data to a requestor, and simultaneously returns data to the home to be written back to memory.	0,1,2,3	0x53	na	0
HA	0x60	0x4	UNC_H_SNP_RESP_RECV_LOCAL.RSPIFWD	Number of snoop responses received for a Local  request; Filters for snoop responses of RspIFwd.  This is returned when a remote caching agent forwards data and the requesting agent is able to acquire the data in E or M states.  This is commonly returned with RFO transactions.  It can be either a HitM or a HitFE.	0,1,2,3	0x53	na	0
HA	0x60	0x40	UNC_H_SNP_RESP_RECV_LOCAL.RSPCNFLCT	Number of snoop responses received for a Local  request; Filters for snoops responses of RspConflict.  This is returned when a snoop finds an existing outstanding transaction in a remote caching agent when it CAMs that caching agent.  This triggers conflict resolution hardware.  This covers both RspCnflct and RspCnflctWbI.	0,1,2,3	0x53	na	0
HA	0x60	0x8	UNC_H_SNP_RESP_RECV_LOCAL.RSPSFWD	Number of snoop responses received for a Local  request; Filters for a snoop response of RspSFwd.  This is returned when a remote caching agent forwards data but holds on to its currentl copy.  This is common for data and code reads that hit in a remote socket in E or F state.	0,1,2,3	0x53	na	0
HA	0x60	0x80	UNC_H_SNP_RESP_RECV_LOCAL.OTHER	Number of snoop responses received for a Local  request; Filters for all other snoop responses.	0,1,2,3	0x53	na	0
HA	0xb	0x10	UNC_H_CONFLICT_CYCLES.CMP_FWDS	Count the number of Cmp_Fwd. This will give the number of late conflicts.	0,1,2,3	0x53	na	0
HA	0xb	0x2	UNC_H_CONFLICT_CYCLES.CONFLICT	Counts the number of cycles that we are handling conflicts.	0,1,2,3	0x53	na	0
HA	0xb	0x4	UNC_H_CONFLICT_CYCLES.LAST	Count every last conflictor in conflict chain. Can be used to compute the average conflict chain length as (#Ackcnflts/#LastConflictor)+1. This can be used to give a feel for the conflict chain lenghts while analyzing lock kernels.	0,1,2,3	0x53	na	0
HA	0xb	0x8	UNC_H_CONFLICT_CYCLES.ACKCNFLTS	Count the number of Ackcnflts	0,1,2,3	0x53	na	0
HA	0xc	0x1	UNC_H_DIRECTORY_LOOKUP.SNP	Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.; Filters for transactions that had to send one or more snoops because the directory bit was set.	0,1,2,3	0x53	na	0
HA	0xc	0x10	UNC_H_DIRECTORY_LOOKUP.ANY	Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.	0,1,2,3	0x53	na	0
HA	0xc	0x2	UNC_H_DIRECTORY_LOOKUP.NO_SNP	Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.; Filters for transactions that did not have to send any snoops because the directory bit was clear.	0,1,2,3	0x53	na	0
HA	0xc	0x2	UNC_H_DIRECTORY_LOOKUP.SNOOP_S	Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.	0,1,2,3	0x53	na	0
HA	0xc	0x20	UNC_H_DIRECTORY_LOOKUP.STATE_I	Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.	0,1,2,3	0x53	na	0
HA	0xc	0x40	UNC_H_DIRECTORY_LOOKUP.STATE_S	Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.	0,1,2,3	0x53	na	0
HA	0xc	0x8	UNC_H_DIRECTORY_LOOKUP.SNOOP_A	Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.	0,1,2,3	0x53	na	0
HA	0xc	0x80	UNC_H_DIRECTORY_LOOKUP.STATE_A	Counts the number of transactions that looked up the directory.  Can be filtered by requests that had to snoop and those that did not have to.	0,1,2,3	0x53	na	0
HA	0xD	0x1	UNC_H_DIRECTORY_UPDATE.SET	Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.; Filter for directory sets.  This occurs when a remote read transaction requests memory, bringing it to a remote cache.	0,1,2,3	0x53	na	0
HA	0xd	0x10	UNC_H_DIRECTORY_UPDATE.S2A	Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.	0,1,2,3	0x53	na	0
HA	0xd	0x2	UNC_H_DIRECTORY_UPDATE.I2S	Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.	0,1,2,3	0x53	na	0
HA	0xD	0x2	UNC_H_DIRECTORY_UPDATE.CLEAR	Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.; Filter for directory clears.  This occurs when snoops were sent and all returned with RspI.	0,1,2,3	0x53	na	0
HA	0xd	0x20	UNC_H_DIRECTORY_UPDATE.A2I	Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.	0,1,2,3	0x53	na	0
HA	0xd	0x3	UNC_H_DIRECTORY_UPDATE.ANY	Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.	0,1,2,3	0x53	na	0
HA	0xd	0x4	UNC_H_DIRECTORY_UPDATE.I2A	Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.	0,1,2,3	0x53	na	0
HA	0xd	0x40	UNC_H_DIRECTORY_UPDATE.A2S	Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.	0,1,2,3	0x53	na	0
HA	0xd	0x8	UNC_H_DIRECTORY_UPDATE.S2I	Counts the number of directory updates that were required.  These result in writes to the memory controller.  This can be filtered by directory sets and directory clears.	0,1,2,3	0x53	na	0
HA	0xe	0x2	UNC_H_TxR_AK.CRD_CBO	tbd	0,1,2,3	0x53	na	0
HA	0xF	0x4	UNC_H_TxR_AD.HOM	Counts the number of outbound transactions on the AD ring.  This can be filtered by the NDR and SNP message classes.  See the filter descriptions for more details.; Filter for outbound NDR transactions sent on the AD ring.  NDR stands for non-data response and is generally used for completions that do not include data.  AD NDR is used for transactions to remote sockets.	0,1,2,3	0x53	na	0
